<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C学习笔记12：程序结构</title>
      <link href="/2024/01/17/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(12)/"/>
      <url>/2024/01/17/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(12)/</url>
      
        <content type="html"><![CDATA[<p>这篇介绍下C语言下常用的程序结构。</p><h3 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h3><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><ul><li><p>定义在函数外面的变量是全局变量； </p></li><li><p>全局变量具有全局的生存期和作用域，他们与任何函数都无关，在任何函数内部都可以使用他们； </p></li><li><p>全局变量的初始化：</p><ul><li><p>没有做初始化的全局变量会是0，指针会是NULL；</p></li><li><p>只能用编译时刻已知的值来初始化全局变量，如下是会发生错误的；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> gAll = <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> g2 = gAll;  <span class="comment">//complie error, Do not suggestion</span></span><br></pre></td></tr></table></figure></li><li><p>全局变量的初始化发生在main函数之前；</p></li></ul></li><li><p>如果函数内部存在与全局变量同名的变量，则全局变量被隐藏；</p></li><li><p>静态本地变量：</p><ul><li>在本地变量定义时加上static修饰词成为静态本地变量；</li><li>静态变量具有全局变量的<strong>生存期</strong>，在函数离开时，会继续保持其数值，在程序中，与全局变量存储在同一块区域； </li><li>静态本地变量的初始化只会有一次，后面如果函数再次进入，则这个变量会使用上次的数值；</li><li>静态本地变量具有局部变量的<strong>作用域</strong>，是一种特殊的全局变量。</li></ul></li><li><p>*返回指针的函数：</p><ul><li>返回本地变量的地址是危险的，不建议使用，最好的方式是返回传入的指针；</li><li>返回全局变量或静态本地变量是安全的，返回函数内malloc出来的内存也是安全的，但是容易造成问题。</li></ul></li><li><p>其他注意点：</p><ul><li>不要使用全局变量在函数间传递参数和结果；</li></ul></li></ul><h4 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h4><ul><li><p>编译预处理指令：</p><ul><li>#开头的是编译预处理指令；</li><li>他们不是C语言的成分，但是C语言程序离不开他们；</li><li><code>#define</code>用于定义一个宏；</li></ul></li><li><p>#define <name> <value></p><ul><li>注意后面不需要有分号，名字必须是单词，值可以随意；</li><li>在程序编译器开始编译之前，预处理阶段会将程序中的名字替换成对应的数值，但是注意对于<code>&quot;&quot;</code>内的数据不会被操作；</li><li>使用以下指令可以保存编译期间的中间文件，其中.i的文件是替换后的文件，发生在预处理阶段；</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc xxx.c --save-temps</span><br></pre></td></tr></table></figure></li><li><p>如果一个宏中有其他宏的名字，也是会被替换的，如果一个宏的值超过一行，最后一行之前的行末要加上<code>/</code>符号，宏后面出现的注释不会被当作宏数值的一部分。</p></li><li><p>常使用类似于<code>#define _DEBUG</code>的形式来定义宏用于条件编译；</p></li><li><p>在C语言中有以下提前定义好的宏，可以直接使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__LINE__  <span class="comment">//当前行号</span></span><br><span class="line">__FILE__<span class="comment">//当前文件名</span></span><br><span class="line">__DATE__<span class="comment">//当前程序编译的日期</span></span><br><span class="line">__TIME__<span class="comment">//当前程序编译的时间</span></span><br><span class="line">__STDC__<span class="comment">//按照ANSIC的便准编译程序</span></span><br></pre></td></tr></table></figure></li><li><p>带参数的宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> cube(x) ((x)*(x)*(x))</span></span><br></pre></td></tr></table></figure><p>错误的使用方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RADTODEG1(x) (x)*57.29578</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RADTODEG2(x) (x*57.29578)</span></span><br><span class="line">ptintf(<span class="string">&quot;%f\n&quot;</span>, RADTODEG2(<span class="number">5</span>+<span class="number">2</span>));     <span class="comment">//5 + 2 * 57.29578</span></span><br><span class="line">ptintf(<span class="string">&quot;%f\n&quot;</span>, <span class="number">180</span>/RADTODEG1(<span class="number">2</span>));   </span><br></pre></td></tr></table></figure><p>正确的定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RADTODEG2(x) ((x)*57.29578)</span></span><br></pre></td></tr></table></figure><p>一切都要有括号，整个值要有括号，参数出现的每个地方要有括号；</p><p>可以带多个参数，例如如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(A&gt;B) (A)&gt;(B)?(A):(B)</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="大程序结构"><a href="#大程序结构" class="headerlink" title="大程序结构"></a>大程序结构</h4><ul><li><p>编译单元：一个.c文件就是一个编译单元，编译器每次编译只能处理一个编译单元；</p></li><li><p>函数原型：</p><ul><li>如果没有函数原型，编译器会去猜测所调用函数的原型；需要在调用的地方给出函数的原型，以告诉编译器那个函数长什么样子。</li></ul></li><li><p>头文件：包含若干个函数原型，使用时include</p><ul><li>inlude头文件其实就是将头文件内的代码拷贝至引用处，和宏类似；</li><li>不一定在源文件开头inlude头文件；</li><li>两种形式：&lt;&gt; “ “ 前者去编译器指定目录查找，后者先在当前目录查找，再去指定目录；</li><li>注意include不是引用库的，现在的C语言默认会引入所有的标准库，#include &lt;stdio.h&gt;是为了让编译器知道printf函数的原型，保证在调用时给出的参数值是正确的类型。</li><li>对于不对外公开的函数，在前面加上static关键词就行</li></ul></li><li><p>变量的声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>;  <span class="comment">//定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i; <span class="comment">//声明</span></span><br></pre></td></tr></table></figure><p>声明不会产生代码，定义才会有代码。同一个编译单元内，同名的结构不能被重复声明，要用标准头文件结构进行书写头文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifnef __LIST_HEAD__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LIST_HEAD__</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> code </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li><p>在有些程序中，没有写#include &lt;stdlio.h&gt; ，但是程序还是可以正常执行，是为什么？ 什么情况下#include头文件，编译成功，但是不能运行。</p><ul><li><p>&lt;stdio.h&gt;太常用，现代编译器已经自动添加了；</p></li><li><p>编译产生了链接，但不导入库就没有相应的01代码。</p></li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这节课的内容收获很多，感觉学习这些，让自己慢慢知道为什么在写程序时应该这样做，搞清楚了所以然。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C学习笔记11：链表</title>
      <link href="/2024/01/09/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(11)/"/>
      <url>/2024/01/09/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(11)/</url>
      
        <content type="html"><![CDATA[<p>这篇介绍下C语言该如何使用。</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="可变数组"><a href="#可变数组" class="headerlink" title="可变数组"></a>可变数组</h4><p>头文件如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">ifndef</span> _RESIZEARRAY_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _RESIZEARRAY_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">int</span> *<span class="built_in">array</span>;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line">&#125;Array;   </span><br><span class="line"></span><br><span class="line">Array <span class="title function_">array_create</span><span class="params">(<span class="type">int</span> init_size)</span>;   <span class="comment">//create a array with malloc</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_free</span><span class="params">(Array *a)</span>;           <span class="comment">//free array memory</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_size</span><span class="params">(<span class="type">const</span> Array *a)</span>;      <span class="comment">//get size of array</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">array_at</span><span class="params">(Array *a,<span class="type">int</span> index)</span>;   <span class="comment">//get number of the index</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">array_inflate</span><span class="params">(Array *a, <span class="type">int</span> more_size)</span>;  <span class="comment">//expand array</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>源文件如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ResizeArray.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入：数组的大小</span></span><br><span class="line"><span class="comment">返回：可变数组</span></span><br><span class="line"><span class="comment">备注：返回采用临时变量传递</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Array <span class="title function_">array_create</span><span class="params">(<span class="type">int</span> init_size)</span></span><br><span class="line">&#123;</span><br><span class="line">Array a;</span><br><span class="line">a.<span class="built_in">array</span> = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*init_size);</span><br><span class="line">a.size = init_size;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">array_free</span><span class="params">(Array *a)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(a-&gt;<span class="built_in">array</span>);</span><br><span class="line">a-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">array_size</span><span class="params">(<span class="type">const</span> Array *a)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*a: 可变数组，指针传递</span></span><br><span class="line"><span class="comment">index: 索引</span></span><br><span class="line"><span class="comment">返回：指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">array_at</span><span class="params">(Array *a,<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(index &gt;= a-&gt;size)&#123;</span><br><span class="line">array_inflate(a , index-a-&gt;size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;(a-&gt;<span class="built_in">array</span>[index]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> *<span class="title function_">array_inflate</span><span class="params">(Array *a, <span class="type">int</span> more_size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(a-&gt;size + more_size)+<span class="number">1</span>);  <span class="comment">//注意加1</span></span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span>*)p,(<span class="type">void</span>*)a-&gt;<span class="built_in">array</span>,(a-&gt;size)*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">free</span>(a-&gt;<span class="built_in">array</span>);</span><br><span class="line">a-&gt;<span class="built_in">array</span> = p;</span><br><span class="line">a-&gt;size = a-&gt;size + more_size+<span class="number">1</span>;  <span class="comment">//注意加1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">Array a = array_create(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a size = %d\n&quot;</span>,array_size(&amp;a));</span><br><span class="line">*(array_at(&amp;a,<span class="number">10</span>)) = <span class="number">1</span>;     <span class="comment">//传出的是个指针，使用*进行解指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the number is %d\n&quot;</span>,*(array_at(&amp;a,<span class="number">10</span>)));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变数组在实现过程中，使用malloc分配一段内存，之后如果需要增加数组的容量，采用重新分配更大内存，将原有数据通过memcpy函数拷贝至新分配的空间，达到可变的目标。这么做在数据操作上很繁琐，而且也不能保证分配的空间不会发生越界。</p><h4 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h4><p>头文件如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _NODE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NODE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node</span>&#123;</span></span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">node</span> *<span class="title">next</span>;</span>   <span class="comment">//指向下一个节点</span></span><br><span class="line">&#125;Node;  <span class="comment">//链表节点</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(List *pList, <span class="type">int</span> number)</span>;    <span class="comment">//add node to linklist</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(List *pList)</span>;              <span class="comment">//print linklist</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(List *pList, <span class="type">int</span> number)</span>;  <span class="comment">//search data in linklist with number</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(List *pList, <span class="type">int</span> number)</span>; <span class="comment">//delete date in linklist with number</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearList</span><span class="params">(List *pList)</span>;          <span class="comment">//clear data</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>源文件如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;node.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">list</span> &#123;</span></span><br><span class="line">Node *head;</span><br><span class="line">&#125;List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">List <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span>.head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line">    <span class="comment">// input data to list </span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;number);</span><br><span class="line"><span class="keyword">if</span>( number != <span class="number">-1</span>)&#123;</span><br><span class="line">add(&amp;<span class="built_in">list</span>,number);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(number != <span class="number">-1</span>);   <span class="comment">//abort while when input -1</span></span><br><span class="line">print(&amp;<span class="built_in">list</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;number);</span><br><span class="line">search(&amp;<span class="built_in">list</span>,number);  </span><br><span class="line">delete(&amp;<span class="built_in">list</span>,number);</span><br><span class="line">print(&amp;<span class="built_in">list</span>);</span><br><span class="line">clearList(&amp;<span class="built_in">list</span>);</span><br><span class="line">print(&amp;<span class="built_in">list</span>);    <span class="comment">//with cleared linklist, so print log is error</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">clearList</span><span class="params">(List *pList)</span></span><br><span class="line">&#123;</span><br><span class="line">Node *p,*q;  <span class="comment">//two pointer </span></span><br><span class="line">q = <span class="literal">NULL</span>;  </span><br><span class="line"><span class="keyword">for</span>(p=pList-&gt;head; p; p=q)&#123;</span><br><span class="line">q = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(List *pList, <span class="type">int</span> number)</span></span><br><span class="line">&#123;</span><br><span class="line">Node *p , *q;</span><br><span class="line"><span class="keyword">for</span>(q=<span class="literal">NULL</span>, p=pList-&gt;head; p; q=p,p=p-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;value == number)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(q)&#123;  </span><br><span class="line">q-&gt;next = p-&gt;next;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123; <span class="comment">//sepcial condition q ==NULL</span></span><br><span class="line">pList-&gt;head = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(List *pList, <span class="type">int</span> number)</span></span><br><span class="line">&#123;</span><br><span class="line"> Node *p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line"> p-&gt;value = number;</span><br><span class="line"> p-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line"> Node *last = pList-&gt; head;</span><br><span class="line"> <span class="keyword">if</span>(last)&#123;</span><br><span class="line"><span class="keyword">while</span>(last-&gt;next)&#123;</span><br><span class="line">  last = last-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">last-&gt;next = p;</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">pList-&gt;head = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(List *pList)</span></span><br><span class="line">&#123;</span><br><span class="line">  Node *p;</span><br><span class="line">  <span class="keyword">for</span>(p = pList-&gt;head; p; p=p-&gt;next)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,p-&gt;value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(List *pList, <span class="type">int</span> number)</span></span><br><span class="line">&#123;</span><br><span class="line"> Node *p;</span><br><span class="line"><span class="type">int</span> isFound = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>( p=pList-&gt;head; p; p = p-&gt;next)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">if</span>( p-&gt;value == number)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the number is founded\n&quot;</span>);</span><br><span class="line">   isFound = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( isFound != <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;No found\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isFound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初步了解下链表的实现，对于一些特殊情况，还不是特别的清楚，后面有时间再看一下。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C学习笔记10：结构类型</title>
      <link href="/2023/12/27/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(10)/"/>
      <url>/2023/12/27/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(10)/</url>
      
        <content type="html"><![CDATA[<p>这篇介绍下其他常用的结构类型。</p><h3 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h3><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><ul><li><p>枚举是一种用户定义的数据类型，它用关键字<code>enum</code>以下语法来声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum 枚举类型名字 &#123;名字0，....名字n&#125;;</span><br></pre></td></tr></table></figure></li><li><p>枚举类型的名字通常不真的使用，要用的是大括号里的名字，因为他们就是常量符号，他们的类型是int,值则依次从0到n。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> &#123;</span>RED,YELLOW,GREEN&#125;l;   <span class="comment">//RED = 0, GREEN = 2;</span></span><br></pre></td></tr></table></figure></li><li><p>枚举量可作为值，枚举类型可以跟上enum作为类型，但实际上是以整数来做内部计算和外部输入输出的。</p></li><li><p>声明枚举量的时候可以指定值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> &#123;</span>red=<span class="number">1</span>,yellow,green=<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p>虽然枚举类型可以作为类型使用，但实际上不好用，如果有意义上排比的名字，用枚举比const int方便，枚举比宏好，因为枚举有int类型。</p></li></ul><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">&#125;;    <span class="comment">//结构体的声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">today</span>;</span>   <span class="comment">//结构体的定义；</span></span><br><span class="line">today.month = <span class="number">07</span>;    <span class="comment">//结构体的使用</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;p1,p2;     <span class="comment">//p1和p2都是一种无名结构，里面有x和y;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;p1,p2;    <span class="comment">//p1和p2都是ponit，里面有x和y的值，比较常用  声明+定义</span></span><br></pre></td></tr></table></figure><ul><li><p>和本地变量一样，在函数内部声明的结构体类型只能在函数内部使用，所以通常在函数外部声明结构体类型，这样多个函数都可以使用。</p></li><li><p>结构体初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">today</span> =</span> &#123;<span class="number">07</span>,<span class="number">31</span>,<span class="number">2023</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">thismonth</span> =</span> &#123;.month = <span class="number">7</span>,.year = <span class="number">2023</span>&#125;;  <span class="comment">//day默认0</span></span><br></pre></td></tr></table></figure></li><li><p>结构体成员：用符号<code>.</code>和名字访问其成员；结构类型是虚的，结构变量才是实体。</p></li><li><p>结构体运算：对于整个结构，可以做赋值，取地址，也可以传递给函数参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1 = (<span class="keyword">struct</span> point)&#123;<span class="number">1</span>,<span class="number">10</span>&#125;;</span><br><span class="line">p1 = p2;  <span class="comment">//p1.x = p2.x  p1.y=p2.y</span></span><br></pre></td></tr></table></figure></li><li><p>结构指针：和数组不同，结构变量的名字并不是结构变量的地址，必须使用**&amp;**运算符；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> *<span class="title">pDate</span> =</span> &amp;today;</span><br></pre></td></tr></table></figure></li><li><p>结构作为函数参数，整个结构可以作为参数的值传入函数，这时是在函数内新建一个结构变量，并赋值调用者的结构的值，也可以返回一个结构，更好的方式是通过指针的形式传递。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">nuberofDays</span><span class="params">(<span class="keyword">struct</span> date d)</span></span><br></pre></td></tr></table></figure></li><li><p>指向结构的指针：用<code>-&gt;</code>表示指针所指的结构变量中的成员,是一个运算符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> *<span class="title">p</span> =</span> &amp;myday;</span><br><span class="line">(*p).month = <span class="number">12</span>;</span><br><span class="line">p-&gt;month = <span class="number">12</span>;</span><br></pre></td></tr></table></figure></li><li><p>结构数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">dates</span>[100];</span>  <span class="comment">//定义一个结构体数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">dates</span>[] =</span> &#123;</span><br><span class="line">    &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">2005</span>&#125;,&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">2005</span>&#125;</span><br><span class="line">&#125;;  <span class="comment">//初始化结构体数组</span></span><br></pre></td></tr></table></figure></li><li><p>结构中的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dateAandTime</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">sdate</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">time</span> <span class="title">stime</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结构与数组的联系与区别：数组成员类型确定且唯一，结构成员类型确定不唯一；结构可以进行赋值，数组不能直接赋值数组；数组为连续控制，结构不一定。都是数据容器，一个放的是同种类型的，一个放的是多种类型的。</p></li><li><p>对于结构体，使用sizeof求值，并且想想他的地址；</p><ul><li>结构体变量中成员的偏移量必须是其成员大小的整数倍；</li><li>结构的大小必须是所有成员大小的整数被，也就是所有成员大小的公倍数；</li><li>下面结构体变量大小为16字节，数据变量按照4字节对齐。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myStruct</span>&#123;</span></span><br><span class="line">     <span class="type">char</span> a;</span><br><span class="line">     <span class="type">int</span> b;</span><br><span class="line">     <span class="type">long</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h4><ul><li><p>自定义数组类型（typedef)</p><ul><li><p>C语言提供了一个叫做typedef的功能来声明一个已有的数据类型新名字；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Length;  <span class="comment">//Length就是指int类型</span></span><br></pre></td></tr></table></figure></li><li><p>改善程序的可读性，看最后的那个单词</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ADate</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">&#125;Date;</span><br><span class="line">Date d = &#123;<span class="number">9</span>,<span class="number">10</span>&#125;;  <span class="comment">//使用Date代替 struct ADate</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>union</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">AnElt</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;elt1,elt2;</span><br><span class="line">elt1.i = <span class="number">4</span>;</span><br><span class="line">elt1.c = <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>与struct相似，但是区别在于内部的变量公用一个最大的空间，也就是sizeof(union …) &#x3D; sizeof(每个成员)的最大值；</li></ul></li><li><p>大小端（1234在内存中的存储形式）</p><ul><li>小端：低位在前 D2_04_00_00</li><li>大端：高位在前 00_00_04_D2</li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>主要搞明白了结构体中的符号，以及大小端的含义，结构体的定义使用等。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理学习笔记02：系统总线</title>
      <link href="/2023/12/26/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B%EF%BC%9A%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(02)/"/>
      <url>/2023/12/26/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B%EF%BC%9A%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(02)/</url>
      
        <content type="html"><![CDATA[<h3 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h3><h4 id="总线的基本概念"><a href="#总线的基本概念" class="headerlink" title="总线的基本概念"></a>总线的基本概念</h4><ul><li>总线是连接多个部件的信息传输线，是各个部件共享的传输介质。</li></ul><h4 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h4><ul><li>数据传送方式：并行传输（8位，16位，32位，64位）和串行传输总线；</li><li>使用范围：计算机总线，测控总线，网络通信总线等；</li><li>连接部件：<ul><li>片上总线：CPU内部寄存器与寄存器之间的连接线；</li><li>系统总线：CPU 存储 I&#x2F;O设备三者之间的信息传输线；<ul><li>总线传输信息不同：数据总线，地址总线（20根，2的20次方&#x3D;1M），控制总线；</li></ul></li><li>通信总线：<ul><li>传输方式：串行通信和并行通信；</li></ul></li></ul></li></ul><h4 id="总线的特性及性能指标"><a href="#总线的特性及性能指标" class="headerlink" title="总线的特性及性能指标"></a>总线的特性及性能指标</h4><ul><li>总线特性：机械特性，电气特性（信号的传递方向和有效的电平范围），功能特性（指每根传输线的功能），时间特性（信号时序图表示）。</li><li>总线性能指标：<ul><li>总线宽度：数据总线的根数；</li><li>总线带宽：总线的数据传输速率，单位时间内总线上传输数据的位数。MBps 如果工作频率为33MHz,宽度为32，则带宽为33 * （32&#x2F;8） &#x3D; 132 MBps.</li><li>时钟同步&#x2F;异步；总线复用，信号线数（地址+数据+控制），总线控制方式等。</li></ul></li><li>总线的标准<ul><li>IAS总线，又称AT总线</li><li>EISA总线，相比于IAS总线，它可以从CPU中分离了总线控制权；</li><li>VESA总线，局部总线；</li><li>PCI总线，可以解决上述三类总线低带宽的问题。具有高性能，支持突发工作方式，良好的兼容性，支持即插即用，支持多主设备能力，具有与处理器和存储子系统完全并行操作的能力；采用多路复用等等。</li><li>AGP总线</li><li>RS-232总线：高电平表示逻辑0，电压范围+3到+15.</li><li>USB总线：具有很强的连接能力，传输速率USB2.0可以到达480Mbps。</li></ul></li></ul><h4 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h4><ul><li>单总线结构，什么设备都在一条总线上</li><li>多总线结构：双总线，三总线，四总线（局部总线连接CPU与Cache,系统总线连接Cache与主存，高速总线连接Cache与其他高速设备，低速总线连接低速设备与高速总线）</li><li>总线结构举例： 传统的微机总线结构，VL-BUS局部总线结构（只适用于特定的CPU），PCI总线结构，多层PCI总线结构（PCI总线驱动能力不足时采用）</li></ul><img src="f56TIywNGRDiVAe.png" style="zoom:50%;" /><h4 id="总线的控制"><a href="#总线的控制" class="headerlink" title="总线的控制"></a>总线的控制</h4><p>主要包括判优控制和通信控制。</p><ul><li>总线判优控制：分为集中式和分布式两种，主要用于多个设备同事要用设备时，如何选择的问题。集中式是将选择权交给CPU，分布式是将选择权交给各个设备。<ul><li>集中式：链式查询（线路简单，靠近CPU的设备优先级高），计数器定时查询（增加设备地址线改变设备使用总线的优先级），独立请求方式（使用的线多）</li></ul></li><li>总线的通信控制：解决通信双方如何获知<strong>传输开始和传输结束</strong>的，以及双方如何协调于配合。<ul><li>总线周期：申请分配阶段 + 寻址阶段 + 传数阶段 + 结束阶段</li><li>四种方式：<ul><li>同步通信：双方由统一的时标控制数据传输；用于传输速度差不多的模块中</li><li>异步通信：采用应答方式（不互锁，半互锁，全互锁），异步串行通信传输速率用波特率衡量，表示单位时间内传输二进制数据的位数；</li><li>半同步通信：增加一个WAIT信号，采用插入时钟周期的措施来协调通信双方的配合问题。</li><li>分离式通信</li></ul></li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>了解了总线的分类，一些特性指标，总线的控制方式，和在计算机系统中，总线的结构。</p>]]></content>
      
      
      <categories>
          
          <category> 理论课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题笔记05：合并两个有序的链表</title>
      <link href="/2023/12/26/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B005/"/>
      <url>/2023/12/26/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B005/</url>
      
        <content type="html"><![CDATA[<h4 id="合并两个有序的链表"><a href="#合并两个有序的链表" class="headerlink" title="合并两个有序的链表"></a>合并两个有序的链表</h4><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><img src="jS64aJgQB9Z8f3t.png" style="zoom: 50%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><h4 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h4><p><strong>暴力迭代法</strong></p><p>这种方法的思想是先申请一个对应数据类型的空间，用一个指针来指向这个空间，通过指针对这个新申请的空间进行初始化，再用另外一个指针指向这个指针，这么做的作用是可以直接返回ret。利用while循环，在循环内进行判断，使用tmp指针将这两个链表按照规则串起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">mergeTwoLists</span><span class="params">(<span class="keyword">struct</span> ListNode* list1, <span class="keyword">struct</span> ListNode* list2)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!list1) <span class="keyword">return</span> list2;</span><br><span class="line">    <span class="keyword">if</span>(!list2) <span class="keyword">return</span> list1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">ret</span> =</span> (<span class="keyword">struct</span> ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    ret -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tmp</span>  =</span> ret; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(list1 &amp;&amp; list2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(list1-&gt;val &gt;= list2-&gt;val )</span><br><span class="line">        &#123;</span><br><span class="line">            tmp-&gt;next = list2;</span><br><span class="line">            list2 = list2-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tmp-&gt;next = list1;</span><br><span class="line">             list1 = list1-&gt;next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list1)      tmp-&gt;next = list1;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (list2) tmp-&gt;next = list2;</span><br><span class="line">    <span class="keyword">return</span> ret-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：结构体内变量的使用采用<code>-&gt;</code>符号。判断指针不为空，可以直接将该变量写入到括号内。新申请的那个ret指针需要进行初始化赋值。</p><p><strong>递归的方法</strong></p><p>递归的核心就在于如果每一次需要做的操作都一样，那么就可以采用递归。这个程序的核心思想在于一次又一次再套娃一样，直到找到list1或list2为NULL，找到之后，就代表这个链表遍历结束，那么就开始从这个点返回，一层又一层。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(list1 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> list2;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span>(list2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> list1;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span>(list1-&gt;val &lt; list2 -&gt;val)&#123;</span><br><span class="line">           list1-&gt;next = <span class="built_in">mergeTwoLists</span>(list1-&gt;next,list2);</span><br><span class="line">           <span class="keyword">return</span> list1;</span><br><span class="line">       &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">           list2 -&gt;next = <span class="built_in">mergeTwoLists</span>(list1,list2-&gt;next);</span><br><span class="line">           <span class="keyword">return</span> list2;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>递归的方法使代码看起来比较巧妙，但是不易懂，另外一种方法看起来比较舒服。通过这个题目，也复习了动态分配内存，链表的操作，指针的操作等内容。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C学习笔记09：指针与字符串（二）</title>
      <link href="/2023/12/26/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(09)/"/>
      <url>/2023/12/26/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(09)/</url>
      
        <content type="html"><![CDATA[<p>这篇继续学习与指针相关的内容，遨游在指针的世界内。</p><h3 id="指针与字符串（二）"><a href="#指针与字符串（二）" class="headerlink" title="指针与字符串（二）"></a>指针与字符串（二）</h3><h4 id="指针的使用"><a href="#指针的使用" class="headerlink" title="指针的使用"></a>指针的使用</h4><img src="1c8UXfwz5uGvIJ3.png" style="zoom:50%;" /><ul><li><p>指针的应用场景：</p><ul><li>交换两个变量的值，函数返回<strong>多个</strong>值，某些值就只能通过指针返回，传入的参数实际上是需要保存带回结果的变量。</li><li>函数返回运算的状态，结果通过指针返回，常用的套路就是让函数返回特殊的不属于有效范围内的值表示出错（-1和0）</li></ul></li><li><p>指针常见的错误：定义了指针变量，还没有指向任何变量，就开始使用指针（<strong>未初始化指针变量</strong>）；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> k = <span class="number">12</span>;</span><br><span class="line">*p = k;    <span class="comment">//!这是错误的写法。</span></span><br></pre></td></tr></table></figure></li><li><p>传入函数的数组成为什么？  成了一个指针，但是可以用数组的运算符<code>[]</code>进行运算；数组变量是const的指针，所以不能被赋值，<code>int b[] --&gt; int * const b</code>。</p></li><li><p>指针与const</p><ul><li><p>表示一旦得到了某个变量的地址，不能再指向其他变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="type">const</span> q = &amp;i; <span class="comment">// q is const</span></span><br><span class="line">*q = <span class="number">26</span>;  <span class="comment">//ok</span></span><br><span class="line">q ++; <span class="comment">//error   </span></span><br><span class="line">--------------------------------</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;i;</span><br><span class="line">*p = <span class="number">26</span>; <span class="comment">//error (*p) is const;</span></span><br><span class="line">i = <span class="number">26</span>; <span class="comment">//ok</span></span><br><span class="line">p = &amp;j; <span class="comment">//ok</span></span><br></pre></td></tr></table></figure></li><li><p>判断哪个被const了的标志是const在*的前面还是后面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> * p1 = &amp;i;  <span class="comment">//1</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *p2 = &amp;i;   <span class="comment">//1</span></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p3 = &amp;i;  <span class="comment">//2</span></span><br></pre></td></tr></table></figure></li><li><p>总是可以把一个非const的值转换成const的，当要传递的参数的类型比地址大的时候，这是常用的手段；既能用比较少的字节数传递值给参数，又能避免函数对外面的变量的修改。</p></li><li><p>const数组，数组变量已经是const的指针了，这里的const表明数组的每个单元都是const int，所以必须通过初始化进行赋值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a[],<span class="type">int</span> len)</span>; <span class="comment">//const 可以保护数组不被破坏</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>数组变量可以被看做const的指针变量，到底是“可以被看作”，还是就是指针呢？</p><p>答案：可以被看做</p></li></ul><h4 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h4><ul><li><p>指针加一，加的不是1，而是这个类型的<code>sizeof</code>; 移动指针到下一个单元。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ac[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">char</span> *p = ac;</span><br><span class="line">p = p +<span class="number">1</span>;    <span class="comment">//p = p + sizeof(ac[0]);  sizeof(ac[0]) = 1;</span></span><br><span class="line"><span class="type">int</span> ac[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>  *q = ac;</span><br><span class="line">q = q +<span class="number">1</span>;    <span class="comment">//q = q + sizeof(ac[0]);   sizeof(ac[0]) = 4;</span></span><br></pre></td></tr></table></figure></li><li><p>给一个指针加1表示要让指针指向下一个变量，如果指针不是指向一片连续分配的空间，如数组，则这种运算没有意义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p = a;</span><br><span class="line">*(p+<span class="number">1</span>) = a[<span class="number">1</span>];</span><br></pre></td></tr></table></figure></li><li><p>对于指针，还可以给指针加，减一个整数，递增或递减和两个指针相减（给的是两个地址的差&#x2F;sizeof(类型))，表示能放几个这样的类型。</p></li><li><p><code>*p++</code>：取出p所指的那个数据来，完事之后顺便把p移到下一个位置去。*的优先级虽然高，但是没有++高，常用于数组类的连续空间操作，在某些CPU上，这可以被翻译诚一条汇编指令。</p></li><li><p>指针的比较：<code>&lt; &lt;= == &gt; &gt;= !=</code>都可以对指针做，比较他们在内存中的地址，数组中的单元地址肯定是线性递增的。</p></li><li><p><code>0地址</code>: 内存中的0地址通常是不能操作的地址，所以你的指针不应该具有0值，因此可以用0地址表示一些特殊的事情：返回的指针是无效的，指针没有被真正初始化（先初始化0）。<code>NULL</code>大写是一个预定义的符号，表示0地址。</p></li><li><p>指针类型的转换</p><ul><li><p><code>void*</code>表示不知道指向什么东西的指针，计算时与<code>char*</code>相同（但不相通）</p></li><li><p>以下代码并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看它所指的变量（我不再当你是int啦，我认为你是一个void）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = &amp;i;</span><br><span class="line"><span class="type">void</span> *q = (<span class="type">void</span>*)p;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>动态内存分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> *a = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>));   <span class="comment">//void * malloc(size_t size); 原型</span></span><br><span class="line"><span class="built_in">free</span>(a);</span><br></pre></td></tr></table></figure><ul><li>向malloc申请的空间的大小是以<strong>字节</strong>为单位的；</li><li>返回的结果是<code>void*</code>，需要类型转换为自己需要的类型；</li><li>申请时如果空间已经用完，则返回NULL；</li><li>free释放内存空间，free中的这个地址必须是<strong>申请获得的地址</strong>，如果这个地址进行了相加或赋值，则均无法释放申请的空间，free(0)不会出错。</li><li>free过了再次free也会出问题。malloc申请的内存空间不一定连续。</li></ul></li><li><p>其他注意事项：</p><ul><li>如果程序中用到动态分配的内存，并且会在函数之间传递，不要让函数申请内存后返回给调用者，因为十有八九调用者会忘了free，或找不到合适的时机来free，好的模式是让调用者自己申请，传地址进函数，函数再返回这个地址出来。说白了就是如果有两个函数A和B，其中A调用B，那么你就让A申请，传地址给B去使用，不要在B中申请。</li><li>函数返回指针，如果是本地变量，函数离开后，这些变量不存在，所指地址不可使用；对于传入的指针，动态申请的内存和全局变量，返回指针都没问题；</li></ul></li></ul><h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><ul><li><p>putchar</p><ul><li><pre><code class="c">int putchar(int c);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 向标准输出写一个字符，返回写了几个字符，EOF（-1）表示写失败；</span><br><span class="line"></span><br><span class="line">- getchar</span><br><span class="line"></span><br><span class="line">  - ```c</span><br><span class="line">    int getchar(void);</span><br></pre></td></tr></table></figure></code></pre></li><li><p>向标准输入读入一个字符，返回类型是int是为了返回EOF(-1)</p></li><li><p>在使用时，对于Linux系统，输入Ctrl + D可以结束输入的获取。</p></li></ul></li><li><p>对于标准输入和输出，是三层结构，中间是shell，shell这个程序帮我我们传递我们的输入和输出。它会有一个行缓冲，如果没有接收到回车，就一直填充至缓冲区，如果有回车，则把这个行缓冲内的东西，输入给程序。</p></li></ul><h4 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h4><ul><li><p>char **a：a是一个指针，指向另一个指针，那个指针指向一个字符串</p></li><li><p>程序参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br></pre></td></tr></table></figure><ul><li>char * argv[] : 所代表的含义为有一个数组，数组的每一个单元放的是指针，每一个指针指向一个字符串;</li><li>argv[0]是命令本身，当使用Unix的符号链接时，反映符号链接的名字；</li></ul></li></ul><h4 id="字符串函数的实现"><a href="#字符串函数的实现" class="headerlink" title="字符串函数的实现"></a>字符串函数的实现</h4><ul><li><p>strlen函数</p><ul><li><pre><code class="c">size_t strlen(const char *s)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 返回s的字符串长度（不包括结尾的0），sizeof包括结尾0；</span><br><span class="line"></span><br><span class="line">- strcmp函数</span><br><span class="line"></span><br><span class="line">  - ```c</span><br><span class="line">    int strcmp(const char *s1,const char *s2);</span><br></pre></td></tr></table></figure></code></pre></li><li><p>比较两个字符串，返回： 0 s1 &#x3D;&#x3D; s2  1 s1 &gt; s2  -1 s1 &lt; s2</p></li><li><p>自定义该函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mycmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1,<span class="type">const</span> <span class="type">char</span> *s2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(*s1 == *s2 &amp;&amp; *s1 != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        s1++;</span><br><span class="line">        s2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *s1 - *s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>strcpy函数</p><ul><li><pre><code class="c">char * strcpy(char *restrict dst,const char* restrict src);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- restrict表明src和dst不重叠，返回dst,为了能连起代码来。</span><br><span class="line"></span><br><span class="line">- 复制一个字符串</span><br><span class="line"></span><br><span class="line">  ```c</span><br><span class="line">  char *dst = (char*)malloc(strlen(src) + 1) //+1代表加上后面的\0.</span><br><span class="line">  strcpy(dst,src);</span><br></pre></td></tr></table></figure></code></pre></li><li><p>自定义该函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">mycpy</span><span class="params">(<span class="type">char</span> *dst,<span class="type">const</span> <span class="type">char</span> *src)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *ret = dst;</span><br><span class="line">    <span class="keyword">while</span>(*src)&#123;</span><br><span class="line">        *dst++ = *src++;</span><br><span class="line">    &#125;</span><br><span class="line">    *dst = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>其他函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s1, <span class="type">const</span> <span class="type">char</span> *s2)</span>;  <span class="comment">//在s1中查找s2;</span></span><br><span class="line"><span class="type">char</span> * <span class="title function_">strcasestr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1,<span class="type">const</span> <span class="type">char</span> *s2)</span>;   <span class="comment">//查找字符串中，忽略大小写</span></span><br><span class="line"><span class="type">char</span> * <span class="title function_">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s,<span class="type">int</span> c)</span>;   <span class="comment">//从左向右在字符串s中寻找c;</span></span><br><span class="line"><span class="type">char</span> * <span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *s1,<span class="type">char</span> *s2)</span>; <span class="comment">//字符串拼接函数</span></span><br></pre></td></tr></table></figure><ul><li><p>小技巧：获取指定字符前面的字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *p = <span class="built_in">strchr</span>(s,<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">    <span class="type">char</span> c = *p;</span><br><span class="line">    *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> *t = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(s)+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(t,s);   <span class="comment">//此时t中存放着he</span></span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>了解了指针的使用，比如交换变量，传参，学习了动态分配内存，学习了字符串的定义，操作，还有指针的运算，总的讲，这一节内容比较多。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C学习笔记09：指针与字符串</title>
      <link href="/2023/12/13/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(08)/"/>
      <url>/2023/12/13/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(08)/</url>
      
        <content type="html"><![CDATA[<p>这篇初步回忆一下有关字符串的相关内容，</p><h3 id="指针与字符串"><a href="#指针与字符串" class="headerlink" title="指针与字符串"></a>指针与字符串</h3><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><ul><li><p><code>sizeof</code>是一个运算符，给出某个类型或变量在内存中所占的字节数；在程序中，字节可以用英文Byte表示，1个字节等于8位，位使用Bit表示。</p></li><li><p><code>&amp;</code>是C语言的一个运算符，可以获得变量的地址，它的操作数必须是变量；在使用printf作为输出内容时，如果想输出地址，可以加上<code>&quot;%p&quot;</code>，就直接输出地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;i);</span><br></pre></td></tr></table></figure></li><li><p><code>&amp;</code>取地址符号右侧必须是一个明确的变量，<code>&amp;(i++)</code>这种是不可以的。</p></li><li><p>在C语言的内存模型中，对于变量的存储的栈空间，采用从顶向下的的存储方式；对于数组，以下表达方式是等价的,都是表达的数组的起始地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,i);</span><br></pre></td></tr></table></figure></li><li><p>指针就是保存地址的变量，定义和用法如下 ，指针可以作为一个参数，来传入子函数中，子函数就可以使用这个指针，访问外面的数值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span>* p = &amp;i;   <span class="comment">//p指向i,例如&amp;i = 0x2000,那么p这个指针变量内存储的就是这个数值；</span></span><br><span class="line"><span class="type">int</span>* p,q;      <span class="comment">//定义p为指针，q为int类型；</span></span><br><span class="line"><span class="type">int</span> *p,q;      <span class="comment">//同上，所以*是指代变量的，没有int*这种类型；</span></span><br></pre></td></tr></table></figure></li><li><p><code>*</code>是一个单目运算符，用来访问指针的值所表示的地址上的变量，可以做右值，也可以做左值，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> k = *p;  <span class="comment">//*p可以被看做一个整体，代表这个地址的数值</span></span><br><span class="line">*p = k+<span class="number">1</span>;</span><br><span class="line">*p++;  <span class="comment">//这种是地址进行++，不对地址内的变量进行改变</span></span><br><span class="line">(*p)++;      <span class="comment">//这种写法就是对地址的数值进行加加，综上*的运算符没有++优先级高；</span></span><br><span class="line">p++;         <span class="comment">//对地址进行++</span></span><br></pre></td></tr></table></figure></li><li><p>数组的名字其实是指针，是<strong>特殊</strong>的地址，是const指针<code>int a[] &lt;==&gt; int * const a</code>。在数组作为参数传入子程序过程中，定义为指针，大小是4个字节，不能在[]中写具体的值，因为是指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">minmax</span><span class="params">(<span class="type">int</span> a[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">minmax</span><span class="params">(<span class="type">int</span> *a)</span>;</span><br><span class="line"><span class="comment">//以下四种等价</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *ar,<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *,<span class="type">int</span> )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> ar[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> [],<span class="type">int</span> )</span>;</span><br></pre></td></tr></table></figure></li><li><p>数组和指针的关系：数组的地址是常量地址，这一点可以看做常量指针，但它自己本身可以改写变量，不是const指针。</p></li></ul><h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><ul><li><p><code>char</code>是一种整数，也是一种特殊的类型：字符。在printf中采用<code>%c</code>输出，每一个字符串都用整数来表示，叫成ASCII码，也可以参与运算。</p></li><li><p>逃逸字符： 用来表达无法打印出来的控制字符或特殊字符，它由一个反斜杠\开头，后面跟上另一个字符，这两个字符合起来，组成了一个字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;such as \&quot;5 7\&quot;mmm&quot;</span>);</span><br><span class="line"><span class="comment">// 输出：such as &quot;5 7&quot;mmm</span></span><br></pre></td></tr></table></figure></li><li><p>常用的逃逸字符</p><table><thead><tr><th>字符</th><th>意义</th><th>字符</th><th>意义</th></tr></thead><tbody><tr><td>\b</td><td>回退一格</td><td><code>\&quot;</code></td><td>双引号</td></tr><tr><td>\t</td><td>到下一个表格位</td><td><code>\&#39;</code></td><td>单引号</td></tr><tr><td>\n</td><td>换行</td><td><code>\\</code></td><td>反斜杠本身</td></tr><tr><td>\r</td><td>回车</td><td></td><td></td></tr></tbody></table></li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul><li><p>字符数组和字符串的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> word[] = &#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;O&#x27;</span>&#125;;   <span class="comment">//字符数组</span></span><br><span class="line"><span class="type">char</span> word[] = &#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;   <span class="comment">//字符串  &#x27;\0&#x27; = 0</span></span><br></pre></td></tr></table></figure></li><li><p>字符串：以整数0结尾的一串字符，<strong>0</strong>标志字符串的结束，但它不是字符串的一部分，也就是计算字符串长度时，这个0不包含在内；</p></li><li><p>字符串以数组的形式存在，以数组或指针的形式访问，在<code>string.h</code>内有很多处理字符串的函数。不能用运算符对字符串做运算。</p></li><li><p>一些字符串变量的定义形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str = <span class="string">&quot;hello&quot;</span>;  </span><br><span class="line"><span class="type">char</span> word[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> line[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"> <span class="comment">//编译器后面加上0，长度+1</span></span><br></pre></td></tr></table></figure><ul><li>str采用指针的形式定义字符串，字符串存储在程序的代码段，只能读出，不能写入；</li><li>如果想修改字符串，则应该参考后面两种定义方式，将字符串定义成数组的形式，那么这个字符串就不会存在程序的代码段了。</li></ul></li><li><p>指针和数组定义形式的区别：</p><ul><li>数组定义的字符串在这里，作为本地变量空间自动被回收； </li><li>指针定义的字符串不知道在哪里，指针可以处理参数，动态分配空间。</li><li>如果要<strong>构造</strong>一个字符串&gt;<strong>数组</strong>；如果要<strong>处理</strong>一个字符串&gt;<strong>指针</strong>。</li></ul></li><li><p><code>char *</code>不一定是字符串，本意是指向字符的指针，可能指向的是字符的数组（像<code>int*</code>‘一样），只有它所指的字符数组有结尾的0，才可以说它指的是字符串。</p></li></ul><h4 id="字符串计算"><a href="#字符串计算" class="headerlink" title="字符串计算"></a>字符串计算</h4><ul><li><p>字符串赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *t = <span class="string">&quot;title&quot;</span>;</span><br><span class="line"><span class="type">char</span> *s;</span><br><span class="line">s = t;</span><br></pre></td></tr></table></figure><p>并没有产生新的字符串，只是让指针s指向了t所指的字符串，对s的任何操作就是对t做的。</p></li><li><p>字符串输入输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="built_in">string</span>[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%7s&quot;</span>,<span class="built_in">string</span>);   <span class="comment">//7表示最多允许读入的字符的数量，比数组的大小小1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%7s&quot;</span>,<span class="built_in">string</span>);</span><br></pre></td></tr></table></figure><p>scanf读入一个单词（到空格，tab或回车为止），scanf是不安全的，因为不知道要读入的内容的长度。</p></li><li><p>常见错误</p><ul><li><p>以为<code>char*</code>是字符串类型，定义了一个字符串类型的变量<code>string</code>就可以直接使用了，由于没有对string初始化为0，所以不一定每次运行都出错。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="built_in">string</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,<span class="built_in">string</span>);     <span class="comment">//错误的使用方法</span></span><br></pre></td></tr></table></figure></li><li><p>空字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">100</span>] =<span class="string">&quot;&quot;</span>；<span class="comment">//这是一个空的字符串，buffer[0] == &#x27;\0&#x27;</span></span><br><span class="line"><span class="type">char</span> buffer[] = <span class="string">&quot;&quot;</span>;   <span class="comment">//这个数组的长度只有1，不能存储任何东西</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>字符串函数<code>string.h</code></p><ul><li><p>strlen 返回s的字符串长度（不包括结尾的0）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure></li><li><p>strcmp 比较两个字符串，返回0:s1 &#x3D;&#x3D; s2  1: s1 &gt;s2  -1:s1&lt;s2  (不相等给出差值)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*s1,<span class="type">const</span> <span class="type">char</span> *s2)</span>;</span><br></pre></td></tr></table></figure></li><li><p>strcpy 拷贝字符，把src的字符拷贝到dst，返回dst（为了能够链接起来）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *<span class="keyword">restrict</span> dst,<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> src)</span>; </span><br></pre></td></tr></table></figure><p>restrict表明src和dst不重叠。</p></li><li><p>strcat 把s2拷贝到s1的后面，拼接成一个长的字符串，返回s1，s1必须具有足够的空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *<span class="keyword">restrict</span> s1,<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> s2)</span>; </span><br></pre></td></tr></table></figure></li><li><p>strcmp strcat strcpy的<strong>安全版本</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*s1,<span class="type">const</span> <span class="type">char</span> *s2,<span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *<span class="keyword">restrict</span> dst,<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> src,,<span class="type">size_t</span> n)</span>; </span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *<span class="keyword">restrict</span> s1,<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> s2,,<span class="type">size_t</span> n)</span>; </span><br></pre></td></tr></table></figure></li><li><p>strchr和strrchr 在字符串中查找字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*s, <span class="type">int</span> c)</span>;  <span class="comment">//from left to right  </span></span><br><span class="line"><span class="type">char</span> * <span class="title function_">strrchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*s, <span class="type">int</span> c)</span>; <span class="comment">//from right to left</span></span><br><span class="line"><span class="comment">//example</span></span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;hello zsk&quot;</span></span><br><span class="line"><span class="type">char</span> *d = <span class="built_in">strchr</span>(str, <span class="string">&#x27;z&#x27;</span>);   <span class="comment">//d = sk</span></span><br></pre></td></tr></table></figure><p>返回NULL表示没有找到，返回查找字符之后的字符串。相当于把c之前的给截取掉。注意只能查找单个字符。</p></li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>指针的定义，使用；在了解指针的基础之上，学习了字符和字符串，特别对于字符串，有更多的玩法。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C学习笔记07：数组运算</title>
      <link href="/2023/12/04/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(07)/"/>
      <url>/2023/12/04/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(07)/</url>
      
        <content type="html"><![CDATA[<p>这篇还是讲数组，数组的知识点很关键，冲杯咖啡，继续干！</p><h3 id="数组运算"><a href="#数组运算" class="headerlink" title="数组运算"></a>数组运算</h3><h4 id="数组运算-1"><a href="#数组运算-1" class="headerlink" title="数组运算"></a>数组运算</h4><ul><li><p>数组的集成初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;</span><br><span class="line">    [<span class="number">0</span>] = <span class="number">2</span>,[<span class="number">2</span>] = <span class="number">3</span>,<span class="number">6</span>,    <span class="comment">//a[3] = 6; ,号不影响正确性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>直接用大括号给出数组的所有元素初始值，不需要给出数组的大小，编译器会替你数数。</li><li>C99中还可以用[n]初始化数组中给出的定位，其他没有初始化的为0，特别适合初始稀疏的数组。</li></ul></li><li><p>数组的大小：sizeof可以计算出数组的大小，单位是字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></li><li><p>数组变量不能直接赋值，必须采用遍历的方法（<strong>唯一方法</strong>）。在for循环时，通常是从0到小于数组的长度，这样循环体内最大的i正好是数组最大的有效下标。切记不要离开循环之后，还继续用i做数组下标。</p></li><li><p>数组作为函数参数时，往往必须再用<strong>另一个</strong>参数来传入数组的大小</p><ul><li>不能再<code>[]</code>中给出数组的大小；</li><li>不能再利用<strong>sizeof</strong>来计算数组的元素个数；</li></ul></li></ul><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><ul><li><p>定义：在一个数组中找到某个数的位置，基本方法是遍历。</p></li><li><p>程序的单一出口原则：在函数中，如果有返回数值，则仅要一个<code>return</code>即可，一专多能是不好的代码。</p></li><li><p>二分搜索：在<strong>排好序</strong>的前提下，采用该方法。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> a[],<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> right = len <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(right &gt; left)   <span class="comment">//跳出循环的条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] == k)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = mid;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[mid] &gt;k)&#123;</span><br><span class="line">            right = mid <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> ret;    <span class="comment">//单一出口原则</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于二分搜索，其效率相比于线性搜索更高。这个关系是N &#x3D; log2n ， 当n &#x3D; 100时，只需搜索7次即可，n&#x3D;1000时，搜素10次即可。 </p><h4 id="排序初步"><a href="#排序初步" class="headerlink" title="排序初步"></a>排序初步</h4><p><strong>选择排序</strong>：需要进行N轮，每一轮找出剩余部分的最大值，之后将这个数值与后面的做替换，也就是将这个最大值写在后面，对应的程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找出数组中，指定范围内的最大值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> maxid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; a[maxid])</span><br><span class="line">        &#123;</span><br><span class="line">            maxid = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">2</span>,<span class="number">45</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">41</span>,&#125;</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len<span class="number">-1</span>; i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> maxid = max(a,i+<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> t = a[maxid];   <span class="comment">//交换</span></span><br><span class="line">        a[maxid] = a[i];</span><br><span class="line">        a[i] = t</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for循环之后，就是对a排序完毕。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><p><code>sizeof</code>是静态运算符,在程序编译时计算值，如果里面写入的是i++，那么++则不会执行；</p></li><li><p><code>(double)(10/4*4)</code>如果加了括号，那么输出就是8，括号内的按照整形计算，如果不加括号，输出为10，因为double将10转换为浮点运算；</p></li><li><p><code>\t</code>在printf中代表输出水平制表符。水平制表符通常用于在输出中产生一个水平的间距，类似于按下键盘上的 “Tab” 键</p></li><li><p><code>char *name[] = &#123;&quot;penny&quot;,&quot;nickel&quot;&#125;</code>   使用指针定义字符串数组;</p></li><li><p>结构体coins[i].name   采用<code>.</code>的形式访问。</p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>主要学习了数组的定义，使用<strong>sizeof运算符</strong>计算数组的大小，简单的线性搜索和二分搜索，为了实现二分搜索，还学习了选择排序算法。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题笔记04：有效的括号</title>
      <link href="/2023/12/04/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B004/"/>
      <url>/2023/12/04/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B004/</url>
      
        <content type="html"><![CDATA[<h4 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h4><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;()&quot;</span>   <span class="string">&quot;(]&quot;</span></span><br><span class="line">输出：<span class="literal">true</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h4 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h4><p>这道题需要判断括号左右是否匹配，里面涉及到一个嵌套的问题，要实现嵌套情况下的括号匹配，如果是这种情况，就需要栈进行实现，栈具有先进后出的属性，正好满足嵌套的实现要求。在C语言中没有栈的指定类，在这里可以采用数组实现。</p><p><strong>C语言实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="title function_">pairs</span><span class="params">(<span class="type">char</span> a)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="string">&#x27;]&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="string">&#x27;&#125;&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="string">&#x27;)&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="comment">//利用栈实现</span></span><br><span class="line">     <span class="type">int</span> length = <span class="built_in">strlen</span>(s);  <span class="comment">//获得字符串的长度</span></span><br><span class="line">     <span class="keyword">if</span>(length%<span class="number">2</span> ==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果是奇数，那肯定不匹配</span></span><br><span class="line">     <span class="type">int</span> stk[length +<span class="number">1</span>];                                <span class="comment">//模拟栈的数组stk</span></span><br><span class="line">     <span class="type">int</span> top = <span class="number">0</span>;<span class="comment">//栈顶</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt; length;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="type">char</span> ch = pairs(s[i]);<span class="comment">//如果是左括号，则选择入栈</span></span><br><span class="line">         <span class="keyword">if</span>(ch)&#123;</span><br><span class="line">             <span class="keyword">if</span>(top ==<span class="number">0</span> || stk[top<span class="number">-1</span>] != ch)<span class="comment">//判断是否匹配，不匹配则返回错误</span></span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             top --;<span class="comment">//右括号，出栈操作</span></span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             stk[top++] = s[i];<span class="comment">//入栈操作</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;[()]&#125;</span></span><br><span class="line"><span class="comment">length = 6;</span></span><br><span class="line"><span class="comment">i  = 0 1 2 3 4 5</span></span><br><span class="line"><span class="comment">s[i] = &#123; [ ( ) ] &#125;</span></span><br><span class="line"><span class="comment">ch = 0 0 0 ( ] &#125;</span></span><br><span class="line"><span class="comment">stk[top] = &#123; [ ( </span></span><br><span class="line"><span class="comment">top = 1 2 3 2 1 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在这里，关键的核心点在于左右括号的匹配方法，使用了子函数<code>pairs</code>来实现，匹配上就是两个字符相等，如果没有匹配上就是不相等，免去了很多if的情况。</p><p><strong>C++语言实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n %<span class="number">2</span> ==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">char</span>&gt; pairs = &#123;</span><br><span class="line">           &#123;<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pairs.<span class="built_in">count</span>(ch))&#123;</span><br><span class="line">                <span class="keyword">if</span>(stk.<span class="built_in">empty</span>() || stk.<span class="built_in">top</span>() != pairs[ch])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​C++中，就有了栈的定义了，如果要定义一个栈，可以选择使用<code>stack&lt;char&gt;</code>关键词，同时，如果要入栈出栈，则可以采用<code>pop push</code>方法。在程序中，还有一个核心点需要注意下。</p><ul><li>使用 <code>unordered_map</code> 初始化的语法，定义了一个名为 <code>pairs</code> 的无序映射；</li><li>在 C++ 的 <code>std::unordered_map</code> 中，<code>count</code> 是一个方法，用于统计指定键在映射中的出现次数。对于一个给定的键，如果它在映射中存在，则 <code>count</code> 方法返回 1，否则返回 0。</li><li><code>for(char ch : s)</code> 是 C++11 引入的一种范围基于范围的循环（range-based for loop）语法。在这个语法中，你可以遍历容器（比如数组、字符串、容器类等）中的元素。示例中的含义为遍历字符串<code>s</code>，并将每次的遍历结果赋值于字符<code>ch</code>。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这道题就是考察栈的使用，在这里学会了栈的定义和基本操作，整体比较下来，还是C++的代码看着比较清爽。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C学习笔记06：数组与函数</title>
      <link href="/2023/11/30/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(06)/"/>
      <url>/2023/11/30/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(06)/</url>
      
        <content type="html"><![CDATA[<p>数组的知识点在程序中还是比较重要的，数组也是算法与数据结构中重要的一种数据存储结构，这篇文章，一起再温故一下吧。</p><h3 id="数组与函数"><a href="#数组与函数" class="headerlink" title="数组与函数"></a>数组与函数</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li><p>定义：数组是长度固定的一种数据结构，用来存放指定类型的数据，这些数据具有相同类型，相似含义，相同生存空间的特性，是一种容器；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型&gt; 变量名称[元素数量]；</span><br><span class="line"><span class="type">int</span> grades[<span class="number">100</span>];</span><br></pre></td></tr></table></figure><ul><li>元素的数量必须是整数，C99之前，其具体数值必须在编译时刻确定；</li><li>一旦创建，不能改变大小；</li></ul></li><li><p>操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> number[<span class="number">100</span>];   <span class="comment">//定义数组</span></span><br><span class="line">number[cnt] = x;   <span class="comment">//对数组元素赋值</span></span><br><span class="line">number[i] &gt; average; <span class="comment">//使用数组的元素</span></span><br></pre></td></tr></table></figure></li><li><p>关于数据下标</p><ul><li><p>下标从0开始编号；</p></li><li><p>编译器不会检查数据的越界的；要保证数组不能越界，其范围始终在[0,数组大小-1]范围内；</p></li><li><p>为了保证数据存储不越界，可以在定义数组时写一个很大的<code>元素数量</code>,或者利用C99的特性，根据输入的数值，动态调整数组的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;cnt);</span><br><span class="line"><span class="type">int</span> number[cnt];</span><br></pre></td></tr></table></figure></li></ul></li><li><p>可以定义一个大小为0的数组，但是没有任何作用，当然也可以使用字符来定义数组的大小，但是使用起来不会特别明显，因为字符是计算机的ASCII码的值，也就是数字；</p></li></ul><h4 id="函数的定义和使用"><a href="#函数的定义和使用" class="headerlink" title="函数的定义和使用"></a>函数的定义和使用</h4><ul><li><p>为什么要用函数？ </p><ul><li>代码复用性</li><li>提高可读性</li><li>方便调试</li></ul></li><li><p>函数是一块代码，接收零个或多个参数，做一件事情，并返回零个或一个值；接收的参数与定义的函数顺序要一致。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span>  <span class="comment">//函数头，其中void代表返回类型，sum函数名，（）代表参数表</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    code</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;   <span class="comment">//括号内代表函数体</span></span><br></pre></td></tr></table></figure></li><li><p>函数知道每一次是哪里调用它，会返回到正确的地方；</p></li><li><p><code>return</code>停止函数的执行，并送回一个数值；一个函数里可以出现多个<code>return</code>语句，其返回数值也可以丢弃；</p></li></ul><h4 id="函数的参数和变量"><a href="#函数的参数和变量" class="headerlink" title="函数的参数和变量"></a>函数的参数和变量</h4><ul><li><p>函数的先后关系：要将子函数写在调用者的前面的原因是C编译器自上而下顺序分析你的代码；</p></li><li><p>函数的原型声明放在前部，函数的定义可以放在调用的后面，函数原型会告诉编译器这个函数长什么样子（名称 + 参数【数量和类型】 + 返回类型）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数头 + 分号   <span class="comment">//函数原型</span></span><br></pre></td></tr></table></figure><ul><li>在调用过程中，如果入口参数类型不匹配，会发生<strong>自动类型转换</strong>，但一般不是你期待的；</li><li>函数原型中可以不写参数的名字；</li></ul></li><li><p>调用函数在传递参数时，可以传递给函数的值时表达式的结果，包括以下：</p><ul><li>字面量</li><li>变量</li><li>函数返回值</li><li>计算的结果</li></ul></li><li><p>每个函数有自己的变量空间，也叫作用域，参数也位于这个独立的空间中，和其他参数没有关系；</p></li><li><p>不建议继续使用形参和实参，可以使用参数和值；</p></li><li><p>本地变量，也叫局部变量，定义在函数内部，其参数也属于其中。其生存期和作用域是大括号内；大括号也叫块；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a&lt;b)&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;   <span class="comment">//i的生存期和作用域在大括号内</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出了大括号，就消失了</span></span><br></pre></td></tr></table></figure><ul><li>在块外面定义的变量，在块内仍然有效；块内定义了与外面同名的变量则会掩盖了外面的变量。</li><li>本地变量不会被默认初始化；</li></ul></li><li><p>逗号运算符：调用时圆括号内的逗号是标点符号，不是运算符；</p></li><li><p>对于<code>main</code>函数，其返回值是要有的，在linux中可以输入以下命令查看函数执行之后的返回数值，其0代表执行成功，其他数值代表错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure></li></ul><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><ul><li><p><code>int a[3][5]</code>可以理解成<strong>3行5列</strong>的矩阵</p></li><li><p>初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[][<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>行数可以由编译器来判断，但列数必须要给出</li><li>每一行一个<code>&#123;&#125;</code>，逗号分割；</li><li>最后的逗号可以存在；</li></ul></li><li><p>先走列和走行都行；</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>终于完事了，这个复习的有点多，也是比较基础的东西，例如函数的定义形式，局部变量，数组的定义和使用 ，很基础，也很常用。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C学习笔记05：循环控制</title>
      <link href="/2023/11/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(05)/"/>
      <url>/2023/11/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(05)/</url>
      
        <content type="html"><![CDATA[<p>本章咱们继续学习C语言中有关循环控制的知识点。</p><h3 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h3><h4 id="循环控制-1"><a href="#循环控制-1" class="headerlink" title="循环控制"></a>循环控制</h4><ul><li><p>break 在循环中跳出循环；注意对于多重循环，break只能跳出所在层的循环，如果要跳出嵌套的循环，可以使用接力break;</p></li><li><p>continue 跳过循环的这一轮剩下的语句，进入下一轮；</p></li></ul><h4 id="多重循环"><a href="#多重循环" class="headerlink" title="多重循环"></a>多重循环</h4><ul><li><p>循环里面可以嵌套循环</p></li><li><p>goto的使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*code 1 */</span></span><br><span class="line"><span class="keyword">goto</span> out</span><br><span class="line">     <span class="comment">/*code 2*/</span></span><br><span class="line">&#125;</span><br><span class="line">out:</span><br><span class="line"><span class="comment">/*code 3*/</span></span><br></pre></td></tr></table></figure><ul><li><p>goto可以代替接力brea语句，跳出嵌套循环，其后面接一个标识符，在程序的后面，可以采用冒号的形式书写对应的程序，从内测跳到最外侧，其他情况，不建议使用。</p></li><li><p>goto破坏了程序的结构性，难查错，使得程序的逻辑顺序显得较为混乱，并且会使程序更加难懂；</p></li></ul></li></ul><h4 id="循环应用"><a href="#循环应用" class="headerlink" title="循环应用"></a>循环应用</h4><ul><li><p>前N项求和<br>$$<br>f(n) &#x3D; 1-1&#x2F;2 + 1&#x2F;3 -1&#x2F;4 + …+1&#x2F;n<br>$$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n,i;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        sum = sum + sign * <span class="number">1.0</span>/i;</span><br><span class="line">        sign = -sign;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f(%d)=%f\n&quot;</span>,n,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序中利用for循环实现，对于负数巧妙的用了<code>sign</code>取反。</p></li><li><p>求最大公约数</p><p>对于输入的两个数a和b,如果b等于0，则计算结束，a就是最大公约数；否则，计算a除b的余数，让a等于b,而b等于那个余数；回到第一步；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">12</span>,b=<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">while</span>(b!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t = a%b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gcd=%d\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>正序分解整数</strong></p><p>输入一个非负整数，正序输出他的每一位数字;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    x = <span class="number">12345</span>;</span><br><span class="line">    <span class="type">int</span> mask =<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> t =x;</span><br><span class="line">    <span class="keyword">while</span>(t&gt;<span class="number">9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t = t/<span class="number">10</span>;</span><br><span class="line">        mask = mask *<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="type">int</span> d = x/mask;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,d);</span><br><span class="line">        <span class="keyword">if</span>(mask &gt;<span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        x = x%mask;</span><br><span class="line">        mask = mask /<span class="number">10</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span>(mask &gt;<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实语句的使用很简单，关键是对于具体的问题，选择什么样的算法，需要我们慢慢去思考和编写。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题笔记03：最长公共前缀</title>
      <link href="/2023/11/23/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B003/"/>
      <url>/2023/11/23/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B003/</url>
      
        <content type="html"><![CDATA[<h4 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h4><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p><strong>示例 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出：&quot;fl&quot;</span><br><span class="line">输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：输入不存在公共前缀。</span><br></pre></td></tr></table></figure><h4 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h4><p>**横向扫描法: **</p><p>这个方法的思路就是对要比较的字符串进行横向的扫描，所谓横向的扫描就是从开始执行两个字符串的比较，如果有公共部分，则记录，之后再利用这个公共部分去和下一个字符串进行比较，如果有公共部分，则更新其结果，当最后比较结束后，返回这个一直记录公共部分的字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//横向扫描</span></span><br><span class="line">        <span class="keyword">if</span>(!strs.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;    <span class="comment">//为空则直接返回</span></span><br><span class="line">        string orignal = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> count = strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt; count; i++)&#123;</span><br><span class="line">            <span class="type">int</span> length = <span class="built_in">min</span>(orignal.<span class="built_in">size</span>(),strs[i].<span class="built_in">size</span>());</span><br><span class="line">            <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//两个字符串进行比较相同部分</span></span><br><span class="line">            <span class="keyword">while</span>(index &lt; length &amp;&amp; orignal[index] == strs[i][index])</span><br><span class="line">            &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            orignal = orignal.<span class="built_in">substr</span>(<span class="number">0</span>,index);   <span class="comment">//更新公共字符串</span></span><br><span class="line">            <span class="keyword">if</span>(!orignal.<span class="built_in">size</span>()) <span class="keyword">break</span>;     <span class="comment">//没有的话，就直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> orignal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span></span><br><span class="line"><span class="comment">orignal = flower </span></span><br><span class="line"><span class="comment">count = 3</span></span><br><span class="line"><span class="comment">i = 1 2 3(break)</span></span><br><span class="line"><span class="comment">orignal= flow fl</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><p><code>min</code>这个是一个模板函数，用于找到两个值中的最小值。定义在头文件 <algorithm> 中；</p></li><li><p><code>index &lt; length</code>这个容易忘记，这个就是代表如果达到了最短的字符串了，那就没有必要再进行比较下去了；</p></li><li><p>再C++中对于字符串定义了<code>string</code>，但是在C中，却没有这个关键词，在C中对于字符串的定义可以采用数组或者指针的形式，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单字符串定义，访问str[i]/str</span></span><br><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">char</span> *str3 = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="comment">//双重字符串定义，访问str2[0]代表&quot;flower&quot;，str2[0][0]代表f</span></span><br><span class="line"><span class="type">char</span> *strs2[] = &#123;<span class="string">&quot;flower&quot;</span>, <span class="string">&quot;flow&quot;</span>, <span class="string">&quot;flight&quot;</span>&#125;; </span><br></pre></td></tr></table></figure></li><li><p><code>substr</code>这个方法会进行截取按照指定的位；</p></li><li><p><code>if(!orignal.size()) break; </code>这句话可以很好的判定如果这两个字符串都没有重合的部分，就直接跳出for循环，没有再进行比较下去的必要了（因为要求每个字符串都要含有公共部分）。</p></li></ul><p>**纵向扫描法: **</p><p>这个思路也是我首先想到的，基本就是比较字符串的一位一位，如果相同，则比较每个字符串的下一位，如果不相同，则停止比较，返回当前记录的公共部分，这种方法容易想到，但是实现起来小细节比较多。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">longestCommonPrefix</span><span class="params">(<span class="type">char</span>** strs, <span class="type">int</span> strsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(strsSize==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>,j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i;i&lt;<span class="built_in">strlen</span>(strs[<span class="number">0</span>]);i++)&#123;   <span class="comment">//有多少位需要判定</span></span><br><span class="line">         <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt; strsSize; j++)  <span class="comment">//判定每一个字符串的位信息是否一致</span></span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">if</span>(strs[<span class="number">0</span>][i] != strs[j][i])&#123;  <span class="comment">//不一致</span></span><br><span class="line">                strs[<span class="number">0</span>][i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>];<span class="comment">//相当于随机拿了第一个字符串作为类比对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>字符串如果想要结尾可以加上<code>&#39;\0</code>‘标志，就代表截断了；</li><li>这个的<code>strs[0]</code>使用的非常的巧妙，当作类别的对象；</li><li>第二个for循环的<code>j</code>每次都要进行初始化，因为要判定首个字符串与其他字符串嘛。</li></ul><p>**分而之治: **</p><p>这种方法其实和横向比较方法类似，它只不过不是进行顺序的比较，而是将整个待测字符看成一个整体，对于这个整体从上到下进行分割，直到分割到最小的位置，分割后，对于分割的两个进行比较，比较的方法和横向法一样，采用对比，字符串截取更新公共部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!strs.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">longestCommonPrefix</span>(strs, <span class="number">0</span>, strs.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//函数重载</span></span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; strs, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> strs[start];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> mid = (start + end) /<span class="number">2</span>;</span><br><span class="line">            string lcpLeft = <span class="built_in">longestCommonPrefix</span>(strs,start,mid);</span><br><span class="line">            string lcpRight = <span class="built_in">longestCommonPrefix</span>(strs,mid+<span class="number">1</span>,end);</span><br><span class="line">            <span class="type">int</span> minLength = <span class="built_in">min</span>(lcpLeft.<span class="built_in">size</span>(),lcpRight.<span class="built_in">size</span>());</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; minLength; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(lcpLeft[i] != lcpRight[i])&#123;</span><br><span class="line">                    <span class="keyword">return</span> lcpLeft.<span class="built_in">substr</span>(<span class="number">0</span>,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> lcpLeft.<span class="built_in">substr</span>(<span class="number">0</span>,minLength);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span></span><br><span class="line"><span class="comment">strs.size() = 3</span></span><br><span class="line"><span class="comment">longestCommonPrefix(strs)</span></span><br><span class="line"><span class="comment">    longestCommonPrefix(strs,0,2)</span></span><br><span class="line"><span class="comment">        mid = 1;</span></span><br><span class="line"><span class="comment">        longestCommonPrefix(strs,0,1);</span></span><br><span class="line"><span class="comment">            mid = 0;</span></span><br><span class="line"><span class="comment">            longestCommonPrefix(strs,0,0);</span></span><br><span class="line"><span class="comment">                return strs[0] = &quot;flower&quot;;</span></span><br><span class="line"><span class="comment">            lcpLeft = &quot;flower&quot;;</span></span><br><span class="line"><span class="comment">            longestCommonPrefix(strs,1,1);</span></span><br><span class="line"><span class="comment">                return strs[1] = &quot;flow&quot;;</span></span><br><span class="line"><span class="comment">            lcpRigh = &quot;flow&quot;;</span></span><br><span class="line"><span class="comment">            minLength = 4;</span></span><br><span class="line"><span class="comment">            return lcpLeft.substr(0,3) = flow;</span></span><br><span class="line"><span class="comment">        lcpLeft = flow;</span></span><br><span class="line"><span class="comment">        longestCommonPrefix(strs,2,2);</span></span><br><span class="line"><span class="comment">            return strs[2] = &quot;flight&quot;</span></span><br><span class="line"><span class="comment">        lcpRigh = &quot;flight&quot;</span></span><br><span class="line"><span class="comment">        minLength = 4;</span></span><br><span class="line"><span class="comment">        return lcpLeft.substr(0,1) = fl;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>在这段代码中，<code>longestCommonPrefix</code>函数进行了重载，重载函数一般是私有的，也就是供这个类内部进行调用，重载可以使代码更加简洁。</li><li>这种方法可以化繁至简</li></ul><p>**二分法: **</p><p>二分法的思想和纵向比较类似，对于每个字符串的字符，进行二分比较，先得出给定字符串的最小长度，之后在这个范围内，采用二分的形式，进行比较，如果两个字符相同，则低位向右移动，如果两个不相同，则高位向左移动，直到低位大于或者等于高位，此时输出字符串0-low之间的字符，即为结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!strs.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> minLength = <span class="built_in">min_element</span>(strs.<span class="built_in">begin</span>(), strs.<span class="built_in">end</span>(),[](<span class="type">const</span> string&amp; s, <span class="type">const</span> string&amp; t) &#123;<span class="keyword">return</span> s.<span class="built_in">size</span>() &lt; t.<span class="built_in">size</span>();&#125;) -&gt; <span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> low =<span class="number">0</span>, high = minLength;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (high - low+<span class="number">1</span>)/<span class="number">2</span> +low;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isCommonPrefix</span>(strs,mid))&#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>,low);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="type">bool</span> <span class="title">isCommonPrefix</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; strs, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">        string str0 = strs[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>, length);</span><br><span class="line">        <span class="type">int</span> count = strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            string str = strs[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; length; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str0[j] != str[j]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>strs[0].substr(0, 2)</code> 代表从0开始截取，截取2个字符，如果<code>strs[0] = flow</code>，那么结果为<code>fl</code>;</li><li>二分法的核心思想在于什么时候结束</li><li>min_element是C++标准库的函数，用于找到字符串数组 strs 中长度最短的字符串； <code>strs.begin()</code> 到 <code>strs.end()</code> 的是查找返回， <code>[](const string&amp; s, const string&amp; t) &#123;return s.size() &lt; t.size();&#125;</code> 是Lambda 函数，返回一个迭代器，指向找到的最小元素。</li></ul><p><strong>参考：</strong><a href="https://leetcode.cn/problems/longest-common-prefix/description/">https://leetcode.cn/problems/longest-common-prefix/description/</a></p><h4 id="算法对比"><a href="#算法对比" class="headerlink" title="算法对比"></a>算法对比</h4><table><thead><tr><th></th><th>横向扫描</th><th>纵向扫描</th><th>分而治之</th><th>二分</th></tr></thead><tbody><tr><td>时间复杂度</td><td>O(mn)</td><td>O(mn)</td><td>O(mn)</td><td>O(mnlogm)</td></tr><tr><td>空间复杂度</td><td>O(1)</td><td>O(1)</td><td>O(mlogn)</td><td>O(1)</td></tr></tbody></table><ul><li>其中 m 是字符串数组中的字符串的平均长度，n 是字符串的数量；二分法最好，其时间复杂度最低。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>四种实现方法，不一样的体会，感觉前两者容易想到，后面使用两个，其效果更好；</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C学习笔记03：判断与循环(下)</title>
      <link href="/2023/11/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(04)/"/>
      <url>/2023/11/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(04)/</url>
      
        <content type="html"><![CDATA[<p>本章咱们继续学习C语言中判断和循环的语法。</p><h3 id="判断与循环"><a href="#判断与循环" class="headerlink" title="判断与循环"></a>判断与循环</h3><h4 id="逻辑类型和运算"><a href="#逻辑类型和运算" class="headerlink" title="逻辑类型和运算"></a>逻辑类型和运算</h4><ul><li><p>bool类型，需要包含 #include&lt;stdbool.h&gt;；</p></li><li><p>逻辑运算：结果只有0和1，运算符有 ! &amp;&amp; || ， 优先级比赋值运算高；</p></li><li><p>条件运算符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = (count &gt; 20) ? count - 10:count +10;  //count - 10为条件满足时的值</span><br></pre></td></tr></table></figure></li><li><p>逗号运算：用于连接两个表达式，主要在for循环中使用；</p></li></ul><h4 id="级联和嵌套的判断"><a href="#级联和嵌套的判断" class="headerlink" title="级联和嵌套的判断"></a>级联和嵌套的判断</h4><ul><li>嵌套if else, else总是和最近的if进行匹配；</li><li>在if else后面要加上大括号；</li><li>级联的if else</li></ul><h4 id="多路分支"><a href="#多路分支" class="headerlink" title="多路分支"></a>多路分支</h4><ul><li><p>switch case : 如果没有对用的case，就去执行defualt对应的语句；</p></li><li><p>控制表达式switch(控制表达式）对应的只能时整数类型的，case要对应常数；</p></li><li><p>break可以结束switch语句；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(type)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="comment">/*code*/</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">/**/</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，case1和2 执行的结果是一样的。</p></li><li><p>分段函数可以用switch-case吗？划算吗？看具体情况，在某些情况下，特别是在处理离散值的情况下，switch-case 可以是一种简洁而清晰的选择。</p></li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>处理问题的流程：变量，算法，流程图，程序；</li><li>在写程序时需要注意：加大括号，错误使用&#x3D;&#x3D; 和 &#x3D;，要缩进对齐；</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个内容不是很多，有一些点还是需要记住的，下一节循环控制！</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题笔记02：判断回文数</title>
      <link href="/2023/11/21/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B002/"/>
      <url>/2023/11/21/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B002/</url>
      
        <content type="html"><![CDATA[<h4 id="判断回文数"><a href="#判断回文数" class="headerlink" title="判断回文数"></a>判断回文数</h4><p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><ul><li>例如，<code>121</code> 是回文，而 <code>123</code> 不是。</li></ul><p><strong>示例 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 121</span><br><span class="line">输出：true</span><br><span class="line">输入：x = -121</span><br><span class="line">输出：false</span><br><span class="line">解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数</span><br></pre></td></tr></table></figure><h4 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h4><p>**字符串法: **</p><p>字符串法就是要将输入的整数首先转换成字符串，之后从首尾开始比较转换之后的字符，如果相等，则继续比较，如果不相等，则返回false,直到字符比较个数进行一半结束，对应的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>];              <span class="comment">// 大致足够存储整数的字符串表示</span></span><br><span class="line">    <span class="built_in">sprintf</span>(str, <span class="string">&quot;%d&quot;</span>, x);     <span class="comment">//整形转换成字符型</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str);     <span class="comment">//求字符的长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; ++i) &#123;     <span class="comment">//进行到一半结束，结束代表是回文数</span></span><br><span class="line">        <span class="keyword">if</span> (str[i] != str[len - <span class="number">1</span> - i]) &#123;   <span class="comment">//首尾比较</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*执行过程</span></span><br><span class="line"><span class="comment">x = 12321</span></span><br><span class="line"><span class="comment">str = 12321</span></span><br><span class="line"><span class="comment">len = 5</span></span><br><span class="line"><span class="comment">len/2 = 2 </span></span><br><span class="line"><span class="comment">i = 0 1 2(2 = len/2 循环跳出，返回true)</span></span><br><span class="line"><span class="comment">str[i] = 1 2  </span></span><br><span class="line"><span class="comment">str[len -1 -i] = 1 2  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><p>整数转变为字符串采用了sprintf函数，其函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>char *str</code>为转换后的字符串存储位置；</li><li><code>const char *format</code>的为指定的格式，在这个案例中使用的是<code>%d</code>；</li><li><code>...</code>为要转换的整数，可变参数，用于提供要格式化的数据；</li><li>如果返回是一个负数，则代表转换出错；</li></ul></li><li><p><code>strlen(str)</code>返回的是一个从1开始的数字，所以在后面比较时<code>len-1</code>。</p></li></ul><p><strong>对数字进行直接转换：</strong></p><p>这种方法大致的思路就是定义一个变量，利用循环的方式对数字进行反向解析，解析之后，存储到之前定义的变量中，如果解析完之后，这个变量和初始的变量一致，那么就说明是回文数，如果不一致，则不是，对应的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> orignal = x;   <span class="comment">//保存初始值</span></span><br><span class="line">    <span class="type">long</span> resValue = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> digit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(x &lt; <span class="number">0</span>)&#123;            <span class="comment">//负数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x &gt;=<span class="number">0</span> &amp; x &lt;<span class="number">10</span>) <span class="comment">//个位数</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            digit = x % <span class="number">10</span>;</span><br><span class="line">            resValue = resValue *<span class="number">10</span> + digit;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resValue == orignal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序中利用了取余和除法的操作，对于1&#x2F;10，余数为1，商为0；</li><li>&#x3D;&#x3D;符号的使用，可以很容易判定是否相等，与return结合，可以方便输出0或1</li><li>记得进行一些特殊情况的判断，例如负数和10以内的数；</li><li><code>reValue</code>这个数值定义时需要定义成long型，int型可能会溢出；</li></ul><p><strong>对数字的一半进行直接转换：</strong></p><p>这个思路和第二种方法一样，它解决了int型溢出的问题，并且代码更加简洁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> reversed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; reversed) &#123;</span><br><span class="line">        reversed = reversed * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x == reversed || x == reversed / <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 执行过程</span></span><br><span class="line"><span class="comment">x = 12321 1232 123 12</span></span><br><span class="line"><span class="comment">reversed = 0 1 12 123</span></span><br><span class="line"><span class="comment">退出循环， 12 == 123 / 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>while内的判断条件是重点，它在这里是只要前半个数小于等于后半个数，就一直进行循环，等到后半个数比前半个数大时，就退出循环。</li><li><code>x == reversed / 10</code>这个非常巧妙，可以排除中位数的影响；</li></ul><p><strong>自己想到的方法</strong></p><p>这个方法是将这个数字进行一位一位的分离，之后再一位一位的拼接，如果拼接的这个和初始的一样，则判定为回文数。我在具体编程时犯了很多错误，例如digits定义错误，前面分离存储还没有问题，等到后面时，我就不知道如何组装这个数了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> original = x;</span><br><span class="line">    <span class="type">int</span> digits[<span class="number">10</span>];  <span class="comment">// 假设数字最多有 10 位</span></span><br><span class="line">    <span class="type">int</span> numDigits = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分离每一位并存储在数组中</span></span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        digits[numDigits] = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">        numDigits++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从数组中重新组合成一个新的数字</span></span><br><span class="line">    <span class="type">int</span> reversed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numDigits; i++) &#123;</span><br><span class="line">        reversed = reversed * <span class="number">10</span> + digits[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> original == reversed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考：</strong><a href="https://leetcode.cn/problems/palindrome-number/description/">https://leetcode.cn/problems/palindrome-number/description/</a></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这个题目一开始在做的时候，觉得不难应该，但是在进行具体编程时就卡住了，我是将这个数字进行一位一位的分离，之后再一位一位的拼接，如果拼接的这个和初始的一样，则判定为回文数。上述的几种方法都很不错，值得我们去回味。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C学习笔记03：判断与循环(一)</title>
      <link href="/2023/11/20/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(03)/"/>
      <url>/2023/11/20/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(03)/</url>
      
        <content type="html"><![CDATA[<p>本章主要复习C语言中常用的判断和循环语句。</p><h3 id="判断与循环"><a href="#判断与循环" class="headerlink" title="判断与循环"></a>判断与循环</h3><h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4><ul><li><p>if语句</p></li><li><p>六种关系运算符：&#x3D;&#x3D; !&#x3D; &gt; &lt; &gt;&#x3D; &lt;&#x3D;，关系运算符的结果只会是0和1；所以关系运算符的优先级比算术运算的低，但是比赋值运算高，&#x3D;&#x3D; !&#x3D;比其他低，&gt; &lt;是从左到右。</p></li><li><p>if else语句在使用过程中要使用中括号括起来，否则只会执行紧邻的第一条语句；</p></li><li><p>几个具有迷惑性的题目</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">1</span>&lt;=n&lt;=<span class="number">10</span>)   <span class="comment">//可以通过编译</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="type">int</span> i,j,k;</span><br><span class="line">i=<span class="number">2</span>,j=<span class="number">3</span>;</span><br><span class="line">k=i*j==<span class="number">6</span>;   <span class="comment">//i*j先进行等于6，之后进行==,结果只能是0或者1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,k);    <span class="comment">//输出为1</span></span><br></pre></td></tr></table></figure></li><li><p>&#x2F;**&#x2F;会被编译器替换，为什么？会替换成什么？</p><p>给程序员看的注释，在程序中，编译器会忽略，不会替换成任何。</p></li></ul><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><ul><li><p>while do while for</p><p><img src="/raoVynfFqKXdH32.jpg" alt="微信截图_20231120215021.png"></p></li><li><p>for循环是先执行判断，还是先进行自加？先进行判断条件再执行迭代表达式；</p></li><li><p>对于for循环的误解：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">10</span>; i&gt;<span class="number">1</span>; i/=<span class="number">2</span>)   <span class="comment">//int i=10只会执行一次</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for(初始动作；条件；每轮的动作)&#123;循环体&#125;</span></span><br><span class="line"><span class="comment">//for(；条件；)&#123;循环体&#125;  =  while(条件)</span></span><br></pre></td></tr></table></figure><p>for循环的执行顺序就是先进行初始化表达式，只会<strong>一次</strong>，然后进行判断条件，如果条件成立，则会执行括号内的循环体，如果不成立，则会跳出循环，执行完循环体之后，再执行迭代语句。当循环离开时，i的数值就是n。</p><p><img src="https://raw.githubusercontent.com/surekun/images/main/PicGo/20231120214421.png"></p></li><li><p>以下表达式不等价</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i++&lt;<span class="number">10</span>;)  </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br></pre></td></tr></table></figure></li><li><p>对于循环程序的调试方法，就是列出所有的变量，随着循环的执行，更新对应的变量。边界数据0，负数等；或者在指定位置插入printf，表示特定的数值，或者程序执行到哪里了。</p></li><li><p>求和的变量初始化为0，求积的变量初始化为1。</p></li><li><p>三种循环方式的选择：</p><ul><li><p>如果有固定次数，则用for；</p></li><li><p>如果必须执行一次，用do_while</p></li><li><p>其他情况用while</p></li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对关系运算符和for循环有了更新的认识！</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题笔记01：两数之和</title>
      <link href="/2023/11/19/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B001/"/>
      <url>/2023/11/19/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B001/</url>
      
        <content type="html"><![CDATA[<h4 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h4><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><h4 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h4><p>**暴力求解: **</p><p>思路就是对num数组内的数据进行两次遍历，通过两次的遍历，查找两次遍历的结果是否与target数值相等，在程序上实现就是采用两个for循环，其时间复杂度位 <code>O(n2)</code>。需要注意的是在进行遍历时，i之前的不需要再次遍历，因为之前已经遍历比较过了，对应的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:   <span class="comment">//vector&lt;int&gt;&amp; nums 引用</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[j] == target)</span><br><span class="line">            &#123;</span><br><span class="line">              result = &#123;i,j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>vector&lt;int&gt; </code>代表的是一个模板类，表示存储整数<code>（int）</code>类型的动态数组（向量），其vector是C++标准标准模板库的一部分，提供了动态数组的功能；</p></li><li><p><code>.size()</code>方法可以用于获得动态数组的大小；</p></li><li><p>使用vector定义数组的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; name = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; name;</span><br><span class="line">name.<span class="built_in">push_back</span>(<span class="number">55</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">name</span><span class="params">(<span class="number">5</span>,<span class="number">0</span>)</span></span>; <span class="comment">//大小为5，并且初始化为0；</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>哈希表解法：</strong></p><p>采用哈希表的形式，来降低时间复杂度，也就是使用一个for循环，在这个for循环内使用哈希表的查找特性，具体实现方法如下;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hashtable;  </span><br><span class="line">        <span class="comment">//声明了一个哈希表，键和值都是int,哈希表的名称为hashtable</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = hashtable.<span class="built_in">find</span>(target - nums[i]);  <span class="comment">//找到对应的键值对</span></span><br><span class="line">            <span class="keyword">if</span>(it != hashtable.<span class="built_in">end</span>())&#123;</span><br><span class="line">              <span class="keyword">return</span>&#123;it-&gt;second,i&#125;;<span class="comment">//访问其值</span></span><br><span class="line">            &#125;</span><br><span class="line">            hashtable[nums[i]] = i;  <span class="comment">//插入键值对</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>哈希表：是一种数据结构，它通过使用哈希函数将键映射到表中的位置来实现高效的数据检索，其时间复杂度为常数；</p></li><li><p><code>unordered_map</code>: 是 C++ 标准库中提供的一种关联容器，它实现了哈希表的数据结构；提供了基于键值对的快速检索功能，其中每个键关联一个唯一的值。</p></li><li><p><code>hashtable.find</code>：<code>find</code>方法用于在哈希表中查找给定键是否存在，并返回对应键值对，如果没有找到，则返回<code>hashtable.end()</code>，找到了之后，可以采用<code>it-&gt;second</code>访问其值。</p></li><li><p>哈希表的使用方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个名为 hashtable 的 unordered_map，其键和值都是整数类型</span></span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hashtable;</span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    hashtable[<span class="number">1</span>] = <span class="number">42</span>;</span><br><span class="line">    hashtable[<span class="number">2</span>] = <span class="number">56</span>;</span><br><span class="line">    hashtable[<span class="number">3</span>] = <span class="number">73</span>;</span><br><span class="line">    <span class="comment">// 查找键为 2 的值</span></span><br><span class="line">    <span class="type">int</span> value = hashtable[<span class="number">2</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value associated with key 2: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：56</p><p><img src="/20231119232952.png"></p></li></ul><p><strong>参考：</strong><a href="https://leetcode.cn/problems/two-sum/description/">https://leetcode.cn/problems/two-sum/description/</a></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这个题目采用哈希表可以降低其时间复杂度，经过测试，采用暴力解法的程序运行时间为336ms,而采用哈希表解法的时间复杂度仅为10ms,相当于快了36倍，这个提升还是很大的。对于上述的解析都是采用C++实现的，当然也可以采用C语言实现，但是对于C语言实现哈希表比较麻烦，推荐使用C++。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理学习笔记01：系统概论及发展应用</title>
      <link href="/2023/11/19/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B%EF%BC%9A%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(01)/"/>
      <url>/2023/11/19/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B%EF%BC%9A%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(01)/</url>
      
        <content type="html"><![CDATA[<p>学习计算机组成原理是基础，可以帮助我们对计算机有一个整体的认识，也是计算机其他课程的前提。</p><h3 id="计算机系统概论"><a href="#计算机系统概论" class="headerlink" title="计算机系统概论"></a>计算机系统概论</h3><p><img src="/20231119172332.png"></p><h4 id="计算机系统简介"><a href="#计算机系统简介" class="headerlink" title="计算机系统简介"></a>计算机系统简介</h4><ul><li>由软件和硬件组成； </li><li>软件：系统软件 （操作系统，编译器等）+ 应用软件</li><li>计算机组成和体系结构的区别<ul><li>体系结构是对各种属性的一种抽象，面向程序员，研究指令系统，数据类型，寻址技术，I&#x2F;O机理等（例如，研究有无乘法指令）；</li><li>计算机组成是对上述属性进行实现；</li></ul></li></ul><h4 id="计算机的基本组成"><a href="#计算机的基本组成" class="headerlink" title="计算机的基本组成"></a>计算机的基本组成</h4><ul><li><p>冯诺依曼组成原理</p><ul><li><p>计算机由运算器，存储器，控制器，输入输出设备五大部分，运算器和控制器统称中央处理器；</p></li><li><p>指令由操作码和操作数组成；</p></li><li><p>以运算器为中心，现代计算机已经转变为以存储器为中心；</p><img src="20231119173921.png" style="zoom:50%;" /></li></ul></li><li><p>计算的工作步骤</p><ul><li>上机前准备：建立数学模型，确定计算方法，编制解题程序（由0和1组成）</li><li>工作过程：由存储器，运算器和控制器三部分组成指令的执行过程；<ul><li>存储器的基本组成：存储体-存储单元-存储元件；MDR存储数据寄存器，反映存储字长，MAR存储器地址寄存器，反映存储单元的个数；存储字长等于MDR，存储单元个数等于2的MAR次方。</li><li>运算器的基本组成：ACC（Accumulator)累加器，MQ（Multiplier-Quotient Register)乘商寄存器，X操作数寄存器，ALU算数逻辑单元；</li><li>控制器的基本组成：取指令PC（Program Counter，程序计数器)，分析指令IR(Instruction Register，指令寄存器)，执行指令(Control Unit,控制单元)CU；</li></ul></li></ul></li><li><p>计算机硬件的主要技术指标</p><ul><li>机器字长：CPU可以一次处理数据的位数，通常与CPU寄存器有关；</li><li>运算速度：主频，核数，MIPS（每秒执行的百万条指令） FLOPS（每秒浮点运算次数）</li><li>存储容量：主存容量和辅存容量，均使用字节表示，一个字节等于8位；</li></ul></li></ul><h3 id="计算机的发展及应用"><a href="#计算机的发展及应用" class="headerlink" title="计算机的发展及应用"></a>计算机的发展及应用</h3><h4 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h4><ul><li>世界上第一台电子计算机ENIAC（1946）</li><li>摩尔定律：微芯片上集成的晶体管数每三年翻两番；</li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li>科学计算和数据处理</li><li>工业控制和实时控制</li><li>网络技术</li><li>展望<ul><li>未来可以用光子取代电子进行存储等。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇是计算机组成原理的开端，是一些基本的概念，了解即可。</p>]]></content>
      
      
      <categories>
          
          <category> 理论课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C学习笔记02：计算</title>
      <link href="/2023/11/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(02)%20/"/>
      <url>/2023/11/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(02)%20/</url>
      
        <content type="html"><![CDATA[<p>有过对C语言有整体的了解之后，下面咱们就一起了解下C语言的变量相关内容吧。</p><span id="more"></span><h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul><li><p>变量作用：用于存放数据，变量的命名只能以字母，数字和下划线组成，数字不能放在第一个位置，关键词不能定义成变量名称；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> price;</span><br><span class="line"><span class="type">int</span> price1,price2;     <span class="comment">//定义多个变量</span></span><br><span class="line"><span class="type">int</span> price1 = <span class="number">10</span>,price2 = <span class="number">100</span>;    <span class="comment">//定义多个变量并赋值</span></span><br><span class="line"><span class="type">int</span> <span class="number">3</span>price;           <span class="comment">//编译会报错，如下所示</span></span><br></pre></td></tr></table></figure><p><img src="/20231119142548.png"></p></li><li><p>变量在使用之前需要初始化一次；</p></li><li><p>变量的类型及其所占空间的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line"><span class="type">int</span> a1;</span><br><span class="line"><span class="type">char</span> a2;</span><br><span class="line"><span class="type">short</span> a3;</span><br><span class="line"><span class="type">long</span> a4;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a5;</span><br><span class="line"><span class="type">float</span> a6;</span><br><span class="line"> <span class="type">double</span> a7;</span><br><span class="line"><span class="type">long</span> <span class="type">double</span> a8;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;int=%d,char=%d,short=%d,long=%d,long long=%d,float=%d,double=%d,long double=%d    \n&quot;</span>,<span class="keyword">sizeof</span>(a1),<span class="keyword">sizeof</span>(a2),<span class="keyword">sizeof</span>(a3),<span class="keyword">sizeof</span>(a4),<span class="keyword">sizeof</span>(a5),<span class="keyword">sizeof</span>(a6),<span class="keyword">sizeof</span>(a7),<span class="keyword">sizeof</span>(a8));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/20231119145035.png"></p><p>注：单位是字节，一个字节等于8位，可以表示0-256个数据；</p></li><li><p>程序编写中如何输入，采用scanf函数，具体说明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="comment">//eg:</span></span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"> size = <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a1,&amp;a2); <span class="comment">//遇到回车结束，在a1 a2中间需要加上空格</span></span><br><span class="line"> size = <span class="built_in">scanf</span>(<span class="string">&quot;%c%c&quot;</span>,&amp;a1,&amp;a2); <span class="comment">//遇到回车或者换行结束，在a1 a2中间不需要加上空格</span></span><br><span class="line"><span class="comment">//size = 2,则读入正确</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">%d: 读取一个整数。</span></span><br><span class="line"><span class="comment">%f: 读取一个单精度浮点数。</span></span><br><span class="line"><span class="comment">%lf: 读取一个双精度浮点数。</span></span><br><span class="line"><span class="comment">%c: 读取一个字符。</span></span><br><span class="line"><span class="comment">%s: 读取一个字符串。</span></span><br><span class="line"><span class="comment">%x 或 %X: 读取一个十六进制整数。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注意以下几点：</p><ul><li><p>如果在格式控制字符串中除了格式声明以外，还有其他的字符，那么在输入时你也必须输入；</p></li><li><p>输入是以行为单位，结束标志就是你按下了回车键；</p></li><li><p>在输入整数时，最好要有对应的空格，但是在输入一个字符时，不需要有空格；</p></li><li><p>在输入时遇到文件结束符（EOF），换行符或空格（针对格式控制字符不包含空格和换行），指定最大字符数；</p></li><li><p>scanf函数在成功读取数据之后，会返回一个变量，如果这个变量的数值等于要输入数据的个数，那么就是成功读入，否则代表在读入时发生了错误；</p></li></ul></li><li><p>常量：可以用来代替变量，const修饰符进行修饰，表示这个数值一旦初始化，就不能再更改，const 定义的字符一般大写。</p></li></ul><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li><p>两个整数的运算结果只能是整数；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;result = %d\n&quot;</span>,<span class="number">10</span>/<span class="number">3</span>*<span class="number">3</span>);    <span class="comment">//result = 9</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;result = %f\n&quot;</span>,<span class="number">10.0</span>/<span class="number">3</span>*<span class="number">3</span>);  <span class="comment">//result = 10</span></span><br></pre></td></tr></table></figure></li><li><p>10和10.0是完全不一样的，如果没有小数点则代表整数，如果有小数点，则整个计算按照浮点型计算；</p></li><li><p>单精度和双精度浮点数的区别：</p><ul><li>单精度：7位有效数字</li><li>双精度：15位有效数字</li></ul></li></ul><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><ul><li><p>运算符和算子</p><img src="20231119154810.png" style="zoom:25%;" /></li><li><p>在Linux中如何使用GDB调试工具查看程序中变量的数值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -o your_program your_program.c    <span class="comment">#生成带有调试信息的可执行程序</span></span><br><span class="line">gdb ./your_program    <span class="comment">#使用GDB执行程序</span></span><br><span class="line"><span class="built_in">break</span> main            <span class="comment">#打断点</span></span><br><span class="line">run                   <span class="comment">#运行</span></span><br><span class="line"><span class="built_in">print</span> your_var        <span class="comment">#查看数值</span></span><br><span class="line">x addr                <span class="comment">#查看地址空间内的内容</span></span><br><span class="line">info locals           <span class="comment">#显示断点处变量的内容</span></span><br><span class="line">step                  <span class="comment">#单步执行</span></span><br><span class="line"><span class="built_in">continue</span>              <span class="comment">#继续执行</span></span><br><span class="line">q                     <span class="comment">#退出GDB</span></span><br></pre></td></tr></table></figure></li><li><p>复合赋值运算符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a++ <span class="comment">//递增 是a+1以前的数值</span></span><br><span class="line">--a  <span class="comment">//递减 是a-1以后的数值</span></span><br></pre></td></tr></table></figure><p>  变量在哪就是哪的数值；</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本片记录了C语言中的变量，运算符相关知识，还记录了Linux中的GDB工具使用方法。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C学习笔记01：程序设计与C语言</title>
      <link href="/2023/11/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(01)/"/>
      <url>/2023/11/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(01)/</url>
      
        <content type="html"><![CDATA[<p>学习C语言对于我来讲已经不止一次了，记得大学时为了参加比赛，从0自学C语言，再到研究生期间为了找工作，按照课本上的知识点，又从新过了一遍。这次我打算再从新过一遍，每一遍都会学到新的知识点，对C语言有更深的理解。整个学习过程是采用大学MOOC慕课的方式，我参考的是翁恺的C语言课程，据了解，网上一致反映讲的很好！</p><span id="more"></span><h3 id="程序设计与C语言"><a href="#程序设计与C语言" class="headerlink" title="程序设计与C语言"></a>程序设计与C语言</h3><h4 id="计算机和编程语言"><a href="#计算机和编程语言" class="headerlink" title="计算机和编程语言"></a>计算机和编程语言</h4><ul><li><p>编译执行和解释执行</p><p>使用编译器将源文件经过预处理，汇编，编译和链接生成目标文件的方式成为编译执行；编译型语言具有更加确定的运算性能。</p><p>采用解释器对源文件进行解释的方式称为解释执行，解释执行不需要处理所有文件行，可以一边解释，一边执行。解释型语言具有更好的计算能力。</p></li></ul><h4 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h4><ul><li><p>C语言的标准</p><p>C11 C99 ANSI C C17</p></li><li><p>C语言的发展</p><p>​1972年诞生于贝尔实验室；1978年有了C语言的第一个正式描述**K&amp;R the C **；1989年ANIS发布了C语言的标准；1999年发布C99，引入了一些新的特性；2011年发布C11标准；2018年发布C17标准。C语言发展于B语言，B语言发展于BCPL语言，BCPL语言发展于FORTRAN。</p></li></ul><h4 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h4><ul><li><p>如何理解GCC？</p><p>GCC全称GNU Compiler Collection，GUN编译器套件；是跨平台，支持多种语言的编译器套件，其中GNU全称GNU’s Not Unix是一个自由软件项目，项目意在创建一个类Unix的操作系统，允许用户自由的分享软件，包括GNU工具集（里面就包括<strong>GCC</strong>），宏语言和工具，基本命令，shell等，但后来其内核并没有广泛采用，而工具集被Linux采用，所以现在的Linux被称为GUN&#x2F;Linux。</p></li><li><p>Turbo C Visual C GCC他们三个都一样，都是编译器。</p></li><li><p>为啥main函数有的是int main, 有的是 void main？</p><ul><li>int main 规范推荐的书写方式，需要有return 返回值</li><li>void main 不需要return返回值，不推荐，理由是不符合C语言标准，编译器会发出警告，具有不清晰的退出状态，使得其他程序调用时不知道状态</li></ul></li><li><p>printf函数中的\r\n分别代表什么？</p><p>​\r表示回车，使光标回到起始位置； \n代表换行；</p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​这篇主要记录了C语言的一些发展，编译器的名称，以及在编程中的一些基础知识。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记02：复合类型（一）</title>
      <link href="/2023/11/18/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(02)/"/>
      <url>/2023/11/18/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(02)/</url>
      
        <content type="html"><![CDATA[<p>这篇文章是记录我在C++ Primer这本书中学习到的第四章内容，在前一章变量的基础上，这一章主要讨论了数组、字符串、结构体等问题。</p><span id="more"></span><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是一种数据格式，可以存储多个同类型的数据，首先这里需要注意，一个数组只能存储同一类型的数据，比如：int数据只能存储int类型的数据，不能存储float类型的。之后在对数据进行声明时，需要指出以下几点：</p><ul><li>存储在每个元素中的值的类型</li><li>数组名称</li><li>数组中元素的个数<br>包含以上三点后，数组的声明一般格式如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeName arrayName[arraysize];</span><br></pre></td></tr></table></figure>C++中的数组使用方法基本和C差不多，数组的位数跟数组类型以及元素个数有关。最后一点需要注意的是，对于数组声明时，不要让编译器自己去算数组中元素的个数，这样做可能会出错，而且还要知道，数组的个数在声明时可以比实际的数据的个数大，这样其他位置默认为0。</li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>首先对于字符串的表示有两种方法，第一种是将一系列单个字符存储到数组中，但是需要注意要在末尾加上空字符\0。另外一种是采用双引号将字符括起，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> fish[]=<span class="string">&quot;Bulles&quot;</span>;</span><br></pre></td></tr></table></figure><p>在数组中使用字符串和C语言一样，如果想要单个字符，只需要对数组加上下标即可，如果需要全部，则直接fish。之后对于字符串在C++程序中的输入，可以使用cin，但是这种存在一个问题，当我们输入一个字符串时，如果里面有空字符，cin会默认空字符前面的是一次输入，如果这时还有一次输入，则程序会将空字符后面的作为第二次输入。为了解决以上的问题，C++提供了两种面向行的类成员函数：getline()和get(),下面对这两种用法做一个说明。</p><ul><li>getline()函数使用起来比较简单，读取到换行符后将其丢弃。例如：cin.getline(name,20)表示将输入数据存储到name数组中，数据个数最大20.</li><li>get()函数不会将其换行符进行丢弃，将就会造成一定的问题，为了解决这个问题，可以采用：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>(name,<span class="number">20</span>).<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure></li></ul><h3 id="string类简介"><a href="#string类简介" class="headerlink" title="string类简介"></a>string类简介</h3><p>string类可以非常友好的表示字符串，主要体现在以下几个方面，首先在声明时，如果没有对其进行初始化，则string会默认将其内存置0，即不占用内存。然后在使用方面可以随意使用加减符号对字符串进行拼接。最后string可以使用getline()或者cin对数据进行赋值。使用string类声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  <span class="comment">//使用string必须包含该头文件</span></span></span><br><span class="line">string str;       <span class="comment">//内存为0</span></span><br><span class="line">string str1 = <span class="string">&quot;test&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>在前面提到的数组中，只能存储同一类型的数据，当我们如果想存储不同类型的数据时，我们可以采用结构体这种方式，其结构体定义组成如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">inflatable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">float</span> volume;</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中在结构体中不仅可以定义<strong>char&#x2F;int&#x2F;float</strong>型，还可以定义<strong>string类</strong>，例如：string name;定义成结构数组之后，需要在程序中进行引用，其引用的格式如下：inflatable hat.注意在C++中引用结构体不需要struct字符。在定义完成之后，便可以使用成员运算符（.）来访问各个成员，例如hat.name或者hat.volume。<br>如果对于相同类的结构体，其定义相同，我们可以进行赋值操作。另外结构体还可以定义成结构数组，如下定义:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inflatable gifts[<span class="number">100</span>];</span><br></pre></td></tr></table></figure><p>其含义为gifts将是一个inflatable数组，其中的每个元素都是inflatable的对应，注意gifts本身是一个数组，不是结构。在使用时可以gifts[10].name。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要记录了数组、字符串、string类、结构体的定义以及使用方法，对比了相当于C语言的差别。下一篇将对于指针、枚举以及存储做重点记录。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记01：数据处理</title>
      <link href="/2023/11/18/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(01)/"/>
      <url>/2023/11/18/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(01)/</url>
      
        <content type="html"><![CDATA[<p>从这篇笔记开始开始，我将用博客记录我的学习成果，一方面可以巩固这些内容，另外一方面可以为以后做参考。</p><span id="more"></span><h3 id="C-变量命名规则"><a href="#C-变量命名规则" class="headerlink" title="C++变量命名规则"></a>C++变量命名规则</h3><p>对于C++来讲，其变量命名和C大致相同，其中需要注意：</p><ol><li>名称的第一个字符不能是数字</li><li>要区分大写字符和小写字符</li><li>在名称中，只能采取字母字符、数字、和下划线</li><li>对于变量的长度并没有限制，其命名方案也没有一定的要求，一般我们采用首字母大写</li></ol><h3 id="关于整形数据的理解"><a href="#关于整形数据的理解" class="headerlink" title="关于整形数据的理解"></a>关于整形数据的理解</h3><h4 id="字节和位"><a href="#字节和位" class="headerlink" title="字节和位"></a>字节和位</h4><p>首先要知道位是组成字节的最小单位，可以把位理解成0和1，然而字节表示8位的内存单元，可以理解成8位组成一个字节。字节又是表示计算机内存量的存储单位，其中1KB&#x3D;1024字节。字节表示该变量在计算机内存空间大小，1个字节表示8位，其值为0-255或者-128到127。</p><h4 id="有符号整形"><a href="#有符号整形" class="headerlink" title="有符号整形"></a>有符号整形</h4><p>主要包含<strong>int&#x2F;short&#x2F;long&#x2F;longlong</strong>,其中如果声明一个int的整形变量，则该变量占有计算机存储空间为4字节32位，其数值表示范围：-2147483648到2147483647；声明一个short整形变量将占有2个字节16位，其数值变化为：-32768到32767；声明一个long将占用4个字节32位，声明一个longlong,将占用8个字节64位。在进行变量声明时，要注意选择最合适的字节占有量。</p><h4 id="无符号整形"><a href="#无符号整形" class="headerlink" title="无符号整形"></a>无符号整形</h4><p>无符号整形的标志为<strong>unsigned</strong>(unsigned int) 后面可以为short&#x2F;long等，表示该整形数据只为正数，也就是从0开始一致增加。例如 unsigned short 表示0-65535变化，而short则表示从-32768到32767；在变量定义时，根据实际情况选取即可。</p><h3 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h3><p>对于C语言来讲，我们常常使用#define来定义我们在程序全局中使用的一个变量，但是对于C++来讲，我们需要改掉这个习惯，C++采用const字符来定义一个全局变量字符，其具体格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> type name =value;</span><br></pre></td></tr></table></figure><p>这样做的好处在于一方面可以明确指定类型，另外一方面可以根据作用域规则将其限定在特殊的函数或者文件中。</p><h3 id="关于浮点数的理解"><a href="#关于浮点数的理解" class="headerlink" title="关于浮点数的理解"></a>关于浮点数的理解</h3><p>首先浮点数有两种书写方式，一种是常规的书写方式，例如：3.14；另外一种是采用E表示法，例如3.45e6表示3.45与10的6次方相乘，其结果为3450000。采用这种方式可以很好的表示最大的数和最小的数。然后浮点数的类型有<strong>float&#x2F;double&#x2F;long double</strong>型，通常，float有32位有效位数，double有64位有效位数，long double有80、96或者128位有效位数。总之，对于三种浮点数据类型，<strong>其经度最大的是long double,最小的是float。</strong> 最后，在程序中，当我们书写像8.24这样的浮点数据时，程序默认存储为double类型，如果想存储为float或者long double需要在数据后面加f或者L后缀。</p><h3 id="C-算术运算符"><a href="#C-算术运算符" class="headerlink" title="C++算术运算符"></a>C++算术运算符</h3><p>在C++中，首先算术运算符的类型和优先级大致和C一样，比如含有加减乘除以及%运算，其中乘除优先级大于加减。当运算符在一个语句中并列时，程序采用从左向右运算。然后对于除法操作，当两个数为整形时，C++将采取整数除法，得到的结果也是整数；当两个数中有一个是浮点数时，C++将采取浮点数运算，结果也是浮点数，默认为double类型。<br>对于数据类型转换，程序会自动进行，或者手动转换，在转换过程中，如果将位数低的数据类型转换成位数高的数据类型，将不会存在风险，反之，将存在一定的风险，例如：将int类型转换成short类型。如果将浮点数据转换成整形数据，也会存在一定的风险。最后对于数据可以进行强制转换，其C++的格式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">typeName</span> (value);</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>首先C++的基本类型主要分为两种，一种是存储整形的，另外一种是存储浮点型的。对于整形来讲，有分为有符号和无符号。浮点型主要包含3种。然后对于算术运算符，基本上和C差不多。最后有一个数据类型的转换，基本上都可以安全实现，但是需要注意浮点型和整形之间的转换以及强制转换的格式。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构随笔03：循环、静态、双向链表</title>
      <link href="/2023/11/16/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%BE%AA%E7%8E%AF%E3%80%81%E9%9D%99%E6%80%81%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/11/16/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%BE%AA%E7%8E%AF%E3%80%81%E9%9D%99%E6%80%81%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>今天接着对线性表中不怎常用但是需要理解的后三种链表结构的思想做介绍，分别为循环、静态、双向表。理解即可，具体的实现代码请详见附件。</p><span id="more"></span><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表行程一个环，这种头尾相连的单循环链表称为循环链表。循环链表解决了单链表无法解决的一个问题，就是如何从当中任意一个结点出发，访问到链表的整个结点。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**循环链表的结点*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CircularNode</span>&#123;</span></span><br><span class="line">    ElementType data;         <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CircularNode</span> *<span class="title">next</span>;</span> <span class="comment">//指向下个节点的指针域</span></span><br><span class="line">&#125;CircularNode;</span><br><span class="line"><span class="comment">/**循环链表结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CircularLinkList</span>&#123;</span></span><br><span class="line">    CircularNode *next;       <span class="comment">//指向第一个节点的指针，头指针</span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;CircularLinkList;</span><br></pre></td></tr></table></figure><h5 id="Operation"><a href="#Operation" class="headerlink" title="Operation"></a>Operation</h5><p><strong>插入</strong>的思想大致就是首先分为两大类，一类是插入的位置是第一个结点，另外一类是插入的位置不在第一个结点。对于第一种情况也有两种情况，一是整个链表为空，另外一个非空，如果是空，则直接插入的下一个元素还是该元素，如果非空，则找到链表中最后一个元素，将该最后的元素的下一个元素指向要插入的元素。当插入的结点不在第一个位置时，需要先利用for循环找到插入位置的元素，然后将该元素的下一个指向赋值给插入元素的下一个指向，该元素的下一个指向插入的元素，长度加加，有一种特殊情况就是插入的位置为最后一个元素的位置，这时就需要将链表的头指针指向指向的元素赋值该待插入元素指向的下一个元素。<br><strong>初始化</strong>循环链表的思路就是采用一个for循环不断地从第一个位置插入元素即可<br><strong>删除</strong>链表种指定位置的元素的思路大致为首先分为两种情况，第一种情况就是删除元素的位置处于链表的第一个位置，另外一种情况就是删除元素的不处于第一个位置的任意位置。对于处于第一个位置的元素，先是根据头指针找到则会个元素，提取元素的数据域进行返回，然后利用循环找到最后一个元素，让删除元素的指向下一个的指针赋值给头指针，然后再将最后一个元素的下一个指针指向头指针指向的元素。最后利用free对删除元素的内存进行释放。对于删除的位置不是第一个位置，则是找到删除元素和删除元素的上一个元素，然后将删除元素的下一个指向的元素赋值给上一个元素下一个指向的元素。<br><strong>根据元素</strong>返回对应的结点的函数是循环链表中特有的一个函数，即根据元素的内容返回该内容对应的结点。实现的方案就是do while循环框架实现即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**在循环链表的指定位置插入元素*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertCircularLinkList</span><span class="params">(CircularLinkList *clist,<span class="type">int</span> pos,ElementType element)</span>;</span><br><span class="line"><span class="comment">/**初始化循环链表*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitCirclarLinkList</span><span class="params">(CircularLinkList*clist,ElementType *dataArry,<span class="type">int</span> length)</span>;</span><br><span class="line"><span class="comment">/**删除循环链表中指定位置的元素*/</span></span><br><span class="line">ElementType <span class="title function_">DeleteCircularLinkList</span><span class="params">(CircularLinkList *clist,<span class="type">int</span> pos)</span>;</span><br><span class="line"><span class="comment">/**根据元素内容返回对应的节点*/</span></span><br><span class="line">CircularNode *<span class="title function_">GetCircularLinkListNode</span><span class="params">(CircularLinkList *clist,ElementType element)</span>;</span><br></pre></td></tr></table></figure><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>静态链表就是起初那些不是高级的语言中，是没有指针的概念的，也就是说没法随机申请内存和释放内存的。但是面对链式链表这种好的特性，科学家们就依据数组对链表进行模拟实现了链表所实现的功能。这种用数组描述的链表叫做静态链表。需要注意一点就是静态链表现在肯定用不上了，但是这种思想可以学习下。<br>通常未被使用的数组元素称为备用链表，下标为0的元素的游标中放备用链表的第一个结点的下标；数组下标最后的元素中的游标中存放第一个有数值元素的下标。</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="Data-1"><a href="#Data-1" class="headerlink" title="Data"></a>Data</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   ElementType data;    <span class="comment">//数据域</span></span><br><span class="line">   <span class="type">int</span> next;            <span class="comment">//int cursor; 游标，如果为0则表示无指向,相当于指针</span></span><br><span class="line">&#125;StaticLinkList[MAX_SIZE_SSL];</span><br></pre></td></tr></table></figure><h5 id="Operation-1"><a href="#Operation-1" class="headerlink" title="Operation"></a>Operation</h5><p><strong>初始化</strong>链表就是利用for循环将当前下标元素的游标赋值为下一个下标，同时最后一个下标的游标置0<br><strong>分配内存</strong>就是模拟malloc函数，思想为获得下标为0的游标，也就是备用链表中的第一个元素的下标，将这个数值返回，并把这个数值为下标的游标赋值给下标为0的游标，其实也就代表使用了备用链表的一个空间。<br><strong>插入元素</strong>的方法就是找到链表中最后的一个元素，分配一个空间，将要插入的元素赋值给该空间，然后找到这个新空间的前缀结点，然后将游标进行互换即可。<br><strong>释放内存</strong>就是将下标为0的游标赋值给要释放空间的游标，再更新下数值为0下标的游标<br><strong>删除元素</strong>就是先找到要删除元素的前缀节点，然后互换下游标，最后释放该节点的空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**初始化链表*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStaticLinkList</span><span class="params">(StaticLinkList slList)</span>;</span><br><span class="line"><span class="comment">/**向指定位置插入元素*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">InsertStaticLinkList</span><span class="params">(StaticLinkList slList,<span class="type">int</span> pos,ElementType element)</span>;</span><br><span class="line"><span class="comment">/**为静态链表分配一个空间内存，返回ERROR表示内存分配失败*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mallocSSL</span><span class="params">(StaticLinkList slList)</span>;</span><br><span class="line"><span class="comment">/**获得静态链表的长度*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetStaticLinkList</span><span class="params">(StaticLinkList slList)</span>;</span><br><span class="line"><span class="comment">/**删除静态链表中指定游标的元素*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">DeleteStaticLinkList</span><span class="params">(StaticLinkList slList,<span class="type">int</span> pos)</span>;</span><br><span class="line"><span class="comment">/**释放静态链表中的指定下标空间*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FreeStaticLinkList</span><span class="params">(StaticLinkList slList,<span class="type">int</span> index)</span>;</span><br></pre></td></tr></table></figure><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表中是在单链表的每个节点中，再设置一个指向其前驱结点的指针域，方便更加迅速的查找，一句话就是用空间换时间。</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="Data-2"><a href="#Data-2" class="headerlink" title="Data"></a>Data</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**双向链表的结点，一个表示数据域，其他两个表示指针域*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DoublyNode</span>&#123;</span></span><br><span class="line">    ElementType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoublyNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoublyNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;DoublyNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DoublyLinkList</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    DoublyNode *next;</span><br><span class="line">&#125;DoublyLinkList;</span><br></pre></td></tr></table></figure><h5 id="Operation-2"><a href="#Operation-2" class="headerlink" title="Operation"></a>Operation</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**向双向链表的指定位置插入元素*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InserDoublyLinkList</span><span class="params">(DoublyLinkList *dlList,<span class="type">int</span> pos,ElementType element)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建空结点</span></span><br><span class="line">    DoublyNode *node = (DoublyNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DoublyNode));</span><br><span class="line">    node-&gt;data = element;</span><br><span class="line">    node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">1</span>)&#123;</span><br><span class="line">        node-&gt;next = dlList-&gt;next;</span><br><span class="line">        dlList-&gt;next = node;</span><br><span class="line">        node-&gt;next-&gt;prev = node;  <span class="comment">//需要特别注意</span></span><br><span class="line">        dlList-&gt;length++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DoublyNode *currNode = dlList-&gt;next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; currNode&amp;&amp;i&lt;pos<span class="number">-1</span>; i++)  <span class="comment">//查找插入点的元素位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        currNode = currNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(currNode)</span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;prev = currNode;</span><br><span class="line">        <span class="keyword">if</span>(currNode-&gt;next)&#123;</span><br><span class="line">            currNode-&gt;next-&gt;prev = node;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;next = currNode-&gt;next;</span><br><span class="line">        currNode-&gt;next = node;</span><br><span class="line">        dlList-&gt;length ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此所有关于链表的内容已经全部学习完毕，至于怎么使用，我观察到单片机实时操纵系统中有段代码就是依据链表进行操纵的。重要是这种思想的把握。Remain true to our original aspiration!</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构随笔02：线性表的顺序和链式</title>
      <link href="/2023/11/16/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B002/"/>
      <url>/2023/11/16/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B002/</url>
      
        <content type="html"><![CDATA[<p>在对数据或者文件进行存储时，通常我们有几种不同结构进行选择，分别是顺序结构和链式结构。对于这两种结构的线性表是怎么对数据进行存储的，以及这两种结构各自的优缺点是什么，今天做个备忘。</p><span id="more"></span><h3 id="线程表"><a href="#线程表" class="headerlink" title="线程表"></a>线程表</h3><p>线性表表：零个或多个数据元素的有限序列，在定义中，有几点需要注意：</p><ol><li>线性表是一个有限的序列，也就是说对于无限的序列是不可以采用线性表进行操作的</li><li>数据元素一一对应，也就是讲存储的位置和元素一一对应，不能一个位置又存储这个，还存储另外的元素</li><li>线性表是有长度的，线性表元素的个数定义为线性表的长度，如果为0，则该表为空表</li><li>在较复杂的元素中，一个数据元素可以由多个数据项组成</li></ol><h4 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ADT 线性表（List)</span><br><span class="line">Data</span><br><span class="line"><span class="number">1</span>、线性表数据元素是一个集合&#123;a_1,a_2,....,a_n&#125;,数据元素的类型DataType</span><br><span class="line"><span class="number">2</span>、除了第一个元素a_1,每个元素只有一个直接的前驱元素</span><br><span class="line"><span class="number">3</span>、除了最后一个元素a_n,每个元素有且只有一个直接的后继元素</span><br><span class="line"><span class="number">4</span>、每个数据元素之间的关系是一对一的关系</span><br><span class="line">Operation</span><br><span class="line"> <span class="title function_">InitList</span><span class="params">(*List)</span>                        初始化线性表，创建一个空的线性表</span><br><span class="line"> <span class="title function_">InsertElement</span><span class="params">(*List,index,element)</span>     在线性表lsit的index下标处插入元素elem</span><br><span class="line"> <span class="title function_">DeletElement</span><span class="params">(*List,index,*elem)</span>        删除线性表Lsit中第i个元素，并返回删除元素的指针e</span><br><span class="line"> <span class="title function_">GetLenth</span><span class="params">(*List)</span>                        获得线性表的长度</span><br><span class="line"> <span class="title function_">IsEmpty</span><span class="params">(*Lsit)</span>                         判断线性表是否为空</span><br><span class="line"> <span class="title function_">ClearList</span><span class="params">(*List)</span>                       将线性表清空</span><br><span class="line"> <span class="title function_">GetElement</span><span class="params">(*List,index)</span>                在线性表中获取指定位置的元素</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h3 id="顺序线性表"><a href="#顺序线性表" class="headerlink" title="顺序线性表"></a>顺序线性表</h3><p>所谓的顺序线性表类似数组，我们知道数组在存储数据中是一种连续的存储方式，大致就是在内存中开辟一块连续的空间，注意这里是连续的空间，然后从首地址开始存第一个数据，依次往后。在数组的声明中，我们要给出数组的大小，同样在顺序表中，我们也是要给出以下三个属性：</p><ol><li>存储空间的起始位置</li><li>线性表的最大存储容量</li><li>线性表的长度</li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、定义数据元素</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> id;           <span class="comment">//元素的ID</span></span><br><span class="line">  <span class="type">char</span> * name;      <span class="comment">//元素的内容</span></span><br><span class="line">&#125;ElementType;</span><br><span class="line"><span class="comment">//2.定义顺序结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  ElementType datas[MAX_SIZE];   <span class="comment">//数据元素</span></span><br><span class="line">  <span class="type">int</span> length;                    <span class="comment">//顺序表长度</span></span><br><span class="line">&#125;Seqlist;</span><br></pre></td></tr></table></figure><h5 id="Operation"><a href="#Operation" class="headerlink" title="Operation"></a>Operation</h5><p><strong>插入</strong> 在指定位置插入一个元素，大概的思路从这个位置开始，将元素进行向后复制，也就是为这个元素腾出一个位置。然后将要插入的元素插入即可。需要注意的是在复制之前需要确保当时顺序表还有位置，同时插入元素的下标应该在[0-MAX_SIZE-1]。<br><strong>初始化</strong>线性表大致的思路就是对前面的插入函数进行调用，这里配合一个for循环，for循环的作用就是向指定的线性表中从第0个位置开始插入，直到线性表的长度达到初始化的长度。注意在进行插入函数调用之前需要确保初始化的链表长度小于最大的长度<br><strong>获得指定位置的元素</strong>的大致思路很简单，就是直接返回当前序号的值即可，在获得该返回值之后，根据这个函数，结合for循环查找可以实现删除线性表中指定位置的一个元素。具体的思路就是找到这个删除的元素，然后从这个元素的位置开始，将后面元素的值复制到前面的一个元素，也叫前移，这么做就实现了一个在指定的位置删除一个元素。<br><strong>其他相关的思路很简单</strong>，获得链表的长度就之间返回链表结构体中的长度选项，判断链表是否为空就可以根据链表的长度进行判断，如果为0则代表空链表。清空顺序表也是对长度进行操作，赋值0则代表清空这个数据链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在线性表的指定位置插入元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertElement</span><span class="params">(Seqlist *seqlist, <span class="type">int</span> index, ElementType element)</span>;</span><br><span class="line"><span class="comment">//初始化顺序线性表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(Seqlist *seqList,ElementType *elemArray,<span class="type">int</span> length)</span>;</span><br><span class="line"><span class="comment">//从指定位置处获得元素</span></span><br><span class="line">ElementType * <span class="title function_">GetElement</span><span class="params">(Seqlist *seqlist,<span class="type">int</span> index)</span>;</span><br><span class="line"><span class="comment">//在指定的位置删除一个元素</span></span><br><span class="line">ElementType * <span class="title function_">DeleteElement</span><span class="params">(Seqlist *seqlist,<span class="type">int</span> index)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">GetLength</span><span class="params">(Seqlist *seqlist)</span>;   <span class="comment">//获得链表的长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(Seqlist *seqlist)</span>;     <span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearElement</span><span class="params">(Seqlist *seqlist)</span>;  <span class="comment">//清空链表中的元素</span></span><br></pre></td></tr></table></figure><p>具体的函数的实现，可以参考附件中的Sequence.c和Sequence.h文件。</p><h3 id="链式线性表"><a href="#链式线性表" class="headerlink" title="链式线性表"></a>链式线性表</h3><p>在进行顺序链表的分析后，你是不是发现一个问题，那就是如果我要在一个位置插入或者删除一个元素，需要对后面的所有元素进行操作。这么做对于整个链表来讲肯定降低其效率，同时顺序链表还有一个缺点，那就是它的空间的大小是固定的。对于内存空间无法正确的最大化利用。这时链式线性表就应运而生了，它的存储元素的方法和顺序表的形式大不一样。<br>链表线性表的存储的思想是在每个元素中存放着下一个元素的位置，这样从一个元素就知道后面的位置了。这么做就需要数据元素分为两个部分，一部分用于存储数据，另外一部分用于存储下一个元素的地址。这么做成功解决了上述顺序表的缺点，在插入和删除元素时不需要对所有的元素进行操作，只需要对数据元素的指针域进行操作即可。同时这种方法也解决了内存的问题，这种方式可以实现不同元素的任意位置存储，我只需要知道它的地址就行即可。总结之后就是以下几点：</p><ol><li>链式线性表不需要规定长度</li><li>存储的元素个数不受限制</li><li>插入和删除元素时，不需要移动其他元素</li></ol><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="Data-1"><a href="#Data-1" class="headerlink" title="Data"></a>Data</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义链表的节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElementType data;   <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>  <span class="comment">//指针域</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义链表的头节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkList</span>&#123;</span></span><br><span class="line">    Node *next;         <span class="comment">//头指针</span></span><br><span class="line">    <span class="type">int</span> length;         <span class="comment">// 链表的长度，初始值为0</span></span><br><span class="line">&#125;LinkList;</span><br></pre></td></tr></table></figure><h5 id="Operation-1"><a href="#Operation-1" class="headerlink" title="Operation"></a>Operation</h5><p><strong>插入方法</strong>的思想首先是创建一个空节点，将要插入的数据赋值给该节点的数据域，然后找要插入节点的位置，这里有两种情况，第一种情况是插入的位置是链表的第一个位置，如果这种情况，则将头指针指向该空节点，然后长度加1；第二种情况是声明一个当前节点并将首节点赋值该节点，采用一个for循环进行查找，for循环的条件是当前节点不为空，并且变量i要小于当前位置减1，在这里需要注意一点就是减1.循环中要做的就是不断的将当前元素的下一个节点赋值给当前节点。最后查找要插入的位置之后，检查下该节点不是最后一个节点，也就是非空，然后将该节点的后面一个数据赋值给插入空节点的后面节点，然后把插入的空节点再赋值给当前节点后面，长度加1.<br><strong>初始化</strong>链表就是采用一个循环调用上面的插入函数，进行不断的插入。<br><strong>删除</strong>链表的思想首先声明一个要返回元素的类型，然后分两种情况，第一种情况是要删除的元素为第一个元素，这时就就需要将头节点指向的第一个节点赋值给给声明的节点，判断下该节点不为空，将该节点的数据域赋值给前面声明的返回数据类型变量，然后将该节点后面的赋值给头指针指向的节点，对第一个节点的内存采用free进行释放，链表长度减1即可。第二种情况就是查找下要删除节点的位置，这里定义了两个节点进行查找，一个是前面定义的当前节点，另外一个是前一个节点，for循环的判断条件和插入的条件类似，循环体中不断地遍历当前节点和上一个节点。如果查找到之后将当前节点数据域赋值给要返回的变量，另外一方面就是将当前节点指示的下一个节点地址赋值给上一个节点接下来的地址，采用free释放当前节点，链表长度减1即可。<br><strong>整个链表的删除</strong>思想大致为声明两个节点一个当前的，一个是下一个的节点。之后采用while循环进行遍历，当前节点的下一个节点赋值给下一个节点，删除当前节点，之后将下一个节点赋值给当前节点。直到当前节点为空（末节点）<br><strong>判断整个链表是否为空</strong>很简单，就是直接判断下链表的长度就行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在链表的指定位置插入元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertLinkList</span><span class="params">(LinkList * linklist, <span class="type">int</span> pos, ElementType element)</span></span><br><span class="line"><span class="comment">//初始化链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitLinkList</span><span class="params">(LinkList *linklist,ElementType * dataArray,<span class="type">int</span> length)</span></span><br><span class="line"><span class="comment">//删除链表指定位置的数据并返回该数据</span></span><br><span class="line">ElementType <span class="title function_">DeleteLinkList</span><span class="params">(LinkList * linklist,<span class="type">int</span> pos)</span></span><br><span class="line"><span class="comment">//清除整个链表的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearList</span><span class="params">(LinkList * linklist)</span></span><br><span class="line"><span class="comment">//判断该链表是否为空</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ISLinkListEmpty</span><span class="params">(LinkList *linklist)</span></span><br><span class="line"><span class="comment">//在链表中获取指定位置的元素并返回该元素</span></span><br><span class="line">ElementType <span class="title function_">GetElementLinkList</span><span class="params">(LinkList *linklist,<span class="type">int</span> pos)</span></span><br></pre></td></tr></table></figure><h3 id="两种结构对比"><a href="#两种结构对比" class="headerlink" title="两种结构对比"></a>两种结构对比</h3><h4 id="存储分配方式"><a href="#存储分配方式" class="headerlink" title="存储分配方式"></a>存储分配方式</h4><p>顺序存储结构用一段连续的存储单元依次存储线性表的数据元素<br>单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素</p><h4 id="时间性能"><a href="#时间性能" class="headerlink" title="时间性能"></a>时间性能</h4><p><strong>查找</strong> 顺序存储结构0（1） 单链表0（n)<br><strong>插入和删除</strong> 顺序存储结构需要平均移动表长一半的元素，时间为0(n)；单链表在找出某位置的指针后，插入和删除时间仅为0（1）</p><h4 id="空间性能"><a href="#空间性能" class="headerlink" title="空间性能"></a>空间性能</h4><p>顺序存储结构需要预分配存储空间，分大了，会浪费，分小了，易发生溢出<br>单链表不需要分配存储空间，只要有就可以分配，元素的个数也不受限制。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构笔记01：绪论与算法</title>
      <link href="/2023/11/16/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B001/"/>
      <url>/2023/11/16/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B001/</url>
      
        <content type="html"><![CDATA[<p>从这个月开始，我将着手准备学习两门与计算机相关的知识，一个是数据结构，另外一个是Linux。其实这两项知识点自己很久以前就有想系统学习的想法，但是由于一些其他的原因吧，到最后都耽搁了。数据结构照着《大话数据结构》阅读过一次，但是到目前好像已经忘的差不多了。所以这次我打算换一种学习的方式，一边看书实战，一边采用博客文章去记录。</p><span id="more"></span><h3 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h3><p>在绪论方面主要是要去了解一些相关的概念，这其中包含数据、数据元素、数据项、数据对象、数据结构等相关的概念。对于这些概念定义了解即可，详细定义可以参考如下：<br><strong>数据：</strong> 是描述客观实物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据有很多不同的类型，在这里需要注意的就是满足可以输入、可以处理两项即可。<br><strong>数据元素：</strong> 是组成数据的、有一定意义的基本单位，在计算机中通常用作整体处理。<br><strong>数据项：</strong> 一个数据元素可以由若干个数据项组成，数据项是数据不可分割的最小单位。记住数据项是最小单位就行。<br><strong>数据对象：</strong> 是性质相同的数据元素的集合，是数据的子集。<br><strong>数据结构：</strong> 是相互之间存在一种或多种特定关系的数据元素的集合<br>对于数据结构，又可以分为逻辑结构和物理结构两大类，其中逻辑结构又包含集合结构、线性结构、树形结构、图形结构；物理结构又包含顺序物理结构、链式存储结构，链式存储结构优点特性要远远大于物理结构。链式存储结构就好比如在存放数据时不考虑数据实际的存储位置，无论数据存储在什么地方，在其中会有一个指针来将这些存储在不同物理结构上但具有一定逻辑结构的数据关联起来，这就是链式存储。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>关于算法的认识我主要总结以下几个方面：首先是涉及的一些定义，例如什么是算法，算法和数据结构之间存在什么的关系，一个好的算法应该具备什么的特性等等，然后是如何判断一个算法的优劣，在这其中判断一个好的算法的方式有两种，第一种是事后判断就是让不同算法编写的程序在电脑上运行，比较程序在电脑上运行的时间，根据时间的长短来判断算法的优劣性，这种方式不可取，因为外界不确定的因素太多了。第二种方式是事前判断，这里面就涉及到一个大O阶方法，后面详细介绍。最后是列举了一些常见的时间复杂度，介绍了最坏情况与平均情况。</p><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>数据结构与算法：</strong> 其实两者的关系相辅相成，在学习数据结构中加入算法，可以让你更加理解数据结构<br><strong>算法：</strong> 算法是解决特定问题求解步骤的描述，在计算机中为指令的有限序列，并且每一条指令表示一个或多个操作<br><strong>特性：</strong> 有穷性、确定性、可行性、输入输出<br><strong>要求：</strong> 正确性、可读性、健壮性、高效率和低存储</p><h4 id="度量方法"><a href="#度量方法" class="headerlink" title="度量方法"></a>度量方法</h4><p>事后度量方法前面有所叙述，在此不再叙述，总之这种方法不可取。事前度量方法，在这其中有一个算法的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n&gt;N，f(n)总是比g(n)大，那么就说f(n)的渐近增长快于g(n)。可以得出判断一个算法的好坏，不能只通过少量的数据下结论，需要对比算法的渐近增长性。<br><strong>复杂度定义：</strong> 在进行算算法分析时，语总的执行次数T（n)是关于问题规模n的函数，进而分析T（n)随n的变化情况并确定T（n)的数量级。算法的时间复杂度也就是算法的时间量度，记作：T(n) &#x3D; O(f(n))。<br><strong>推导大O阶方法：</strong> </p><ol><li>用常数1取代运行时间中的所有加法常数</li><li>在修改后的运行次数函数中，只保留最高阶项</li><li>如果最高阶项存在且不是1，则去除与这个项相乘的常数。<br>得到的结果就是最大O阶，常见的最大O阶项有常数阶、线性阶、平方阶、对数阶等等。对于最大O阶项有一个时间复杂度公式(时间复杂度从小到大）：<br>$ O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n) $</li></ol><h4 id="其他相关"><a href="#其他相关" class="headerlink" title="其他相关"></a>其他相关</h4><p>最坏情况和平均情况，其实这两个概念是相对比较容易理解的，在这里就不做介绍。还有一个是空间的复杂度，也就是说可以实用空间的复杂度去替代时间的复杂度。空间的复杂度也是比较好理解的，牺牲空间来换取代码的执行效率。这种方法对于简单的还可以，但是对于一些复杂的问题，选择这种方法显得就有些鸡肋了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>主要是大概阐述了下数据结构和算法两个方面的定义吧。对数据结构的概念有个相对感性的认识，目前还没有接触到一些经典优秀的算法。后面将会接触，期待后面学习！</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对近期绘制PCB的的一些总结</title>
      <link href="/2023/11/16/%E7%A1%AC%E4%BB%B6%E5%BC%80%E5%8F%91%EF%BC%9A%E5%AF%B9%E7%BB%98%E5%88%B6PCB%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>/2023/11/16/%E7%A1%AC%E4%BB%B6%E5%BC%80%E5%8F%91%EF%BC%9A%E5%AF%B9%E7%BB%98%E5%88%B6PCB%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>在没有学习PCB绘制之前，就对PCB有着浓厚的兴趣，看到电路板上密密麻麻的线，就充满着好奇和成就感。在这一年的学习中，先是用国产EDA软件绘制成功自己第一块PCB，到现在熟练使用AD绘制各式各样的两层板，中间遇到了大大小小的困难，也出现了不同层级的失误，这篇文章主要对这些做一个总结和记录，以便以后查阅。</p><span id="more"></span><h3 id="AD绘制PCB的流程"><a href="#AD绘制PCB的流程" class="headerlink" title="AD绘制PCB的流程"></a>AD绘制PCB的流程</h3><p>AD（Altium Designer）是原Protel软件开发商Altium公司推出的一体化的电子产品开发系统。目的在于帮助电子开发者快速高效地设计开发PCB（Printed Circuit Board）。其大致的流程如下：</p><h4 id="新建PCB工程"><a href="#新建PCB工程" class="headerlink" title="新建PCB工程"></a>新建PCB工程</h4><p>  并为PCB工程添加原理图和PCB文件，新建好的工程一般如下：<br><img src="https://i.loli.net/2021/08/07/JOglkNFBTcMyZEz.png" alt="image.png"></p><h4 id="原理图绘制"><a href="#原理图绘制" class="headerlink" title="原理图绘制"></a>原理图绘制</h4><p>   在原理图绘制过程中，可以参考一些成熟的电路图或者芯片手册提供的典型电路图。在绘制过程中，一般流程为先放置元器件，然后根据元器件的多少，选择合适的原理图纸张大小，其纸张的设置如下所示：<br>   <img src="https://i.loli.net/2021/08/07/WcTANPf8b9GYa3l.png" alt="image.png"><br>   再然后使用导线连接元器件，在连接的过程当中，需要注意的是没有相连接的口，需要使用NO ERC符号，否则在编译中会出现警告。最后对连接好的电路图的标号进行统一的标记，其标记的方法如下：点击工具-&gt;标注-&gt;原理图标注，就会出现该界面，进行相关选择之后，点击更新即可。注意别忘了最后的编译，方法为点击工程，之后鼠标右击，点击Compile 工程名即可。</p><h4 id="PCB布线"><a href="#PCB布线" class="headerlink" title="PCB布线"></a>PCB布线</h4><p>   编译好的原理图，点击设计-更新到我们提前向工程中添加的PCB文件后，即可开始布线操作。<br>   <strong>1.板子外形</strong>：根据器件的封装大小选择合适的板子形状，其方法为：点击Keep-Out Layer层，右键放置-放置线条。线条用于绘制板子的形状。绘制完成之后，点击一个线条，查找相似对象，设置一定的条件选中所有我们绘制好的线条，之后点击设计-板子形状-按照选择对象定义即可。<br>   <strong>2.设计规则</strong>：设计规则其实就是我们提前定义好的在设计开发过程中需要遵守的一些规范，在设计规则中，主要需要设置以下几项：<br>   <img src="https://i.loli.net/2021/08/07/5HQKSDpOjodaLn4.png" alt="image.png"><br>   Clarance一般设置6mil;Witch一般设置成10mil至30mil,在绘制PCB中，对于电源线宽一般为20-30mil,在功率不大的线路板上15-18mil也是可以接受的。信号线宽一般10-15mil之间；PlaneConnect和PolygonConnect连接选择直连方式；HoleSize和一些间距根据实际的情况设置即可，一般生产产商都可以生产。其他选项的配置一般选择默认。<br>   <strong>3.布线和敷铜</strong>：布线过程中尽量选择均匀布线；使用电容去电源线滤波；布线过程中不要出现直角，对于两层板尽量在一层选择横向，在另外一层选择纵向，或反之；布线完毕后，进行敷铜，在敷铜中要先设置该层铜要连接的网络，否则会出现敷铜不成功，敷铜中可以更改Clarance&#x3D;18，进行敷铜，敷完之后，再将Clarance&#x3D;6。<br>   <strong>4. 丝印标记与NRC检查</strong>：一定要对于一些关键的接口做丝印说明，方便后续的使用。最后要对板子进行NRC检查，直到错误为0结束。</p><h4 id="生产"><a href="#生产" class="headerlink" title="生产"></a>生产</h4><p>对绘制好的PCB文件进行压缩，上传压缩文件至嘉立创平台，选择相应的参数即可完成生产 文件的提交。</p><h3 id="一年内踩过的坑"><a href="#一年内踩过的坑" class="headerlink" title="一年内踩过的坑"></a>一年内踩过的坑</h3><ul><li>元器件封装选择错误，还是最关键的芯片，GD32芯片选择成如下图所示，正确的封装应该为TSQFP50P1200*1200-64L。切记，芯片封装一定要选择正确<br><img src="https://i.loli.net/2021/08/07/FIJ59x7A2ypZ3Nl.png" alt="image.png"></li><li>连线错误，一根线与芯片IO口连接错误，出现这种方式要么更改软件连接，但是如果更改不了软件，那么这块板子基本就废了，所以一定要检查连接线，另外可以采用模块化设计的方式，提高产品的容错。</li><li>丝印没标，对于一些重要的接口，一定要有标注，这样下次使用时就不用再打开原理图核对了</li><li>对地短路，这种情况我虽然没有出现，但是绝对是致命的错误。</li><li>信号线太细：对于信号线，至少要10mil,如果器件不是特别多，可以设置成15mil</li><li>对于可调元件，如可调电位器，可调电容器，可调电感线圈，考虑其机械结构，方便操作</li></ul><h3 id="后续规划"><a href="#后续规划" class="headerlink" title="后续规划"></a>后续规划</h3><p>后续将对四层板进行实践并且制作，对象为OpenMV4,期待成品的设计。</p>]]></content>
      
      
      <categories>
          
          <category> 硬件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCB绘制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对32位单片机调试的总结</title>
      <link href="/2023/11/16/%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91%EF%BC%9A%E5%AF%B932%E4%BD%8D%E5%8D%95%E7%89%87%E6%9C%BA%E8%B0%83%E8%AF%95%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>/2023/11/16/%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91%EF%BC%9A%E5%AF%B932%E4%BD%8D%E5%8D%95%E7%89%87%E6%9C%BA%E8%B0%83%E8%AF%95%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>对于32位的ARM单片机，其程序烧录的方式除了采用原始的串口下载之外，还拥有即可烧录程序，也可在线调试的外部接口，即JTAG与SWD接口。单片机芯片指定了一些IO口在默认的配置下实现上述的功能，例如：PA13、A14、A15、PB3、PB4等。那么如何设置其中某几个IO口做普通使用呢，这篇文章将会给出答案。</p><span id="more"></span><h3 id="烧录方式"><a href="#烧录方式" class="headerlink" title="烧录方式"></a>烧录方式</h3><p>目前我经常用的烧录方式有三种，最开始使用JTAG方式去下载调试32单片机，到后来发现更加简单方便的SWD方式，再到后面的ST-LINK，其实也是SWD方式。</p><h4 id="JTAG方式"><a href="#JTAG方式" class="headerlink" title="JTAG方式"></a>JTAG方式</h4><p>JTAG：JTAG（JointTest Action Group；联合测试工作组）是一种国际标准测试协议，主要用于芯片内部测试。现在多数的高级器件都支持JTAG协议，如DSP、FPGA器件等。标准的JTAG接口是4线：TMS、TCK、TDI、TDO，分别为模式选择、时钟、数据输入和数据输出线。<br>市场上的J-Link下载器支持JTAG方式，其仿真器与单片机的连接电气图如下：<br><img src="https://i.loli.net/2021/08/06/T2sFtRoI7DrpdCX.png" alt="image.png"><br>除标准的4个IO接口外，还有nTRST、RTCK、RESET，分别表示的含义如下：<br><strong>nTRST</strong>：可选项，内核的调试复位信号，以用来对TAPController进行复位（初始化）<br><strong>RTCK</strong>：可选项，目标端反馈给仿真器的时钟信号,用来同步TCK信号的产生,不使用时直接接地<br><strong>RESET</strong>：可选项,与目标板上的系统复位信号相连,可以直接对目标系统复位。同时可以检测目标系统的复位情况，为了防止误触发应在目标端加上适当的上拉电阻。<br>JTAG在使用过程中，标准的4根线是必须要连接的，其他三根根据实际情况连接。</p><h4 id="SWD方式"><a href="#SWD方式" class="headerlink" title="SWD方式"></a>SWD方式</h4><p>SWD：SW（Serial Wire Mode Interface），串行接口线模式。在串行线模式，只有针TCLK和TMS使用。TDO数据输出引脚是一个可选。也就是说SWD只需要3根线就可以实现烧录与调试，分别是时钟线、数据线和地线。相比于JTAG的7根调试线，SWD连接和使用更加方便，其稳定性和可靠性也有进一步提升，通过配置SWD方式，还可最大化的利用单片机的IO口，使A15、PB3、PB4做普通IO口使用。市面上的J-Link下载器也支持SWD方式，其仿真器与单片机的连接电气图如下：<br><img src="https://i.loli.net/2021/08/06/L5WbGHDAMnos3Uu.png" alt="image.png"><br><strong>SWDIO</strong>:串行数据线，用于数据的读出和写入,与TMS复用<br><strong>SWDCLK</strong>:串行时钟线，提供所需要的时钟信号与TCLK复用</p><h3 id="特殊IO口定义"><a href="#特殊IO口定义" class="headerlink" title="特殊IO口定义"></a>特殊IO口定义</h3><p>在常用的32位ARM单片机中，PA13、A14、A15、PB3、PB4这几个IO默认配置成调试专用，其具体的定义在手册中如下：<br><img src="https://i.loli.net/2021/08/07/q6biyxHjoa2lc7v.png" alt="image.png"><br><img src="https://i.loli.net/2021/08/07/PqmLoAxi6gW1NZK.png" alt="image.png"><br>也就是说，如果在单片机初始化中不对这几个IO口进行配置，这些IO将无法作为普通IO口使用，有时候为了方便布线和管理，需要对这其中的某几个IO口进行设置的。</p><h3 id="程序配置"><a href="#程序配置" class="headerlink" title="程序配置"></a>程序配置</h3><p>需要进行配置的情况大致是，已经通过Keil软件设置成SWD方式进行烧录，这时需要在程序中添加以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rcu_periph_clock_enable(RCU_AF);  <span class="comment">//开启复用时钟</span></span><br><span class="line">gpio_pin_remap_config(GPIO_SWJ_SWDPENABLE_REMAP, ENABLE);  <span class="comment">//选择SWD调试方式</span></span><br><span class="line"><span class="comment">//gpio_pin_remap_config(GPIO_SWJ_NONJTRST_REMAP, ENABLE);  //SWD或者4线JTAG</span></span><br></pre></td></tr></table></figure><p>以上是GD32单片机提供的库函数设置，通过上面的两句话，就可以将A15、PB3、PB4做普通IO使用，PA13、A14做SWD的下载调试IO口使用。使用STM32CubeMX配置STM32芯片的过程如下，首先在STM32CubeMX中的配置如下：选择Pinout -&gt; System Core -&gt; SYS -&gt; Serial Wire即可。<br><img src="https://i.loli.net/2021/08/07/KFSHWmJBZTC97Dn.png" alt="image.png"><br>生成代码工程之后，在代码中的体现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__HAL_RCC_AFIO_CLK_ENABLE(); <span class="comment">//打开复用时钟</span></span><br><span class="line"> __HAL_AFIO_REMAP_SWJ_NOJTAG(); <span class="comment">//只选择SWD方式</span></span><br><span class="line"> <span class="comment">//__HAL_AFIO_REMAP_SWJ_NONJTRST() SWD或者4线JTAG</span></span><br></pre></td></tr></table></figure><p>需要注意的是在使用STM32CubeMX生成底层代码时，如果在之初没有选择Serial Wire，则默认处于NO Debug的状态，第一次可以烧录进程序，当第二次烧录时，就出现烧录不成功，显示没有找到芯片。处理的方式为：首先使用STM32CubeMX从新选择正确配置生成工程，点击烧录，在烧录的同时，将单片机的REST引脚拉低，当出现进度条时，取消REST引脚的拉低配置。出现这种情况的原因在于第一次烧录进去的程序没有配置SWD接口。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇首先学习了以前经常使用的JTAG和SWD的烧录方式，讲述了如何将A15、PB3、PB4做普通IO使用，主要包含两类单片机GD32和STM32的程序配置。最后对于一些可能出现的情况讲述了其对应的解决方案。</p>]]></content>
      
      
      <categories>
          
          <category> 裸机开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对32位单片机串口的理解</title>
      <link href="/2023/11/16/%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91%EF%BC%9A%E5%AF%B932%E4%BD%8D%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%B2%E5%8F%A3%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2023/11/16/%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91%EF%BC%9A%E5%AF%B932%E4%BD%8D%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%B2%E5%8F%A3%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>串口这个功能应该是很常用、基础的一个功能，无论是电脑与设备还是设备与设备之间都可以采用串口进行传输数据。在前段时间调试单片机与Dwin串口屏通信的过程中，对于接收走了很多的弯路，后来准备系统地学习下单片机的串口收发，写成一篇博客，供以后参考。</p><span id="more"></span><h3 id="串行通讯"><a href="#串行通讯" class="headerlink" title="串行通讯"></a>串行通讯</h3><h4 id="串行和并行比较"><a href="#串行和并行比较" class="headerlink" title="串行和并行比较"></a>串行和并行比较</h4><p>在数据传送过程中，分为串行和并行通信，其中并行通讯就是将数据的每一位一起发送，达到并行的效果，但是这种并行通信在面对位数比较大的数据时，需要大量的线缆连接，非常的不实用。这时就出来了串行通讯，就是将数据按照一定的规则排好队，一位一位的在数据线上进行传输。这种方式虽然相比于并行通讯效率会有一定的降低，但是需要的线缆数据量大大减少，普通的全双工串行通信只需要2根即可。</p><h4 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h4><p>串行通讯为了达到更好的传送效率，规定了数据帧的格式，发送端发送的数据和接收端接收的数据帧格式相同，目前常用的数据帧格式为1位停止位，8位数据位，无奇偶校验。<br><img src="https://i.loli.net/2021/08/08/1qvPyd9bw7WT5CD.png" alt="帧格式.png"></p><h4 id="波特率"><a href="#波特率" class="headerlink" title="波特率"></a>波特率</h4><p>波特率就是设备每秒传送数据的位数，常用的数值为9600 115200.如果发送和接收端的波特率不一致，就会出现乱码的情况，或者没有数据，在出现乱码时要及时检查波特率是否一致。</p><h3 id="USART模块原理图及主要寄存器"><a href="#USART模块原理图及主要寄存器" class="headerlink" title="USART模块原理图及主要寄存器"></a>USART模块原理图及主要寄存器</h3><h4 id="USART框图介绍"><a href="#USART框图介绍" class="headerlink" title="USART框图介绍"></a>USART框图介绍</h4><p>对于32位的单片机比51单片机功能复杂，下图为《STM32中文参考手册》中提供的串口结构框图。<br>在左侧部分是串口提供的一些引脚，需要关注的是TX、RX引脚，其他的引脚一般不会用到。对于结构图的理解为：从下向上走，首先是波特率发生器，波特率发生器就是为发送数据和接收数据提供必要的时钟，其在程序中对波特率寄存器进行设置以改变波特率的值。波特率提供的时钟经过16分频到达发送控制和接收控制器。发送和接收控制器通过时钟和一些相关的控制寄存器去控制发送移位寄存器和接收移位寄存器，如图中紫色线所示。发送移位寄存器根据发送控制器的信号将数据寄存器的数据通过TX口发送出去，接收移位寄存器通过接收控制器的控制，将RX口的数据存入到数据寄存器。以此来完成发送和接收。在发送和接收过程中，还有与之相关的控制器和标志寄存器。<br><img src="https://i.loli.net/2021/08/08/5n1d7p8fAL69FON.png" alt="串口结构框图.png"></p><h4 id="主要寄存器"><a href="#主要寄存器" class="headerlink" title="主要寄存器"></a>主要寄存器</h4><h5 id="状态寄存器"><a href="#状态寄存器" class="headerlink" title="状态寄存器"></a>状态寄存器</h5><p><img src="https://i.loli.net/2021/08/08/qWGvkfKY9rJLl7Q.png" alt="SR寄存器.png"></p><ul><li>TXE：发送数据寄存器为空；0：发送缓冲区有数据 1：发送缓冲区没有数据；根以根据判断这一位是1还是0来知道上一帧的数据有没有发送完成，一般在发送下一帧数据时，要等待前面的数据帧发送完成，也就是这一位为1.</li><li>TC：发送完成；0：发送没有完成，1：发送完成；这一位就是判断这个数据包什么时候发送完成，如果发送缓冲区为空，那么当前数据发送完成之后，就代表发送完成，TC&#x3D;1.</li><li>RXNE:读缓冲区非空；0：读缓冲区为空，1：读缓冲区不为空；这一位用于判断是否接收到数据，如果接收到一帧的数据，这一位就等于1.</li><li>IDLE：空闲线检测标志，0：未检测到空闲帧，1：检测到空闲帧；这一位主要是用于判断接收的数据是否完成，如果完成就代表有空闲帧，这一位就会置1.</li></ul><h5 id="数据寄存器"><a href="#数据寄存器" class="headerlink" title="数据寄存器"></a>数据寄存器</h5><p><img src="https://i.loli.net/2021/08/08/rgE5DFp2Q6vyLXY.png" alt="image.png"><br>数据寄存器32位，但是只有其中8位用于接收和发送数据暂存。</p><h5 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h5><p>控制寄存器有三个，但是只有第一个最常用，所以主要介绍第一个控制寄存器。<br><img src="https://i.loli.net/2021/08/08/lYKvxn1jaTrRm3C.png" alt="image.png"></p><ul><li>UE：串口使能位；0：USART分频器和输出被禁止 1：USART模块使能</li><li>PEIE：中断使能；0：禁止产生中断 1：可以产生中断</li><li>TXEIE：发送缓冲区空中断使能；0：禁止产生中断 1：可以产生中断</li><li>TCIE：发送完成中断使能；0：禁止产生中断 1：可以产生中断</li><li>RXNEIE：接收缓冲区非空中断使能；0：禁止产生中断 1：可以产生中断</li><li>TE：发送使能；0：禁止产生中断 1：可以产生中断</li><li>RE：接收使能；0：禁止产生中断 1：可以产生中断</li></ul><h3 id="USART发送实现"><a href="#USART发送实现" class="headerlink" title="USART发送实现"></a>USART发送实现</h3><p>手册中已经给出详细的串口发送配置，其流程如下：</p><ol><li>在USART_CTL1寄存器中置位UE位，使能USART；</li><li>通过USART_CTL1寄存器的M设置字长；</li><li>在USART_CTL2寄存器中写STB[1:0]位来设置停止位的长度；</li><li>在USART_BAUD寄存器中设置波特率；</li><li>在USART_CTL1寄存器中设置TE位；</li><li>等待TXE置位；</li><li>向USART_DATA寄存器写数据；<br>依据上面的大致流程就是开启串口时钟，写入相应参数，对串口以及发送使能。相关的C语言代码如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串口参数配置与使能</span></span><br><span class="line">usart_deinit(USART1);   <span class="comment">//复位串口1</span></span><br><span class="line">usart_baudrate_set(USART1, <span class="number">115200U</span>);  <span class="comment">//串口1波特率设置成115200</span></span><br><span class="line">usart_word_length_set(USART1, USART_WL_8BIT);  <span class="comment">//配置串口1数据长度8位</span></span><br><span class="line">usart_stop_bit_set(USART1, USART_STB_1BIT);  <span class="comment">//配置串口1停止位为1位</span></span><br><span class="line">usart_parity_config(USART1, USART_PM_NONE);  <span class="comment">//配置奇偶校验：无</span></span><br><span class="line">usart_hardware_flow_rts_config(USART1, USART_RTS_DISABLE);  <span class="comment">//配置串口1硬件控制流：除能RTS</span></span><br><span class="line">usart_hardware_flow_cts_config(USART1, USART_CTS_DISABLE);  <span class="comment">//配置串口1硬件控制流：除能CTS</span></span><br><span class="line">usart_receive_config(USART1, USART_RECEIVE_ENABLE);   <span class="comment">//使能接收</span></span><br><span class="line">usart_transmit_config(USART1, USART_TRANSMIT_ENABLE);  <span class="comment">//使能发送</span></span><br><span class="line">usart_enable(USART1);  <span class="comment">//使能串口</span></span><br><span class="line"><span class="comment">//发送子程序如下：</span></span><br><span class="line"><span class="keyword">while</span>(sendCount--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* wait until end of transmit */</span></span><br><span class="line">        <span class="keyword">while</span>(RESET == usart_flag_get(USART1, USART_FLAG_TBE));</span><br><span class="line">        usart_data_transmit(USART1, *sb++);</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>对于发送子程序的详细分析有while循环中如果usart_flag_get(USART1, USART_FLAG_TBE) &#x3D;&#x3D; RESET，那么程序就一直在while循环中循环，直到usart_flag_get(USART1, USART_FLAG_TBE) ！&#x3D; RESET，那么数据就会由这句usart_data_transmit(USART1, *sb++)写入到数据寄存器，由此通过TX引脚发出。usart_flag_get(USART1, USART_FLAG_TBE)这句话就是获取发送缓冲区是否为空，也就是判断状态寄存器中的TXEIE位，如果为空，则返回SET，while循环中判断条件不成立，程序跳过循环，执行下面那句，就把数据写入到了寄存器中，如果为RESET，那说明数据发送缓冲区还不为空，说明上一次的数据还没有发送完，需要在此等待。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USART_FLAG_TBE = USART_REGIDX_BIT(USART_STAT_REG_OFFSET, <span class="number">7U</span>),</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_STAT_REG_OFFSET                     (0x00000000U)        <span class="comment">/*!&lt; STAT register offset */</span></span></span><br></pre></td></tr></table></figure>程序中对TBE这个字符的定义如上所示，USART_STAT_REG_OFFSET代表状态寄存器的地址偏移，7U代表TBE为状态寄存器的第7位。</li></ol><h3 id="USART接收实现"><a href="#USART接收实现" class="headerlink" title="USART接收实现"></a>USART接收实现</h3><p>手册同样给出了USART配置成接收器的操作，在初始化串口完成的前提之下，需要完成</p><ol><li>在USART_CTL0中设置REN位；</li><li>开启串口中断</li><li>开启串口接收缓冲区的中断</li><li>判断接收缓冲区是否为非空，如果为非空，就读数据寄存器中的数据<br>USART的接收一般采用中断的方式进行，根据上面的流程，编写出相关的C程序代码如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">nvic_irq_enable(USART1_IRQn, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">//开启串口1中断</span></span><br><span class="line">usart_interrupt_enable(USART1, USART_INT_RBNE);<span class="comment">//使能串口1发送缓冲区非空中断</span></span><br><span class="line">usart_interrupt_enable(USART1, USART_INT_IDLE);<span class="comment">//使能串口1发送缓冲区空闲帧中断</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span>(RESET != usart_flag_get(USART1, USART_FLAG_RBNE))  <span class="comment">//USART_INT_RBNE</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/* receive data */</span></span><br><span class="line">        rxbuffer[rxcount++] = usart_data_receive(USART1); <span class="comment">//rxcount++</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(usart_flag_get(USART1, USART_FLAG_IDLEF) != RESET )</span><br><span class="line">&#123;</span><br><span class="line"> usart_data_receive(USART1);</span><br><span class="line"> bReceStatus = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>对于数据的接收子程序详细的分析如下：当数据接收缓冲区有数据时，会触发相应的中断，在中断中，再次判断标志寄存器的RBNE接收缓冲区非空的标志位是否为1，如果为1则代码这个缓冲区有数据，然后将数据从数据寄存器中取入到提前定义的buf中。正常的采用这种接收方式去接收字符串是没有错误的，但是上次在调试单片机与串口屏幕的通信时出现了问题，注意他们的通信采用的是16进制，也就是hex格式进行数据信息收发。错误的现象就是，无论串口屏给单片机发送多长的字节，例如0x5AA567AC，单片机接收到是始终只有前两个，也就是0x5AA5。导致通信无法解析，后来经过查阅资料发现，可以开启接收空闲帧的中断，这个意思大概就是0x5AA567AC是有很多帧组成的，在发送过程中，如果不加入空闲帧，那么说明数据现在还没有接收完成，加入空闲帧之后，当这个标志位为1时，说明现在数据帧接收完毕，线路上出现了空闲帧，这时就可以读取刚刚线路上接收到的完整数据帧了。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过这篇博客的总结，使我对串口的理解有了更进一步的认识，尤其是串口的接收和发送的实现代码，之前总是直接拿来使用，却没有想过为什么这么去写，有了这一次的总结，也使我以后对串口调试有了快速的解决方法。</p>]]></content>
      
      
      <categories>
          
          <category> 裸机开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>踩坑笔记01：CubeMX&amp;STM32的使用</title>
      <link href="/2023/11/16/%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91%EF%BC%9A%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B001/"/>
      <url>/2023/11/16/%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91%EF%BC%9A%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B001/</url>
      
        <content type="html"><![CDATA[<p>最近一这周一直在做一块面板，所以更新有些延迟，今天差不多已经做完了。这个面板使用到的外设也很简单，一个串口，两个OLED屏幕还有几个按键。做起来按理来讲也很快就能搞定，这次我尝试使用了CubeMX软件协助编程，由于第一次使用，真是做起来一会一个坑，所以今天在这里对这两天遇到的问题做一个总结。</p><span id="more"></span><h3 id="SWD调试接口"><a href="#SWD调试接口" class="headerlink" title="SWD调试接口"></a>SWD调试接口</h3><p>上来第一个就是SWD这个调试接口，由于之前没有怎么注意这个问题，在CubeMX做好相应的设置之后，我就直接生成了代码，代码编写完成之后，第一次使用SWD模式下载程序是没问题的，但是当我第二次下载时，它显示错误了，说内核没有发现。这个问题我之前没有遇到过啊，在百度之后，我发现我在CubeMX软件中没有开启SWD的调试IO口，导致程序下载进去后，SWD的IO虽然硬件上处于连接状态，但是软件上已经将这两个IO设置成普通IO口了，所以第二次下载程序不成功。<br><img src="https://i.loli.net/2021/04/16/2fm7KV9bzTl1GQI.png" alt="20210416140550"><br>解决方案：解决的方式也很简单，首先在CubeMX软件上开启SWD调试接口，如上图所示。然后再次生成程序。在编译之前将单片机RESET引脚置地，保持这种状态，然后点击下载程序，待程序出现下图所示时，将置地断开，可以看到程序已经成功地下载到了芯片中。如果下次断电或者重启，则可以继续使用SWD下载。但是需要注意一点是，在程序中我使用了TIM3定时器的编码器模式，程序下载进去之后，虽然已经开启SWD的IO口，但是还是不能使用SWD下载程序，网上有篇文章说是因为HAL库对寄存器读写设计的BUG，详见<a href="https://www.eemaker.com/stm32f103-cubemx-timer3-pwm.html">https://www.eemaker.com/stm32f103-cubemx-timer3-pwm.html</a><br><img src="https://i.loli.net/2021/04/16/cUb3Oz2x148MRvw.png" alt="20210416140217"></p><h3 id="GPIO设置"><a href="#GPIO设置" class="headerlink" title="GPIO设置"></a>GPIO设置</h3><p>之前发过一篇文章，里面阐述了GPIO的原理及其工作模式，具体包含5种工作模式，每个IO口都可以配置成输入或者输出。在这次体现中，体会了IO口上拉下拉的设置。详细为在按键配置过程中，一开始我配置成输入模式并且没有上拉或者下拉。这样在调试过程中出现按键按下去之后，程序很快就会检测到，但是按键松开后，原本检测高电平，但是迟迟没有检测到，会有2秒的延时。在详细检查之后，发现GPIO设置的没有上拉和下拉，配置成上拉之后，问题成功解决。还有一个配置也是类似，对于编码器的配置，在开始时没有注意到我将一个配置成上拉，另外一个没有做上拉配置，调试过程中就发现，那个没有配置上拉的旋钮非常的不灵敏而且不靠谱，配置成上拉之后，这个问题就成功解决了。<br>其实这个也跟简单，程序检测按键的高低电平，如果你在配置中不告诉程序中的IO口在默认状态下处于什么状态，那么整个程序控制起来就是不可控的。<br><img src="https://i.loli.net/2021/04/16/1naW73Tgc5OzEZJ.png" alt="20210416141635"></p><h3 id="EC11编码器"><a href="#EC11编码器" class="headerlink" title="EC11编码器"></a>EC11编码器</h3><p><img src="https://i.loli.net/2021/04/16/TMWjPQFv3a8tCrD.png" alt="20210416142340"><br>经常会看到EC11这种编码器，有的是双轴的，有的是单轴的。如上图所示，其中这种编码器和那种光电编码器类似，没有初始的位置和末尾的位置。当你旋转时，它配置A.B两个接口，这两个接口就会输出相应的脉冲变化，通过示波器可以发现如果你正转，A会比B相位超前90度，如果你反向转动，B会比A超前90度。每转动一次，AB的电平就会发生一次翻转。<br><img src="https://i.loli.net/2021/04/16/sRA8pzxcwZItyk1.png" alt="20210416142106"><br>硬件连接方面这种最中间的IO口要接地，左右两个IO口分别是AB相输出。刚开始我使用程序直接读取A相的电平状态来判断是否转动，这种是可以的，但是要判断转动的方向时，如果只用A相的输出是没法判断的，必须根据B相，来判断那个超前90度，来判定转动的方向。尝试使用IO口读取编写相应的逻辑代码失败后，采用了定时器编码器的方式，不得不说，使用CubeMX软件可以非常容易的配置定时器为编码器模式。在配置完编码器模式后，使用以下几句程序配置，使用三句代码就可以使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> HAL_TIM_Encoder_Start(&amp;htim3, TIM_CHANNEL_ALL);   <span class="comment">//开启编码器模式</span></span><br><span class="line">CountOutside=(<span class="type">uint32_t</span>)(__HAL_TIM_GET_COUNTER(&amp;htim3));   <span class="comment">//读取编码器的位置</span></span><br><span class="line">DirOutside=__HAL_TIM_IS_TIM_COUNTING_DOWN(&amp;htim3);  <span class="comment">//读取编码器的方向</span></span><br></pre></td></tr></table></figure><p>CubeMX的编码器模式配置如下：选择编码器模式，配置最大计数值即可，其他选择默认<br><img src="https://i.loli.net/2021/04/16/g4mtjThZWzAVR1i.png" alt="20210416143244"></p><h3 id="MAX13487芯片"><a href="#MAX13487芯片" class="headerlink" title="MAX13487芯片"></a>MAX13487芯片</h3><p>MAX13487芯片可以实现串口转485双向通讯。中间耽搁很久时间的原因是因为买到了假的MAX13478芯片，假的这种芯片只能发送，不能接收。整个过程来来回回更换了好几个器件，都没有解决，最后更换完另外一个批次的芯片之后，问题就成功解决了。一般来讲，在硬件电路方面，电阻电容以及二极管出现的故障概率并不是特别大，这时你要大胆的去猜测芯片有没有问题，当然，更换芯片也是从简单的到复杂的进行逐个判断。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在做完并且调试成功之后，还是有满满的成就感的，特别是实现相应的功能之后。在整个过程中也学到了很多的知识，对CubeMX和AD有了更加熟练的操作。对EC11编码器以及还有OLED屏幕的驱动有了经验。后期我打算空闲时间时，详细地去研究下比如定时器的编码器模式以及EC11和OLED屏幕驱动的原理等等。</p>]]></content>
      
      
      <categories>
          
          <category> 裸机开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STM32&amp;HAL笔记02：浅谈GPIO</title>
      <link href="/2023/11/16/%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91%EF%BC%9ASTM32&amp;HAL%E7%AC%94%E8%AE%B002%EF%BC%88GPIO)/"/>
      <url>/2023/11/16/%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91%EF%BC%9ASTM32&amp;HAL%E7%AC%94%E8%AE%B002%EF%BC%88GPIO)/</url>
      
        <content type="html"><![CDATA[<p>无论对于哪一款芯片来讲，其I&#x2F;O功能是至关重要的。对于STM32这款芯片来说，也不例外。在学习完芯片的心脏之后，我们今天来探讨下芯片的IO接口。本篇主要首先讲述STM32的GPIO的8种模式原理，之后对相关寄存器配置做简单介绍，最后使用CubeMX软件配置相应的IO口，生成HAL库代码，并对代码进行解释。</p><span id="more"></span><h3 id="模式介绍"><a href="#模式介绍" class="headerlink" title="模式介绍"></a>模式介绍</h3><p>GPIO为芯片和外设之间提供了输出或输入的接口，芯片使用IO口不仅可以对设备进行控制，而且还可以读取设备的传感器参数。STM32的GPIO一共有8种工作模式，分别是：输入浮空、输入上拉、输入下拉、模拟输入、开漏输出、推挽式输出、推挽式复用功能、开漏复用功能。可以通过相关的寄存器和电路进行配置。下面来依次介绍他的内部的实现原理。</p><h4 id="输入浮空"><a href="#输入浮空" class="headerlink" title="输入浮空"></a>输入浮空</h4><p><img src="https://i.loli.net/2021/04/01/BYaxoGHZ1cmCKeL.jpg" alt="01浮空输入.jpg"><br>所谓的输入浮空就是在输入口不接上拉也不接下拉，意思就是悬空这。内部信号走线如上图所示。VDD_FT表示这个IO口可以容忍0-5V的电压，可以通过芯片手册查看IO口是否表示FT来判断这个IO口的容忍电压。IO口数据过来之后，上拉开关和下拉开关均处于断开状态，之后数据流入TLL触发器，数据经过触发器之后，存入到输入数据寄存器中。这时芯片就可以读取这个寄存器的值来读取外部的输入值。注意这里只能读取到高低电平。也就是讲要么是高电平1，要么是低电平0。</p><h4 id="输入上拉"><a href="#输入上拉" class="headerlink" title="输入上拉"></a>输入上拉</h4><p><img src="https://i.loli.net/2021/04/01/n29ZOzQWgtFTyuf.jpg" alt="02输入上拉.jpg"><br>输入上拉与输入浮空大致相似，唯一的区别在于在触发器前部，输入信号的上拉开关在ON位，这就导致将不确定的输入信号嵌在高电平，就是无论输入是高还是低，这个往输入寄存器存储的电平都是高电平。</p><h4 id="输入下拉"><a href="#输入下拉" class="headerlink" title="输入下拉"></a>输入下拉</h4><p><img src="https://i.loli.net/2021/04/01/bUGeyKv2VdpzPNl.jpg" alt="03输入下拉.jpg"><br>和输入上拉相反，输入下拉则是采用将下拉的开关置于ON位，这样就将不确定的输入电压嵌至低电平，就是输入寄存器存储的都是低电平。</p><h4 id="模拟输入"><a href="#模拟输入" class="headerlink" title="模拟输入"></a>模拟输入</h4><p><img src="https://i.loli.net/2021/04/01/slHPEimepNOW6wd.jpg" alt="04模拟输入.jpg"><br>在前面的几种输入模式中，都是采用高低电平进行信号或者逻辑传输的，但是我们使用的外设中，肯定不全是高低电平的变化，肯定有模拟的电压变化。对于模拟的电压变化，STM32有模拟输入的这种功能，在模拟输入下，触发器处于关闭状态，上拉下拉开关也是处于关闭状态。电压通过最上面的模拟输入至芯片。</p><h4 id="开漏输出"><a href="#开漏输出" class="headerlink" title="开漏输出"></a>开漏输出</h4><p><img src="https://i.loli.net/2021/04/01/tYLlh1o97XJRIGB.jpg" alt="05开漏输出.jpg"><br>开漏输出的模式结构图如上图所示。信号首先通过位设置&#x2F;清除寄存器，然后该寄存器控制输出寄存器ODR，ODR输出信号到输出控制部分。在输出控制部分，只有下面的信号线传送信号，然后该信号送到N-MOS管，控制N-MOS管的导通与截止。为什么叫开漏输出呢，其实就是因为在输出端IO口，相当于N-MOS的集电极。如果我们写入一个高电平信号1，那么该信号将N-MOS截止，输出IO的状态就是外部的上拉或者下拉电阻决定。如果我们写入一个低电平信号0，那么该信号将N-MOS导通，输出的IO状态为低电平。最后有一点是IO口的电平状态可以通过输入回路传送至输入寄存器中。</p><h4 id="推挽式输出"><a href="#推挽式输出" class="headerlink" title="推挽式输出"></a>推挽式输出</h4><p><img src="https://i.loli.net/2021/04/01/5wkEsQe7DLxSU1q.jpg" alt="07推挽输出.jpg"><br>和开漏输出不同，推挽输出采用的两个MOS管，输出控制电路是输出两个信号，这两个信号一致。两个MOS管相互配合，一推一拉进行工作。IO的状态都是内部可以控制的。例如：如果我们写入一个高电平，那么输出控制回路的上面信号经过取反后，上面的P-MOS管将导通，下面的N-MOS管将截止，IO口输出高电平。如果写入一个低电平，那么上面的P-MOS将截止，下面的N-MOS将导通，信号输出低电平。这样通过这两个MOS管就可以实现输出输入均可控的状态。</p><h4 id="复用开漏输出"><a href="#复用开漏输出" class="headerlink" title="复用开漏输出"></a>复用开漏输出</h4><p><img src="https://i.loli.net/2021/04/01/jXd3Evko1maZYMx.jpg" alt="06开漏复用输出.jpg"><br>开漏复用输出其实和开漏输出差不多。差别在于输入源不同，后者的信号是复用功能作为输入源。其控制方式和开漏输出一致。</p><h4 id="复用推挽输出"><a href="#复用推挽输出" class="headerlink" title="复用推挽输出"></a>复用推挽输出</h4><p><img src="https://i.loli.net/2021/04/01/XQOAUhSWLNJwaCY.jpg" alt="08复用推挽输出.jpg"><br>复用推挽输出和推挽输出也差不多，差别在于输入源的不同。后者的信号是复用功能作为输入源。其控制方式相同。</p><h3 id="相关寄存器"><a href="#相关寄存器" class="headerlink" title="相关寄存器"></a>相关寄存器</h3><p>配置GPIO的相关寄存器有端口配置低寄存器（GPIOX_CRL)、端口配置高寄存器（GPIOX_CRH）、端口输入数据寄存器（GPIOX_IDR）、端口输出数据寄存器（GPIOX_ODR）、端口位设置&#x2F;清除寄存器（GPIOX_BSRR）、端口位清除寄存器（GPIOX_BRR）、端口配置所存寄存器（GPIOX_LCKR）.需要注意的是不是每个IO口都包含以上的寄存器，是一组IO口包含上面的寄存器。是通过组来算的，不是通过单个来配置的。下面我们来逐个挑选几个重要的寄存器阐述其配置原理。</p><h4 id="端口配置寄存器"><a href="#端口配置寄存器" class="headerlink" title="端口配置寄存器"></a>端口配置寄存器</h4><p>STM32属于32位芯片，所以它的寄存器都是32位的，但是每组IO口数量为16个，每个IO口配置需要4位。那么对于端口配置寄存器就需要64位，所以分为两个寄存器进行配置。低位配置寄存器配置0-7，高位配置寄存器配置8-16。<br><img src="https://i.loli.net/2021/04/01/A1KoZ8LnfiXVTEO.png" alt="20210401151845"><br>具体的配置方法为先配置MODE[1:0]位，主要含义就是配置是输入还是输出，如果对于输出，输出的速度为多少等等。配置完MODE后，CNF[1:0]配置更加具体的模式，比如如果是输入状态，则这个位就配置到底是哪种的输入状态，如果是输出状态，则这个就配置哪种输出状态。 </p><h4 id="端口输入-输出寄存器"><a href="#端口输入-输出寄存器" class="headerlink" title="端口输入&#x2F;输出寄存器"></a>端口输入&#x2F;输出寄存器</h4><p>用于暂时存储输入的状态或者输出状态。输入数据寄存器存储输入的数据，输出数据寄存器存放输出数据。在芯片中，我们可以通过程序进行编程来读取寄存器值。</p><h4 id="AFIO寄存器"><a href="#AFIO寄存器" class="headerlink" title="AFIO寄存器"></a>AFIO寄存器</h4><p>所谓的复用就是将外设的功能比如串口复用到指定的IO口上，这样这个IO口不仅有普通的IO功能，而且还有串口TX RX功能。但是IO口在同一时间只能配置成一种功能，要不普通功能，要么复用功能使用。如果配置复用功能，则需要配置复用寄存器即可。<br>复用功能重映射这个功能大致就是为了PCB的布线方便，如果在一定情况下，其串口复用的IO口有其他作用，而我们还是想使用这个功能，这时就可以采用端口重映射，将IO口映射到其他的IO上。具体哪个IO口可以在数据手册进行查看。</p><h3 id="CubeMX生成HAL程序"><a href="#CubeMX生成HAL程序" class="headerlink" title="CubeMX生成HAL程序"></a>CubeMX生成HAL程序</h3><p>使用CubeMX新建一个工程，将PC13IO口配置成推挽输入，界面如下图所示。在芯片的IO口处右击选择配置的模式。然后在GPIO Mode and Configuration中进行详细模式的配置，选择Output Push Pull。设置相应的速度。最后生成相关工程代码。其他的IO口配置也是类似的。<br><img src="https://i.loli.net/2021/04/01/OSQEocdyNiLxwvF.png" alt="20210401154342"></p><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MX_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="comment">/* GPIO Ports Clock Enable */</span></span><br><span class="line">  __HAL_RCC_GPIOC_CLK_ENABLE();</span><br><span class="line">  __HAL_RCC_GPIOD_CLK_ENABLE();</span><br><span class="line">  <span class="comment">/*Configure GPIO pin Output Level */</span></span><br><span class="line">  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*Configure GPIO pin : PC13 */</span></span><br><span class="line">  GPIO_InitStruct.Pin = GPIO_PIN_13;      <span class="comment">//选择IO口</span></span><br><span class="line">  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;</span><br><span class="line">  GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;</span><br><span class="line">  HAL_GPIO_Init(GPIOC, &amp;GPIO_InitStruct);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是GPIO初始化的代码，其实大致的思路就是创建一个结构体，通过结构体赋值的形式将值传入到相关的寄存器中，这里有个子函数HAL_GPIO_Init这个函数的相关信息如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">for</span> (position = <span class="number">0U</span>; position &lt; GPIO_NUMBER; position++)   <span class="comment">//查找IO口对应的位置</span></span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">/*通过case语句将相关的位赋值给config这个变量  这里是 0x00000002 也就是0x0000000|0010|</span></span><br><span class="line"><span class="comment">0x2U，对应也就是0x0010.写到相应的寄存器中，MODE对应10：输出模式最大速度2MHZ，00对应</span></span><br><span class="line"><span class="comment">CNFy对应模式为推挽输出*/</span></span><br><span class="line">config = GPIO_Init-&gt;Speed + GPIO_CR_CNF_GP_OUTPUT_PP;    </span><br><span class="line"><span class="comment">//针对IO口的位置选择是低位配置寄存器还是高位配置寄存器，并计算出位移量</span></span><br><span class="line">configregister = (iocurrent &lt; GPIO_PIN_8) ? &amp;GPIOx-&gt;CRL     : &amp;GPIOx-&gt;CRH;</span><br><span class="line">registeroffset = (iocurrent &lt; GPIO_PIN_8) ? (position &lt;&lt; <span class="number">2U</span>) : ((position - <span class="number">8U</span>) &lt;&lt; <span class="number">2U</span>);</span><br><span class="line"><span class="comment">//将config的值进行位移运算后，写入到相应的配置寄存器</span></span><br><span class="line">MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) &lt;&lt; registeroffset ), (config &lt;&lt; registeroffset));</span><br></pre></td></tr></table></figure><p>初始化的这些代码都是CubeMX帮助我们去做的，要实现功能，直接在while循环当中编辑相应的逻辑即可。下面编写的逻辑可以实现LED灯0.5ms翻转。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">HAL_Delay(<span class="number">500</span>);</span><br><span class="line">HAL_GPIO_WritePin(GPIOC,GPIO_PIN_13,GPIO_PIN_RESET);  <span class="comment">//低电平</span></span><br><span class="line">HAL_Delay(<span class="number">500</span>);</span><br><span class="line">HAL_GPIO_WritePin(GPIOC,GPIO_PIN_13,GPIO_PIN_SET);    <span class="comment">//高电平</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 裸机开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32&amp;HAL笔记01：芯片时钟</title>
      <link href="/2023/11/16/%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91%EF%BC%9ASTM32&amp;HAL%E7%AC%94%E8%AE%B001%EF%BC%88%E6%97%B6%E9%92%9F%EF%BC%89/"/>
      <url>/2023/11/16/%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91%EF%BC%9ASTM32&amp;HAL%E7%AC%94%E8%AE%B001%EF%BC%88%E6%97%B6%E9%92%9F%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>时钟就好比单片机的心脏，是器件的关键部分。所以要理解并掌握stm32的时钟。这篇文章将重点讲时钟介绍、以及时钟配置和寄存器的关系，最后使用HAL库配置时钟。</p><span id="more"></span><h3 id="时钟树概要"><a href="#时钟树概要" class="headerlink" title="时钟树概要"></a>时钟树概要</h3><p><img src="https://i.loli.net/2021/03/29/ChV9kZoGNWxLIH6.gif" alt="时钟树概要.gif"><br>STM32属于高性能处理器，常常这种处理器选择采用多时钟源的输入方案。如上图所示，STM32一共有4个时钟源，分别是时钟源01：HSI（高速内部时钟）、时钟源02：HSE（高速外部时钟）、时钟源03：LSE（低速外部时钟）、时钟源04：LSI（低速内部时钟）。初次之外还有一个PLL时钟，PLL时钟选择HSE或者HSI时钟源作为输入，通过配置后，输入到系统时钟。通过相应的寄存器进行时钟的选择和配置。配置好的时钟源通过相应的总线输出到相应的外设当中。</p><h5 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h5><p>时钟树的配置主要在时钟配置寄存器（RCC_CFGR）中实现。寄存器为32位寄存器，包含了MCO、USBPRE、PLLMUL、PLLXTPRE、PLLSRC、ADCPRE、PPPRE2、PPPRE1、HPRE、SWS、SW的配置。如下图所示<br><img src="https://i.loli.net/2021/03/29/4ATebghsyDEvJKx.png" alt="20210329145835"><br>MCO主要配置输出时钟源的选择，USBPRE主要配置USB时钟是1.5分频还是不分频，PLLMUL主要配置PLL进行多少倍频，PLLXTPRE、PLLSRC配置HSE或者HSI输出是2分配还是不分频，ADCPRE配置ADC的分频，PPPRE2配置高速APB预分频，PPPRE1配置低速APB分频，HPRE配置AHB预分频，SWS、SW配置输入时钟源的选择。</p><h3 id="HSE时钟源"><a href="#HSE时钟源" class="headerlink" title="HSE时钟源"></a>HSE时钟源</h3><p><img src="https://i.loli.net/2021/03/29/n2KaW9rxJf4UQEp.png" alt="时钟树HSE.png"><br>HSE时钟称为高速外部时钟，该时钟也成为晶振，采用外部的晶振为芯片提供精确稳定的时钟输入。常常选用8M的时钟作为芯片外部输入时钟，注意在PCB布线过程中。应尽量让晶振距离芯片近一些，并且IN和OUT应该对称分配，同时选择合适的电容，一般为22p。从时钟树中可以看出，HSE时钟一共有4路输出，分别为</p><ul><li>第一路：作为PLL的时钟，这时PLLSRC应该配置选择HSE，同时可以配置PLLXTPRE选择要不要分频，需要对R4 R1 R2 R3 配置。</li><li>第二路：作为HSE时钟，也就是不分频作为时钟的输入，需要对R3配置</li><li>第三路：输入值CSS时钟安全系统中，CSS检测HSE的状态，当HSE故障时，及时充当备份时钟并且产生中断，需要对CSS配置。</li><li>第四路：通过128分频为RTC供作时钟源，需要通过RTCSEL进行配置，需要对R5进行配置。</li></ul><h3 id="HSI时钟源"><a href="#HSI时钟源" class="headerlink" title="HSI时钟源"></a>HSI时钟源</h3><p><img src="https://i.loli.net/2021/03/29/QZ1LjeUXhBkspHf.png" alt="时钟树HSI.png"><br>HSI时钟被称为高速内部RC时钟，通过RC振荡器产生时钟源，大小为8MHz,这种HSI时钟具有响应速度块，但是经度和稳定性不如HSE的外部晶振。所以，一般情况下，在外部晶振良好的情况下，优先使用HSE,但是如果HSE有问题或者没有外部晶振，这时芯片也可以使用HSI。HSI时钟一共有2路输出，分别为</p><ul><li>第一路：作为PLL的时钟输入，这种情况HSI将时钟进行2分频,经过倍频后可以作为系统时钟，需要对R1 R2 R3进行配置。</li><li>第二路：直接做系统时钟，这时系统时钟将为固定的8MHZ，需要对R3进行配置。</li></ul><h3 id="LSE时钟源"><a href="#LSE时钟源" class="headerlink" title="LSE时钟源"></a>LSE时钟源</h3><p><img src="https://i.loli.net/2021/03/29/Kps359RStcWEuOz.png" alt="时钟树LSE.png"><br>低速外部时钟源常常采用的大小为32.768K的晶振作为时钟源，并且布线规则和高速外部时钟一样，尽可能线对称分布，选择合适的电容，一般为15p。低速外部时钟主要用来为RTC提供精确的时钟源，如果在程序中中使用RTC提供时间功能，那么LSE是优先推荐的时钟源，需要配置R5来完成。</p><h3 id="LSI时钟源"><a href="#LSI时钟源" class="headerlink" title="LSI时钟源"></a>LSI时钟源</h3><p><img src="https://i.loli.net/2021/03/29/x2LFpP97VwTA5ja.png" alt="时钟树LSI.png"><br>LSI输入低速内部时钟，和HSI类似，是在芯片内部的RC时钟，其时钟频率为40Khz。这个时钟精度不高，但是响应速度块。其输出主要有2路，分别为：</p><ul><li>第一路：为RTC提供时钟，需要对R5进行配置，如果芯片外部没有LSE，则RTC可以选择LSI作为时钟，但是缺点是不够精准和稳定。</li><li>第二路：为看门狗提供时钟（看门狗还没怎么理解，先知道这个）</li></ul><h3 id="时钟的User"><a href="#时钟的User" class="headerlink" title="时钟的User"></a>时钟的User</h3><p><img src="https://i.loli.net/2021/03/29/WPKQL9lDiSsE5pm.png" alt="时钟树USER.png"><br>时钟树的用户主要分为ABC三大类吧，其中A类为USB；B类为一些常用的外设，包含APB1下面挂载的外设和APB2下面挂载的外设以及DMA等；第三类为RTC和看门狗。如果要使用一种外设，必须开启它的时钟配置。否则该外设将无法正常使用。</p><h3 id="HAL库时钟配置"><a href="#HAL库时钟配置" class="headerlink" title="HAL库时钟配置"></a>HAL库时钟配置</h3><p>CubeMX为32提供了可视化的时钟配置，可以非常简单地配置相应的时钟。如下图所示，可用通过图形化配置HSE时钟作为时钟源，CubeMX可以直接输出相应的工程代码，直接编辑逻辑即可。<br><img src="https://i.loli.net/2021/03/29/N4yaFB7Qn69ACtP.png" alt="20210329161109"><br>通过这个软件可以直接配置相应的寄存器，在代码中提下如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;  <span class="comment">//选择HSE</span></span><br><span class="line">RCC_OscInitStruct.HSEState = RCC_HSE_ON;</span><br><span class="line">RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;     <span class="comment">//HSE不分频</span></span><br><span class="line">RCC_OscInitStruct.HSIState = RCC_HSI_ON; </span><br><span class="line">RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;      <span class="comment">//PLL作为系统时钟</span></span><br><span class="line">RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;     </span><br><span class="line">RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;     <span class="comment">//PLL将HSE进行9倍频</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 裸机开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32&amp;HAL笔记00：STM32及HAL库介绍</title>
      <link href="/2023/11/16/%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91%EF%BC%9ASTM32&amp;HAL%E7%AC%94%E8%AE%B000/"/>
      <url>/2023/11/16/%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91%EF%BC%9ASTM32&amp;HAL%E7%AC%94%E8%AE%B000/</url>
      
        <content type="html"><![CDATA[<p>一直想着有机会从头开始学习下STM32这款单片机，前端时间对CubeMX和HAL库的操作很好奇，因为之前做项目都是直接用正点原子的例程，所以这次我打算利用学习CubeMX和HAL库的这个机会，从新系统的学习下STM32，重点学习其相关外设的原理，并使用HAL库来实战。目前我将安排两类文章，一类属于笔记部分，主要介绍相关理论知识，另外一类属于实战部分，介绍操作方法，根据该操作方法可以将内容复现。那我们就先大致了解下STM32以及HAL库吧~</p><span id="more"></span><h3 id="STM32"><a href="#STM32" class="headerlink" title="STM32"></a>STM32</h3><h4 id="STM32功能概述"><a href="#STM32功能概述" class="headerlink" title="STM32功能概述"></a>STM32功能概述</h4><p>整个学习准备采用最基础的STM32F103系列的单片机，先来大致看一下这款单片机的功能。</p><ul><li>芯片属于ARM架构32位的处理芯片，时钟频率为72MHz</li><li>存储器为32K字节至128K字节闪存程序存储器</li><li>I&#x2F;O引脚电压3.3V，内嵌4至16Mhz高速晶体振荡器</li><li>芯片有三种省电模式，分别为睡眠、停机和待机模式，VBAT引脚为RTC和后备寄存器供电</li><li>拥有2个12位的数模转换器，转换电压0-3.6V</li><li>可以采用SWD和JTAG接口进行调试，但是一般优先选择SWD</li><li>7通道的DMA控制器，支持的外设有定时器、ADC、SPI、I2C、和USART</li><li>多达32个快速I&#x2F;O口，所有的I&#x2F;O口均可以映射到16个外部中断</li><li>有7个定时器，3个同步的16位定时器，每个定时器有4个输入捕获&#x2F;输出比较&#x2F;PWM或脉冲计数通道</li><li>通信接口包含2个I2C、3个USART、2个SPI同步串行接口、CAN接口、USB2.0全速接口<br>单片机包含5种封装类型，在整个学习过程中，我们采用的是LQFP48这种封装类型，如下图所示，列出了这几种封装类型<br><img src="https://i.loli.net/2021/03/24/VPQNI7rjndJipax.png" alt="20210324204843.png"></li></ul><h4 id="嵌套的向量式中断控制器（NVIC"><a href="#嵌套的向量式中断控制器（NVIC" class="headerlink" title="嵌套的向量式中断控制器（NVIC)"></a>嵌套的向量式中断控制器（NVIC)</h4><p>芯片内置嵌套的向量式中断控制器，能够处理43个可屏蔽中断通道和6个优先级</p><h4 id="外部中断-事件控制器（EXIT）"><a href="#外部中断-事件控制器（EXIT）" class="headerlink" title="外部中断&#x2F;事件控制器（EXIT）"></a>外部中断&#x2F;事件控制器（EXIT）</h4><p>外部中断&#x2F;事件控制器包含19个边沿检测器，连接16个外部中中断线，用于产生中断&#x2F;事件请求。每个中断线都可以单独配置，并且可以单独屏蔽，有一个挂起寄存器维持所有中断请求的状态。</p><h4 id="时钟和启动"><a href="#时钟和启动" class="headerlink" title="时钟和启动"></a>时钟和启动</h4><p>首先系统时钟的选择是在启动时完成的，8MHz的RC振荡器被选择为默认时钟，然后可以选择外部的时钟，如果外部的时钟无效，则会产生相应的中断，最后使用多个预分频器配置时钟</p><h4 id="供电监视器"><a href="#供电监视器" class="headerlink" title="供电监视器"></a>供电监视器</h4><p>芯片内部有一个上电复位&#x2F;掉电复位的电路，该电路一直处于工作状态，作用在于当供电电压低于2V时，不必使用外部的复位电路就可以复位。器件中还有一个可编程的电压检测器，作用是检测VDD的电压，当电压低于VPVD时，产生一个中断，这个中断可以使芯片进入安全模式，注意需要通过程序开启此功能</p><h4 id="低功耗模式"><a href="#低功耗模式" class="headerlink" title="低功耗模式"></a>低功耗模式</h4><p>器件包含三种低功耗模式，分别是睡眠模式、停机模式、待机模式</p><ul><li>睡眠模式：只有CPU停止工作，其他外设均处于工作状态，中断可以唤醒CPU</li><li>停机模式：所有1.8V内部功能停止工作，PLL HSI HSE RC振荡器将会关闭，但是SRAM和寄存器的内容不会丢失。EXIT的信号会唤醒该模式</li><li>待机模式：在停机模式的基础上，SRAM和寄存器的内容会发生丢失，但是后备寄存器的内容还有，并且待机电路还在工作状态。可以采用NSRST、IWDG或者RTC闹钟唤醒。</li></ul><h4 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h4><p>首先DMA可以实现存储器到存储器、设备到存储器、存储器到设置之间的数据传输，一共有7个通道。然后每个通道有专门的硬件DMA请求逻辑，同时可以用软件对长度、传输源和目标地址进行单独设置，最后DMA可以用于SPI I2C USART 定时器和ADC等外设中。</p><h4 id="RTC和后备寄存器"><a href="#RTC和后备寄存器" class="headerlink" title="RTC和后备寄存器"></a>RTC和后备寄存器</h4><p>RTC和后备寄存器供电既可以选择VDD供电也可以选择VABT引脚供电，由一个开关控制。后备寄存器是10个16位的寄存器，可以用来在VDD没电时保存数据。实时时钟具有一组连续运行的计数器，可以为系统提供日历、闹钟功能，在时钟选择方面，可以选择使用外部晶体的32.768kHz振荡器，也可以使用内部RC振荡器，或者还可以使用高速外部时钟。一般考虑到精度问题等，优先选择用外部晶体的32.768kHz振荡器。</p><h4 id="独立看门狗"><a href="#独立看门狗" class="headerlink" title="独立看门狗"></a>独立看门狗</h4><p>首先看门狗的时钟是独立的32kHz内部RC振荡器，该振荡器独立于主时钟，因此可以工作在低功耗模式中。在系统发生问题时，可以复位整个系统，或者作为一个自由定时器为应用程序提供超时管理。最后可以通过选择字节配置成软件看门狗或者硬件看门狗。</p><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>定时器分为高级定时器TIM1和通用定时器TIM2-4，其中高级定时器就是一个分配到6通道的三相PWM发生器，也可以当作普通定时器使用。每个通用定时器都包含一个16位的自动加载递增&#x2F;递减计数器、一个16位的预分频器、和4个独立通道，4个独立通道都可以用于输入捕获、输出比较、PWM和单脉冲输出。还可以通过定时器连接功能与高级定时器协同工作。</p><h4 id="I2C总线"><a href="#I2C总线" class="headerlink" title="I2C总线"></a>I2C总线</h4><p>器件有2个I2C总线接口，能够工作与多主和从模式，支持标准和快速模式</p><h4 id="通用同步-异步接收发送器（USART）"><a href="#通用同步-异步接收发送器（USART）" class="headerlink" title="通用同步&#x2F;异步接收发送器（USART）"></a>通用同步&#x2F;异步接收发送器（USART）</h4><p>器件包含3个串口，其中一个串口通信速率可以达到4.5兆&#x2F;秒。接口具有硬件的CTS和RTS信号管理</p><h4 id="SPI串行外设接口"><a href="#SPI串行外设接口" class="headerlink" title="SPI串行外设接口"></a>SPI串行外设接口</h4><p>包含2个SPI通讯接口，在从或者主模式下，全双工和半双工的通信速率可以达到18兆位&#x2F;秒。3位的预分频器可产生8种主模式频率。</p><h4 id="控制器区域网络（CAN）"><a href="#控制器区域网络（CAN）" class="headerlink" title="控制器区域网络（CAN）"></a>控制器区域网络（CAN）</h4><p>CAN接口不仅可以接收和发送11位标识符的标准帧，也可以处理29位标识符的扩展帧，含有2个接收FIFOs,3级14个可调节的滤波器。</p><h4 id="通用串行总线（USB）"><a href="#通用串行总线（USB）" class="headerlink" title="通用串行总线（USB）"></a>通用串行总线（USB）</h4><p>器件内嵌一个usb设备，遵循全速标准，具有可软件配置的端点和待机&#x2F;恢复功能。专门的48MHZ时钟由PLL直接产生</p><h4 id="通用输入输出接口（GPIO"><a href="#通用输入输出接口（GPIO" class="headerlink" title="通用输入输出接口（GPIO)"></a>通用输入输出接口（GPIO)</h4><p>每个IO口都可以配置成输出（推拉、开路）、输入（带或者不带上拉或者上拉）或者其他外设的功能，与数字模拟的外设功能关键共用，并且所有引脚都是大电流通过的能力。</p><h4 id="ADC（模拟-数字转换器）"><a href="#ADC（模拟-数字转换器）" class="headerlink" title="ADC（模拟&#x2F;数字转换器）"></a>ADC（模拟&#x2F;数字转换器）</h4><p>器件内嵌2个12位的数字&#x2F;模拟转换器，每个ADC有16个外部通道，可以执行单次扫描或者扫描转换模式。<br>对上述功能做简单介绍后，可以根据下面的方框原理图大致了解该器件内部的组成结构。<br><img src="https://i.loli.net/2021/03/25/bTYGRpPW941SxCU.png" alt="20210325104541"></p><h3 id="HAL库"><a href="#HAL库" class="headerlink" title="HAL库"></a>HAL库</h3><p>C语言对程序的编程其实就是对寄存器的操作，但是随着32系类芯片的寄存器越来越多，这时很多人已经记不住每个寄存器的名称等，这时意法半导体非常友好地为编程人员提供了一套操作寄存器的API接口，这套东西就成为HAL库。有了HAL库，我们就不用去记每个寄存器的地址和操作方法，只需要根据HAL库函数操作即可。<br>CubeMX是意法半导体为编程人员提供的一款开发软件，使用该软件可以进行图形化编程，其实在开发过程中，最耗费精力的就是IO口的配置，然后CubeMX这款软件目的在于简化IO口的操作，说白了就是配置IO，然后自动生成代码的工具，生成后的代码我们不需要关注IO口的配置，只需要进行程序的逻辑处理即可，使用起来非常的方便。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章主要对32的功能进行了简单的介绍，比如包含几个定时器等等，以及对HAL库的介绍，后续将根据实战和理论相结合的方式一一探讨这些功能。</p>]]></content>
      
      
      <categories>
          
          <category> 裸机开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RTOS（RT-Thread)学习笔记01：野火教程读后感</title>
      <link href="/2023/11/16/RTOS%EF%BC%9ARTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AC%AC%E4%B8%80%E6%9C%9F%EF%BC%89/"/>
      <url>/2023/11/16/RTOS%EF%BC%9ARTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AC%AC%E4%B8%80%E6%9C%9F%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>好久没有更新博客了，满打满算得有两个月得时间了。但是这段时间也没有闲着。一方面在完成老师下达得项目任务，另外一方面准备这学期的期末考试。时间过得真快，研一的时光一转而过，记得昨天刚刚提着行李箱报道，今天都已经上完研一所有课程了。后面的时间大部分都在实验室度过，是非常集中的时间，因此我就可以充分安排我的计划，暂定一周写一篇关于目前所学到的知识总结。这篇文章就是我在阅读野火出版的《RT-Threa内核实现与应用开发实战指针》后的一些对RTOS的认识。</p><span id="more"></span><h3 id="RT-Thread整体理解"><a href="#RT-Thread整体理解" class="headerlink" title="RT-Thread整体理解"></a>RT-Thread整体理解</h3><p>这本书分为两个大的部分，一部分是讲述RT-Thread内核的实现，另外一部分是讲述应用开发的实现，例如信号量、消息队列、内存管理等等。两部分的内容我建议按照书上的程序，如果不是特别复杂，自己有时间的话敲一遍，这样印象更加深刻一些。阅读完这本书之后，其实最大的感触就是不要把操作系统想的那么复杂，它的实现也没有那么的难，简单来说就是利用中断去控制几个while()循环，但是在while循环中需要加上阻塞，所谓的阻塞就是当程序执行到这里时，让出CPU的使用权，让别的循环去利用。其核心在于调度器的实现以及对线程的操作。<br>在完成调度之后呢，线程中的程序肯定会使用一些变量或者数据什么的，那么如何实现这些呢，就是后面讲述的消息队列，如何实现不同的线程操作同一个资源时，不会被其他线程打扰呢，这就是需要信号量，有二值信号量也有整形的信号量。还有事件的内容，大致也是用于这部分的操作。<br>当然肯定还有定时或者中断这些基础的内容，中断和裸机系统差不多，定时器呢是一种软件定时器，实现也是根据滴答定时器的中断去检测定时时间是否到达，对了对于操作系统的实现过程中，无论信号量、还是事件以及软件定时器，都用到了控制块的概念。它们的控制块和线程的控制块概念相同。由于这本书使用的是Nano版本的内核，所以不包含文件系统那些东西。</p><h4 id="多线程操作系统"><a href="#多线程操作系统" class="headerlink" title="多线程操作系统"></a>多线程操作系统</h4><p>裸机系统与多线程系统，对于这个，我的理解如下。裸机系统就是我们传统的之前一直写的程序，可以使用CubMX生成，其特点在于整个系统的程序都运行在一个while循环中，如果你想并行运行一些代码，只能利用定时器中断（比如在中断中判断标志位等等）来辅助实现。程序的结构比较简单，先是各种硬件软件的初始化，然后就是一个while循环包含所有。<strong>多线程的操作系统</strong>则具有并行处理的功能，它可以实现多个while循环，我们可以在多个while循环中放置不同的任务程序，让其任务并行处理。它的一个最大的特点就是CPU的使用效率高、实时性好。</p><h3 id="RT-Thread线程"><a href="#RT-Thread线程" class="headerlink" title="RT-Thread线程"></a>RT-Thread线程</h3><h4 id="线程函数"><a href="#线程函数" class="headerlink" title="线程函数"></a>线程函数</h4><p>在多线程操作系统中，根据功能的不同，把整个系统分割成一个个独立的且无法返回的函数，这个函数则称为<strong>线程</strong>，线程的一般程序结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">thread_entry</span><span class="params">(<span class="type">void</span> *parg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 用户代码 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了实现多个线程同时工作的应用，我们在单单创建完线程函数之后是不可能实现多个线程的同时运行的。怎么实现多个线程同时运作的，这就需要我们的系统调度，系统调度其实就相当于管家一样。去按照一定的顺序和规则去安排每一个线程去利用CPU的资源。这也是多线程同时运行的本质。<br>再去思考一个问题，系统调度怎么实现先不用具体的考虑，先思考下我们创建的线程如何进行标记，那么这个时候就用到了线程控制块。</p><h4 id="线程控制块"><a href="#线程控制块" class="headerlink" title="线程控制块"></a>线程控制块</h4><p>它相当于线程的身份证，用于存储线程的栈指针、线程名称、优先级等相关的参数，必须要指导每一个线程在创建时，都需要对其进行线程控制块定义。其线程控制块的一般定义如下（rtdef.h中有相关定义)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span>       *sp;                                     <span class="comment">/**&lt; 线程栈指针 */</span></span><br><span class="line">    <span class="type">void</span>       *entry;                                  <span class="comment">/**&lt; 线程入口地址  */</span></span><br><span class="line">    <span class="type">void</span>       *parameter;                              <span class="comment">/**&lt; 线程形参 */</span></span><br><span class="line">    <span class="type">void</span>       *stack_addr;                             <span class="comment">/**&lt; 线程栈起始地址 */</span></span><br><span class="line">    <span class="type">rt_uint32_t</span> stack_size;                             <span class="comment">/**&lt; 线程栈大小 */</span></span><br><span class="line">    .......                                             <span class="comment">/**&lt; 其他与线程有关的参数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h4><p>线程创建有线程创建的函数rt_thread_init(),该函数用于创建一个线程，在线程创建之初，需要首先在程序中声明线程控制块以及线程的入口函数，创建的代码示例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rt_thread_create( <span class="string">&quot;threadName&quot;</span>,                 <span class="comment">/* 线程名字 */</span></span><br><span class="line">                     thread_entry,   <span class="comment">/* 线程入口函数 */</span></span><br><span class="line">                     RT_NULL,             <span class="comment">/* 线程入口函数参数 */</span></span><br><span class="line">                     <span class="number">512</span>,                 <span class="comment">/* 线程栈大小 */</span></span><br><span class="line">                     <span class="number">3</span>,                   <span class="comment">/* 线程的优先级 */</span></span><br><span class="line">                     <span class="number">20</span>);                 <span class="comment">/* 线程时间片 */</span>                  </span><br><span class="line">   <span class="comment">/* 启动线程，开启调度 */</span></span><br><span class="line">  <span class="keyword">if</span> (led1_thread != RT_NULL)</span><br><span class="line">       rt_thread_startup(led1_thread);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>该创建的为使用动态内存，意思就是线程的栈的空间在创建时只需要声明这个空间的大小即可，对于空间的起始地址和末尾地址不用声明；程序会根据这个空间的大小去动态分配地址。对于动态内存和静态内存各有优缺点，其中动态内存的优点在于可以对内存进行充分利用，静态内存的优点在于效率比较高，根据实际的情况去考虑使用吧。对于多线程的创建和单线程一样，需要注意一点的就是要合适的分配线程的时间片和优先级以及栈空间的大小。</p><h5 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h5><p>对于线程的优先级还是比较好理解的，因为rt-thread属于RTOS实时操作系统，每个线程之间的调度根据线程的优先级进行抢占资源。在低优先级的程序在执行中时，如果这时有一个高优先级的程序需要执行，那么这时系统就调度到高的优先级，把低的优先级进行挂起。数值越小，代表的优先级越高，对于优先级的实现，会分专门的一篇进行讨论。</p><h5 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h5><p>对于时间片的理解在于，时间片就是相同优先级下，不同程序占用CPU的时间，单位为Tick,具体的实现后面会有一篇专门讨论。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇中，主要阐述了对于RTOS的理解，通过野火的这本书籍，对于实时操作系统的运行、调度、内核部分、应用部分有了一个简单的理解。然后对于线程这部分做了一些解释说明，介绍线程的创建以及与线程创建相关的名词。后面将继续以这种博客的形式，输出我对RTOS的一些理解。</p>]]></content>
      
      
      <categories>
          
          <category> RTOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RT-Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prepar3D开发总结02：仪表与按键</title>
      <link href="/2023/11/16/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5%EF%BC%9APrepar3D%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%9302/"/>
      <url>/2023/11/16/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5%EF%BC%9APrepar3D%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%9302/</url>
      
        <content type="html"><![CDATA[<p>上一期的博客总结中，<a href="https://jiaone.gitee.io/2021/09/10/Prepar3D%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%9301/">Prepar3D开发总结01：模型与SDK</a>详细介绍了Prepar3D二次开发的过程、以及开发过程中两个重要的配置文件。在先前的基础之上，我们一起来总结下在二次开发过程中，仪表与按键的开发流程。</p><span id="more"></span><h3 id="项目工程"><a href="#项目工程" class="headerlink" title="项目工程"></a>项目工程</h3><h4 id="模板目录"><a href="#模板目录" class="headerlink" title="模板目录"></a>模板目录</h4><p>整个的二次开发工程，可以选用C++或者C#作为开发语言。在此我选择了C++作为整个项目的开发语言。打开模板项目工程，首先是工程的目录文件结构，如下图所示：<br><img src="https://i.loli.net/2021/09/16/GjO2UhEvmq1XYsL.png" alt="image.png"><br>整个CGaugeSample工程一共包括五大项，分别为引用、外部依赖项、Header Files、Resource Files、Source Files文件夹。对其中比较关键的四项做详细说明</p><ul><li>外部依赖项：主要是程序运行所依赖Windows的一些.h文件</li><li>Header Files：包含了程序中自己编写实现的.h和.cpp文件。因为.cpp文件在主文件中采用#include的形式包含进来，所以文件被放在了Header Files目录中。</li><li>Resource Files：资源文件包含程序中所有的贴图，例如仪表中的背景图，指针的样式等等，注意这些图片的文件的格式是BMP格式，后面还有详细的介绍如何向工程中添加自己的资源图片</li><li>Source Files：相当于整个项目的工程主文件，在此文件中，定义了要实现的仪表或者按键，同时将对应的程序文件也包含在内。</li></ul><h4 id="资源文件介绍"><a href="#资源文件介绍" class="headerlink" title="资源文件介绍"></a>资源文件介绍</h4><p>Resource Files中包含一个.RC的文件，这个文件中存放着项目所需的一些图片或者其他资源。可以选中该文件，右击查看代码，查看该文件对应的代码，从代码中，可以看到以下的内容：<br><strong>版本定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">    BLOCK <span class="string">&quot;StringFileInfo&quot;</span></span><br><span class="line">    BEGIN</span><br><span class="line">        BLOCK <span class="string">&quot;040904b0&quot;</span></span><br><span class="line">        BEGIN</span><br><span class="line">            VALUE <span class="string">&quot;CompanyName&quot;</span>, <span class="string">&quot;Your Company\0&quot;</span></span><br><span class="line">            VALUE <span class="string">&quot;FileDescription&quot;</span>, <span class="string">&quot;Prepar3D Gauge\0&quot;</span></span><br><span class="line">            VALUE <span class="string">&quot;FileVersion&quot;</span>, VERSION_STRING</span><br><span class="line">            VALUE <span class="string">&quot;LegalCopyright&quot;</span>, <span class="string">&quot;Your Copyright.\0&quot;</span></span><br><span class="line">            VALUE <span class="string">&quot;ProductName&quot;</span>, <span class="string">&quot;Your Product\0&quot;</span></span><br><span class="line">            VALUE <span class="string">&quot;ProductVersion&quot;</span>, VERSION_STRING</span><br><span class="line">        END</span><br><span class="line">    END</span><br><span class="line">    BLOCK <span class="string">&quot;VarFileInfo&quot;</span></span><br><span class="line">    BEGIN</span><br><span class="line">        VALUE <span class="string">&quot;Translation&quot;</span>, <span class="number">0x409</span>, <span class="number">1200</span></span><br><span class="line">    END</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>该处的代码就是定义输出的dll文件的属性，在程序中修改Value后面的字符串即可，在DLL文件中，相关的属性中，就可以查看到以上程序的定义。<br><img src="https://i.loli.net/2021/09/16/9o3WS5PId14f8xz.png" alt="image.png"><br><strong>资源定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BMP_FUEL_SELECTOR_OFFBITMAPDISCARDABLE<span class="string">&quot;res\\Fuel_Selector.Off.BMP&quot;</span></span><br><span class="line">BMP_FUEL_SELECTOR_LEFTBITMAPDISCARDABLE<span class="string">&quot;res\\Fuel_Selector.Left.BMP&quot;</span></span><br></pre></td></tr></table></figure><p>上面的代码含义为BMP_FUEL_SELECTOR_OFF代表该图片在程序中的名称，中间BITMAPDISCARDABLE是对该名称的描述，最后是资源文件的路径。上述代码的含义就是将文件目录res下的Fuel_Selector.Off.BMP文件定义为BMP_FUEL_SELECTOR_OFF名称。其他都是重复的代码。如果我们想向项目中添加资源，实现的代码也是上面所示。在上面添加相应的代码后，点击CGaugeSample.rc文件就可以看到刚才添加的资源。如果对应的资源名称没有在CGaugeSample.h文件中定义，会显示双引号，这时我们只需要在CGaugeSample.h文件中对名称进行定义即可。即</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>BMP_FUEL_SELECTOR_OFF0x2100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>BMP_FUEL_SELECTOR_LEFT0x2101</span></span><br></pre></td></tr></table></figure><p>注意后面的十六进制表示不可重复，其实也就是文件存放在内存中的地址。对于稍微大的文件，中间要有一定的间隔。</p><h3 id="仪表实现"><a href="#仪表实现" class="headerlink" title="仪表实现"></a>仪表实现</h3><p>以燃油仪表为例，首先需要在CGaugeSample.cpp中对仪表进行定义，实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>     GAUGE_NAME          <span class="string">&quot;Fuel&quot;</span>         <span class="comment">//panel.cfg中添加仪表的名字要于之对应</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     GAUGEHDR_VAR_NAME   gaugehdr_fuel  <span class="comment">// GAUGE_TABLE_ENTRY会用到此变量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     GAUGE_W             100            <span class="comment">//默认</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CGaugeSample.Fuel.hpp&quot;</span>               <span class="comment">//仪表的代码文件</span></span></span><br><span class="line"><span class="comment">//上述代码定义好仪表之后，还需要在文件最后添加定义的仪表</span></span><br><span class="line"><span class="built_in">GAUGE_TABLE_ENTRY</span>(&amp;gaugehdr_fuel)</span><br></pre></td></tr></table></figure><p>如果该仪表有处理的逻辑变量也需要在CGaugeSample.cpp文件中定义。下面看下CGaugeSample.Fuel.hpp文件中针对仪表是如何实现的。在该文件中，先是根据定义的变量去声明这个仪表，然后用MAKE_NEEDLE去定义仪表的指针，用MAKE_STATIC定义仪表的背景，最后编写相应的回调函数。<br>注意在该文件中，MAKE_NEEDLE是核心，下面对该宏做详细说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制一个可以绕另外一个图像特定点旋转的图像</span></span><br><span class="line"><span class="built_in">MAKE_NEEDLE</span></span><br><span class="line">(</span><br><span class="line">fuel_needle, <span class="comment">//NAME</span></span><br><span class="line">BMP_FUEL_SMALL_NEEDLE, <span class="comment">// RES_ID  the name of resource file</span></span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">// NEXT_LIST </span></span><br><span class="line">fuel_fail, <span class="comment">// FAILURE   Probably failure defination</span></span><br><span class="line">IMAGE_USE_TRANSPARENCY|IMAGE_USE_ERASE|IMAGE_BILINEAR_COLOR,     <span class="comment">//DRAW_FLAGS</span></span><br><span class="line"><span class="number">0</span>, <span class="comment">//Aircraft Special Instrument   only with autopilot</span></span><br><span class="line"><span class="number">150</span>, <span class="number">150</span>, <span class="comment">// the position of rotate point</span></span><br><span class="line"><span class="number">6</span>, <span class="number">12</span>, <span class="comment">// NDL_POSITION</span></span><br><span class="line">TOTAL_FUEL_QUANTITY_GALLONS,fuel_needle_cb,     </span><br><span class="line">     <span class="comment">// SOURECE_VAR:Token Variable used to drive the needle  CALLBACK: fuel_needle_cb</span></span><br><span class="line">fuel_nonlinearity,               <span class="comment">// name of the non-linearity table </span></span><br><span class="line"><span class="number">6</span> <span class="comment">//MAX_DEG_PER_SEC</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>MAKE_NEEDLE可以实现让一个图层绕着一个点实现旋转，这也就实现了仪表指针的动画。在定义中，150, 150为围定点选装的坐标，注意这个坐标是相对于背景图片来讲的。图层实现旋转可以还需要数据的驱动，这个数据就是TOTAL_FUEL_QUANTITY_GALLONS，该变量在GaugeDefiners.h文件中定义，代表飞机的燃油总重。如果要实现其他仪表，只需要在该文件中找相关变量即可。有了数据源，接下来就是对数据源进行处理，与之相关的有非线性表fuel_nonlinearity和回调函数fuel_needle_cb。其中回调函数是对数据进行逻辑的判断和单位的转换，而转换后的数据再根据非线性表在图层上进行变化。而这个指针图层如何在背景图层上进行变化，则通过这几个宏IMAGE_USE_TRANSPARENCY|IMAGE_USE_ERASE|IMAGE_BILINEAR_COLOR实现。除此之外，BMP_FUEL_SMALL_NEEDLE代表在资源在程序中的定义。其他参数默认。定义好指针之后，要在lsit数组中进行实现，(PELEMENT_HEADER)&amp;fuel_needle。<br>对于非线程的定义，相关实现如下：需要注意的一点就是这个范围的定义每次的定义都是起始点开始。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非线性区间表 格式：像素点&#123;x,y&#125; 范围a~b</span></span><br><span class="line">NONLINEARITY  fuel_nonlinearity[] =</span><br><span class="line">&#123;</span><br><span class="line">&#123;&#123;<span class="number">30</span>,<span class="number">182</span>&#125;, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;&#123;<span class="number">119</span>, <span class="number">47</span>&#125;,<span class="number">25</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;&#123;<span class="number">246</span>, <span class="number">93</span>&#125;,<span class="number">50</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;&#123;<span class="number">241</span>,<span class="number">221</span>&#125;,<span class="number">75</span>, <span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="效果实现"><a href="#效果实现" class="headerlink" title="效果实现"></a>效果实现</h4><p>根据以上的代码编译之后，就可以在P3D中看到与之对应的效果图了，如下图所示，此时的仪表为2D仪表，后续还需3DMAX软件绘制3D仪表，通过XML文件传递动画实现3D的效果。<br><img src="https://i.loli.net/2021/09/16/Fpn3wqNrMCuY4Dy.png" alt="image.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇主要总结了下工程文件的结构以及仪表的具体实现，其实仪表的实现会一个，其他都会了。模板都是一样的。只是变量不同。理解里面的几个关键的宏定义。但是现在有一个问题，仪表的数据源的那个宏的数据是从哪来的，肯定是P3D输出的，具体P3D哪个文件或者项目产生，后面有机会再详细分析吧。这篇就这样，作者文笔有限，如果有错误的地方，欢迎大家指正。</p>]]></content>
      
      
      <categories>
          
          <category> 项目实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Prepar3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prepar3D开发总结01：模型与SDK</title>
      <link href="/2023/11/16/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5%EF%BC%9APrepar3D%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%9301/"/>
      <url>/2023/11/16/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5%EF%BC%9APrepar3D%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%9301/</url>
      
        <content type="html"><![CDATA[<p>怀着一颗未知的心，终于耗时一周打开了Prepar3D的大门，总结起来也并没有那么的复杂，但是需要配置的步骤可能会稍微繁琐。为防止以后遗忘，服务他人也方便自己，还是写几篇关于开发过程的博客总结吧。本篇主要总结准对使用Prepar3D开发仿真模型的总结，主要的部分为Prepar3D介绍与配置、飞机模型介绍与配置、以及SDK的实践。</p><span id="more"></span><h3 id="Prepar3D介绍与配置"><a href="#Prepar3D介绍与配置" class="headerlink" title="Prepar3D介绍与配置"></a>Prepar3D介绍与配置</h3><h4 id="Prepar3D"><a href="#Prepar3D" class="headerlink" title="Prepar3D"></a>Prepar3D</h4><p>Prepar3D是一个可视化模拟平台，允许用户创建跨航空、海事和地面领域的训练场景。Prepar3D 通过真实环境让用户参与到沉浸式培训中。Prepar3D软件由洛克希德·马丁（Lockheed Martin）公司开发，该公司是世界上最大的国防承包商。目前版本以更新至V5.2，Prepar3D在软件安装的内部默认安装了众多型号飞机、轮船等的仿真模型，除此模型之外，Prepar3D支持二次开发，也就是说您可以开发定义属于你自己的飞机仿真模型，开发的模型还可以与外部硬件进行通讯，从而让用户达到沉浸式学习的效果。</p><h4 id="配置与准备"><a href="#配置与准备" class="headerlink" title="配置与准备"></a>配置与准备</h4><p>在进行二次开发之前，请先准备以下资源和软件：</p><ol><li>Prepar3D软件已成功安装并破解，如需软件资源可私信联系我</li><li>准备Prear3D的SDK包，SDK包的主要文件如下，主要包含了一些二次开发的示例代码和工具插件<br><img src="https://i.loli.net/2021/09/10/3QR2uWvp9YBiLex.png" alt="image.png"></li><li>Prepar3D?Learning Center,P3D的教程中心，也是最权威最全面的参照指南，该文件在默认的安装目录中可以找到<br><img src="https://i.loli.net/2021/09/10/C4gGHzRTq6V9XSP.png" alt="image.png"></li><li>Visual Studio软件已安装，并且对已经掌握软件的使用方法，同时具备一定的C++ 开发经验，如需软件请私信作者</li><li>Photoshop 软件已安装，并且对PS掌握一些基本的操作，例如形状的绘制、图层的编辑等等<br>准备好以上资源之后，接下来就是先要对上述的软件进行一些配置和了解，对于P3D需要打开错误报告选项,方法为选择Options-&gt;Application-&gt;勾选Enable Content Error Reporting<br><img src="https://i.loli.net/2021/09/10/PCZM2m9OwoIuq3f.png" alt="image.png"><br>勾选完成之后，在每次软件加载模型过程中，如果编写或者配置的模型有问题，那么就会将具体的错误生成一个TXT文档，输出到Prepar3D v5 Files文件夹中，根据该文档就可以清晰地定位到错误的原因，相当于在编程过程中的二次编译。该文件夹的路径为：C:\Users\zsk\Documents\Prepar3D v5 Files，需要注意的一点就是，只有加载的模型出现问题才会将错误的Content Error Reporting.txt文件输出到该文件夹，如果该文件夹为空，则代表加载的模型正确，也可以说明二次开发的模型在语法和变量函数上没有问题。</li></ol><h3 id="飞机模型介绍与配置"><a href="#飞机模型介绍与配置" class="headerlink" title="飞机模型介绍与配置"></a>飞机模型介绍与配置</h3><h4 id="模型文件"><a href="#模型文件" class="headerlink" title="模型文件"></a>模型文件</h4><p>飞机的模型文件主要为两大类，一类是仿真模型的基础文件，该文件存放在SimObjects文件夹下；另外一类gau文件，存放在gauges文件目录下，可以理解成基础文件的扩展文件，在gau文件中实现了具体的功能和逻辑，二次开发的主要任务也就是生成对应的gau文件。两类文件相互结合，基础文件为gau文件提供框架，gau文件实现框架上的逻辑交互和动画展示。<br>在默认的安装目录下，P3D为用户提供了多种类型多种型号的仿真模型。以Mooney_Bravo型号的仿真模型为例，说明上述相应的两类文件。<br><strong>Mooney_Bravo基础模型：</strong><br><img src="https://i.loli.net/2021/09/10/mCNYfjnVOdqKaiu.png" alt="image.png"><br>该文件对应的路径如上图中所标记。主要的文件的含义如下：</p><ul><li>model:模型文件，该文件夹下存放着主要的Simulink仿真模型文件</li><li>panel:面板文件飞机上主要的面板都放在此文件夹下，该文件下还有一个panel.cfg(稍后会详细介绍）的配置文件，用于配置这些面板的属性</li><li>sound:声音文件，模型中例如警告的声音，发动机的声音等一些音频文件都放在这里】</li><li>texture:涂装文件，包含了飞机的外观设计，和涂装的颜色等等</li><li>aircraft.cfg：整个飞机模型的配置文件，包含了飞机的各项详细参数，后面将详细介绍</li><li>.air&#x2F;.htm文件暂时不用管<br><strong>gau文件：</strong><br><img src="https://i.loli.net/2021/09/10/OB3tW8zfAJDyusF.png" alt="image.png"><br>除了上述的框架之外，模型还需要gau文件的支持，如标红框的三项为对应飞机模型的gauges文件，该文件是通过Visual Studio C++编程输出的dll文件，具有很好的保密性。在框架的panel.cfg文件中就需要与该dll文件有交互。<br>如果我们想自己二次开发一架飞机仿真模型，如何添加到P3D中呢，我们可以通过将该飞机模型的基础模型文件和gauges文件打包成一个文件夹放在目录C:\Users\zsk\Documents\Prepar3D v5 Add-ons下，P3D在运行时会自动加载里面的模型。</li></ul><h4 id="panel-cfg"><a href="#panel-cfg" class="headerlink" title="panel.cfg"></a>panel.cfg</h4><p>panel.cfg文件是面板的配置文件，在P3D的模型中，如果你想显示你编写的面板或者交互开关，必须要在此配置文件夹下进行配置。该文件大致的格式如下：<br><img src="https://i.loli.net/2021/09/11/tOkmPJ6WqAMw7vB.png" alt="image.png"></p><ul><li>[Window Titles]:包含面板的种类，其命名规则为：WindowXX&#x3D;{PanelName},XX代表面板的序 号，注意在命名序号中要从0开始，同时{PanelName}不可相同。</li><li>[Windows XX]: 就是[Window Titles]中WindowXX的详细定义,在该项目中，可以定义面板的背景，面板的相关属性。除此之外，我们想要显示的仪表或者开关就是添加到该项目下，才可以在P3D运行时展示出来，具体的添加格式为：gauge00&#x3D;Mooney_Bravo!Airspeed, 13, 10, 158, 158 其中Mooney_Bravo为生成dll(gau)文件的名称，Airspeed为在项目中定义仪表的名称，和程序中GAUGE_NAME相同，后面的四项分别代表仪表的X Y W H值。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>     GAUGE_NAME          <span class="string">&quot;Attitude&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     GAUGEHDR_VAR_NAME   gaugehdr_attitude</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     GAUGE_W             100</span></span><br></pre></td></tr></table></figure>项目中定义的一些属性在此就不做过多的介绍，具体可以参考帮助指南，需要注意就是ident后面的数值每个Windows不能相同。</li><li>[VcockpitXX]：我理解的是添加3D的仪表，现在还没有涉及到，后面涉及到在做介绍。</li><li>[Color]、[Default View]、[VIEWS]：为定义的一些颜色或者视角，在此就不做介绍，以后用到后再详细记录</li></ul><h4 id="aircraft-cfg"><a href="#aircraft-cfg" class="headerlink" title="aircraft.cfg"></a>aircraft.cfg</h4><p>在模型的基础框架下面都有对应的aircraft.cfg文件，该文件的作用就是配置飞机的一些参数，包括发动机的型号、飞机模型外表的涂装、注册号、以及各个系统的属性参数。例如：在燃油部分配置了燃油的最大容量，如下图所示：<br><img src="https://i.loli.net/2021/09/11/QzlAYp52c31ydgq.png" alt="image.png"><br>如果我们想改变关于飞机的一些固有参数，在这个文件中查找修改即可。</p><h3 id="SDK-Panel实践"><a href="#SDK-Panel实践" class="headerlink" title="SDK Panel实践"></a>SDK Panel实践</h3><h4 id="大致步骤"><a href="#大致步骤" class="headerlink" title="大致步骤"></a>大致步骤</h4><ol><li>打开SDK中的C-Gauge Samples例程，该例程的位置D:\Prepar3D_V5\SDK\Panels and User Interface\Panels\C-Gauge Samples</li><li>打开项目例程，检查例程的属性和配置，对例程进行重新编译</li><li>将编译成功的例程的输出文件复制到C:\Program Files\Lockheed Martin\Prepar3D v5\gauges目录中</li><li>对模型飞机的panel.cfg文件进行配置，添加要显示的仪表</li><li>运行P3D，选择相应的飞机模型，点击Instrument，选择定义好的panel名称即可看到相应的仪表面板。<br>如下图显示所示，SDK的例程中，提供了燃油量的显示、燃油箱的选择、姿态球、航向和温度等信息。<br> <img src="https://i.loli.net/2021/09/11/7huHPAkcI8ax2sf.png" alt="image.png"></li></ol><h4 id="需要注意"><a href="#需要注意" class="headerlink" title="需要注意"></a>需要注意</h4><p>在帮助文档中有教程指导你如何运行SDK提供的C-Gauge Samples项目工程，在运行过程中需要注意以下几点：</p><ul><li>检查项目的属性配置，选择本机电脑对应的SDK版本、平台工具集、配置类型选择DLL动态连接库<br><img src="https://i.loli.net/2021/09/11/61uAgyfalOPIsiB.png" alt="image.png"></li><li>在将输出的dll文件添加到MOON——brao飞机的仪表过程中，需要将这以下几项文件复制出来。直接粘贴到C:\Program Files\Lockheed Martin\Prepar3D v5\gauges目录。<br><img src="https://i.loli.net/2021/09/11/awhmq4LSrvCj5tZ.png" alt="image.png"></li><li>在编辑panel.cfg的过程中，注意gaugeXX的序号，序号不可重复。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇博客主要是大概介绍了P3D的开发，后面将详细介绍SDK项目中程序的实现。第一次接触P3D的二次开发，有些可能还不是特别的了解，大概总结了下自己学习过程中遇到的一些问题，如果有错误之处，欢迎指出。</p>]]></content>
      
      
      <categories>
          
          <category> 项目实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Prepar3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenMV实践总结02：色块与AprilTag应用</title>
      <link href="/2023/11/16/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5%EF%BC%9AOpenMV%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%9302/"/>
      <url>/2023/11/16/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5%EF%BC%9AOpenMV%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%9302/</url>
      
        <content type="html"><![CDATA[<p>这两天学校开学，事情比较杂，OpenMV的学习进度没有那么的快，在这半周当中，主要是实践学习了色块和AprilTag的应用。星瞳科技的教程还是比较详细的，IDE中也有对应的示例代码。这次主要就是对代码中的需要注意的进行下记录。</p><span id="more"></span><h3 id="SD卡的使用"><a href="#SD卡的使用" class="headerlink" title="SD卡的使用"></a>SD卡的使用</h3><p>在OpenMV中大约提供了120KB的FLASH空间用于存储用户的脱机代码。这些对于正常存储程序空间是绰绰有余的，但是如果我们想用OpenMV去拍摄照片或者去录制视频，那么这个空间是远远不够的，这种情况下，我们就可以使用SD了，当SD卡插入后，就会去替代原先的FLASH空间。对于SD卡的相关参数，要求格式为FAT32，最大支持的容量为32GB。<br>使用方法为首先进行格式化，格式化之后，打开IDE软件，选择一个例程，选择工具，然后将打开的示例文件保存到OpenMV Cam 并且命名的格式为main.py.这样就好了</p><h3 id="色块实践"><a href="#色块实践" class="headerlink" title="色块实践"></a>色块实践</h3><p>对于色块的实践，主要参考星瞳科技提供的教程进行学习实践即可。具体的方法我就不在过多的赘述，详情点击<a href="https://book.openmv.cc/image/blob.html">寻找色块</a>，也可以打开IDE中对应的教程。在寻找色块中，常用的教程就是single_color_rgb565。这个例程是用于彩色单颜色识别的，也可以修改进行多颜色识别。在例程代码中需要注意以下几点：</p><ol><li>相机需要关闭白平衡和自动增益，关闭的代码如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sensor.set_auto_gain(<span class="literal">False</span>) <span class="comment"># must be turned off for color tracking</span></span><br><span class="line">sensor.set_auto_whitebal(<span class="literal">False</span>) <span class="comment"># must be turned off for color tracking</span></span><br></pre></td></tr></table></figure></li><li>主要的函数为find_blobs()<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_blobs([thresholds[threshold_index]], pixels_threshold=<span class="number">200</span>, area_threshold=<span class="number">200</span>, merge=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>对于该函数，几个常用的入口参数和出口参数如下：</li></ol><ul><li>thresholds：颜色的阈值，可以理解为你要识别的颜色。注意这个颜色不是RGB值，是LAB值的最大和最小值。在LAB中，L表示亮度、a的正数表示红色，负数表示绿色、b的正数表示黄色，b的负数表示蓝色。总结起来就是L是负责亮度的调节，AB是负责颜色的平衡。<br>对于这6个数值如何取值，IDE中提供了两种常用的方法，一种是采用阈值调节器，打开的方法如下<br><img src="https://i.loli.net/2021/09/05/IySCm9UGZ7XAuzf.png" alt="image.png"><br>拖动下面的6个滑块，使上面你想识别的颜色显示为全白，其他部分的颜色显示为全黑，赋值下面的数字到程序中即可<br><img src="https://i.loli.net/2021/09/05/iHUsFIVa8Prp5ke.png" alt="image.png"><br>第二种方法是根据IED种的直方图，直接读出LAB的最大值和最小值，例如<br><img src="https://i.loli.net/2021/09/05/QZVSrcCFRktDguB.png" alt="image.png"><br>具体两种方法，哪种比较精准，我个人还是比较推荐先用第二种确定大概值，然后再用这个大概值使用第一种方法去调节。</li><li>pixels_threshold：像素个数阈值，如果色块像素数量小于这个值，会被过滤掉</li><li>area_threshold：面积阈值，如果色块被框起来的面积小于这个值，会被过滤掉</li><li>merge：如果设置为True，那么合并所有重叠的blob为一个<br>几个常用的返回参数如下：</li><li>blob.rotation()：返回色块的旋转角度</li><li>blob.code() 返回的是如果是多个颜色识别，识别到的颜色代码。更多详细的参数请参考中文文档<br><a href="https://docs.singtown.com/micropython/zh/latest/openmvcam/index.html">MicroPython 和 OpenMV Cam 中文文档</a></li></ul><h4 id="实践结果"><a href="#实践结果" class="headerlink" title="实践结果"></a>实践结果</h4><p><img src="https://i.loli.net/2021/09/05/6zPCvX9k12xbDm4.png" alt="image.png"><br>实践的现象如上图中所示，在上述的实践中，主要识别的颜色为红色，当识别到红色之后，用一个白色的框圈起。除了白色的框之外，还有红色的框，红色的框圈起的是红色像素点的区域，在红色框中有一个蓝色和绿色的线，分别代表主轴线和次轴线。以上三个方框的实现代码对应为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img.draw_edges(blob.min_corners(), color=(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">img.draw_line(blob.major_axis_line(), color=(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>))</span><br><span class="line">img.draw_line(blob.minor_axis_line(), color=(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>))</span><br></pre></td></tr></table></figure><h3 id="AprilTag实践"><a href="#AprilTag实践" class="headerlink" title="AprilTag实践"></a>AprilTag实践</h3><p>OpenMV去识别颜色还是比较精准和简单的，初次之外，还有一个比较喜欢用OpenMV用的就是AprilTag.它是一个视觉基准系统，可用于各种任务，包括AR，机器人和相机校准。这个tag可以直接用打印机打印出来，而AprilTag检测程序可以计算相对于相机的精确3D位置，方向和id.Tag有很多的种类，我们常用的就是TAG36H11，ID值为0到586.<br>同样可以使用IDE中的AprilTag生成器去生成对应的TAG。生成的方法比较简单，生成之后，打印即可使用。<br><img src="https://i.loli.net/2021/09/05/rlSTuozJywWgYHq.png" alt="image.png"></p><h4 id="代码理解"><a href="#代码理解" class="headerlink" title="代码理解"></a>代码理解</h4><p>AprilTag最常用的有两种方式，其中一种使用方式是去寻找TAG，另外一种使用的场景是TAG的3D定位。主要用的函数为find_apriltags(),寻找TAG的例子比较简单，在这里不做介绍，支队3D定位的代码进行分析。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find_apriltags(fx=f_x, fy=f_y, cx=c_x, cy=c_y)</span><br><span class="line"><span class="comment"># f_x 是x的像素为单位的焦距。对于标准的OpenMV，应该等于2.8/3.984*656，这个值是用毫米为单位的焦距除以x方向的感光元件的长度，乘以x方向的感光元件的像素（OV7725）</span></span><br><span class="line"><span class="comment"># f_y 是y的像素为单位的焦距。对于标准的OpenMV，应该等于2.8/2.952*488，这个值是用毫米为单位的焦距除以y方向的感光元件的长度，乘以y方向的感光元件的像素（OV7725）</span></span><br><span class="line"><span class="comment"># c_x 是图像的x中心位置</span></span><br><span class="line"><span class="comment"># c_y 是图像的y中心位置</span></span><br></pre></td></tr></table></figure><p>find_apriltags默认选择识别的Family为TAG35H11。fx&#x3D;f_x, fy&#x3D;f_y, cx&#x3D;c_x, cy&#x3D;c_y是根据不同的摄像头进行变化的。对于返回参数值，可以返回相对于相机的3D位置和方位信息。注意在这里是选取摄像头为坐标原点，其中tag.x_translation(), tag.y_translation(), tag.z_translation()分别代表以摄像头为原点的3D空间中TAG的X&#x2F;Y&#x2F;Z轴信息。tag.x_rotation()), degrees(tag.y_rotation()), degrees(tag.z_rotation()反应的是TAG相对于各自轴XYZ的旋转角度，注意这个是弧度，如果需要角度，需要去转换。除此之外，tag.id()代表的是别到的TAG的ID值。</p><h4 id="实践结果-1"><a href="#实践结果-1" class="headerlink" title="实践结果"></a>实践结果</h4><p><img src="https://i.loli.net/2021/09/05/5ibuzdInYpm7R3c.png" alt="image.png"><br>如上图所示，TAG别成功识别到。在串行终端打印识别到的位置信息。对于XYZ轴的距离值，是实际的距离一一对应的。换算值大约需要乘27.在实际使用过程中，不需要进行相关的换算。可以根据三个轴的距离，利用勾股定理求出TAG到摄像头的直线距离。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是对于色块和TAG的识别的总结，更加详细的教程可以看星瞳的，讲的还是挺详细的。对于上述的识别，可以采用通过串口与其他单片机进行交互。从而完成更加复杂的功能任务。下周计划将第一版PCB版修改下，打印制作第二版OpenMV.初次之外，再实践下其他相关的代码。让我们一起进步吧~，每天进步一点点。加油！！</p>]]></content>
      
      
      <categories>
          
          <category> 项目实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenMV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenMV实践总结01：HelloWorld</title>
      <link href="/2023/11/16/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5%EF%BC%9AOpenMV%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%9301/"/>
      <url>/2023/11/16/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5%EF%BC%9AOpenMV%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%9301/</url>
      
        <content type="html"><![CDATA[<p>OpenMV4总算有了进展，自己内心的那份疑惑或者说好奇也终于有了一点明朗。前段时间画的OpenMV4今天已经可以运行HelloWord程序了，在此对前面的工作包含电路设计、驱动软件等相关方面自己遇到的问题做一个简单总结。</p><span id="more"></span><h3 id="电路设计"><a href="#电路设计" class="headerlink" title="电路设计"></a>电路设计</h3><p>在电路设计方面主要是参照官网的开源电路图，在这个基础之上加以修改。在修改过程中，我主要考虑的就是这个元器件在国内是不是很容易买到，或者它的封装是不是常见的封装形式。在原来的电路图基础之上，主要做了以下修改：</p><ul><li>3.3V电压的产生由PAM2305AABADJ更改为常见的AMS1117-3.3；在这个过程中，我还对常用的5V转3.3V芯片做了一个简单的罗列，见下面表格.主要参考原有芯片的最大电流和OpenMV工作时的电流进行选择，根据OpenMV的手册，在器件带SD卡工作时的电流大约250ma左右，则综上可以选择常用的AMS117-3.3.</li></ul><table><thead><tr><th align="left">名称</th><th align="right">最大电流</th><th align="center">封装</th></tr></thead><tbody><tr><td align="left">HT7533</td><td align="right">100ma</td><td align="center">SOT89</td></tr><tr><td align="left">AMS117-3.3</td><td align="right">800ma</td><td align="center">SOT223</td></tr><tr><td align="left">SPX1117M-3.3</td><td align="right">1000ma</td><td align="center">SOT223</td></tr><tr><td align="left">XC6206P33</td><td align="right">200ma</td><td align="center">SOT23</td></tr><tr><td align="left">MIC5219</td><td align="right">500ma</td><td align="center">SOT23-5</td></tr><tr><td align="left">LP2985AIM-3.3</td><td align="right">150ma</td><td align="center">SOT23-5</td></tr><tr><td align="left">PAM2305AABADJ</td><td align="right">1000ma</td><td align="center">TSOT25</td></tr><tr><td align="left">上面的几种封装中，其中最小的是SOT23，最大的是SOT223。</td><td align="right"></td><td align="center"></td></tr></tbody></table><ul><li>1.8V用于OV7725摄像头供电电压芯片由TPS231XX更改为AMS1117-1.8V。原因也很简单，TPS231XX属于可调电压芯片，需要外接反馈电阻才可以实现输出1.8V；而AMS1117-1.8V外围电路简单，市面上较常见。</li><li>所有的接插座子均由原有的2.54MM更改为1.25MM.目的在于减少模块的尺寸。<br>在设计之初参考别人大牛的作品时，总结出有以下几点需要注意的地方：</li><li>USB的D+ D-不需要接任何的电阻，因为STM32内部有阻抗匹配</li><li>I2C要硬件初始化，所以要在SCL和SDA引脚接上拉电阻</li><li>5V电压要接芯片的PA9引脚，该引脚具有OTG-FS-VBUS功能</li></ul><h3 id="PCB设计"><a href="#PCB设计" class="headerlink" title="PCB设计"></a>PCB设计</h3><p>考虑到尺寸的需求和布线的方便，也借此机会实践PCB四层板的设计。顶层和底层为走线层，中间层为GND和VCC层。GND层在顶层之下。布线的大致流程为：首先根据元器件确定板子的大致尺寸信息，然后进行元器件的摆放，在摆放过程中，需要注意接口的方向和对称性，然后进行顶层和底层的布线，先将除了VCC和GND 的都连接好，最后利用打孔局部敷铜的形式连接VCC和GND。在此过程中需要注意以下几点:</p><ul><li>打孔的孔不能只打一半的那种孔，所有的孔必须为通孔，否则嘉立创做不了</li><li>丝印的标识要采用图片+插件生成的形式，直接从别的PCB拷贝过来的发现乱码（3 7之类）</li><li>对于自己没有的封装或者原理图，可以选择 粘贴别的板子的器件，需要注意的就是在粘贴完成之后，将原理图中器件的编号要和PCB中封装的编号对应在一起。</li><li>VCC层的敷铜面积或者外围应该小于GND层的外围，这么做可以阻止回流</li><li>VCC和GND层采用的均是正片层，正片层就需要进行敷铜的操作<br><img src="https://i.loli.net/2021/08/31/9OiabutnqYZ4G2B.png" alt="image.png"></li></ul><h3 id="焊接与固件烧录"><a href="#焊接与固件烧录" class="headerlink" title="焊接与固件烧录"></a>焊接与固件烧录</h3><p>最近嘉立创推出4层板免费打印的活动是真香，四层板由于工艺的原因，生产周期相比于两层板来讲时间要多个2天左右。最近芯片的价格也是涨的迅猛，一篇STM32H743要65元，还要担心害怕买到的是假芯片。基本上器件都能买或者找的到，焊接也是一项挑战，最难焊的就是24pinOV7725接口。需要注意的一点就是不用上这么多焊锡。焊接好的成品图如下：<br><img src="https://i.loli.net/2021/08/31/Xhl5xqDV3EFmUHj.jpg" alt="外观01.jpg"><br><img src="https://i.loli.net/2021/08/31/BhzTnefV7ir6jd3.jpg" alt="外观02.jpg"></p><h4 id="固件烧录"><a href="#固件烧录" class="headerlink" title="固件烧录"></a>固件烧录</h4><p>自己DIY买的STM32芯片是没有固件的，OpenMV如果需要运行是需要烧写固件的，对于新买的芯片常用DFU的形式进行烧录，方法步骤如下：</p><ol><li>将BOOT引脚和3.3V引脚短接<br><img src="https://i.loli.net/2021/08/31/pklMuFmcevnGr7d.jpg" alt="微信图片_20210831204134.jpg"></li><li>然后将USB插上电脑，电脑会显示如下（只要显示DFU就说明当前芯片DFU连接成功）<br><img src="https://i.loli.net/2021/08/31/zKDeTNsWlfo3Zyu.png" alt="image.png"></li><li>在OpenMV的IDE中打开DFU烧录软件，选择下方的choose，选择固件，对应的固件也在IDE中，然后点击更新即可。<br><img src="https://i.loli.net/2021/08/31/MNuGDX1retkYbsh.png" alt="image.png"><br><img src="https://i.loli.net/2021/08/31/8zoH65A3SM9ylRs.png" alt="image.png"><br><img src="https://i.loli.net/2021/08/31/Swr8zXEamhnGbDo.png" alt="image.png"><br>参考链接：<a href="https://blog.csdn.net/qq_42748213/article/details/90579251">https://blog.csdn.net/qq_42748213/article/details/90579251</a><br><a href="https://makermare.com/t/29.html">https://makermare.com/t/29.html</a><br>！！！注意注意的是以上这种方式适用于非V版的芯片，对于V版的芯片，会出现进度条到49%时停止更新，也就是固件通过这种方式是无法烧录的。通过不断的摸索和尝试，对于V版的芯片，采用STM32 Cube Programmer的方法，步骤为：</li><li>去ST官网下载STM32 Cube Programmer，下载后安装软件，软件安装中会安装驱动，安装好的界面如下：<br><img src="https://i.loli.net/2021/08/31/lvF4wKX7LPChbqz.png" alt="image.png"></li><li>将芯片BOOT引脚和3.3V引脚短接，插入电脑，进入DFU模式，此时设备管理器显示如下：<br><img src="https://i.loli.net/2021/08/31/zKDeTNsWlfo3Zyu.png" alt="image.png"></li><li>依次选择USB-刷新-连接，使软件与芯片通过DFU的形式进行连接，参考图片<br><img src="https://i.loli.net/2021/08/31/zrx1K93aHYflt2m.png" alt="image.png"></li><li>连接成功后如下图所示，之后选择Memory &amp; File edition→选择Read→Open File，打开bin文件。<br><img src="https://i.loli.net/2021/08/31/ytI1d2zbqn9D5XH.png" alt="image.png"><br><img src="https://i.loli.net/2021/08/31/MqHiT3PnuKA8xg5.png" alt="image.png"></li><li>点击DOWNLOAD下载按钮，可以看到下方的进度条在变化，等待到100%。之后断开芯片，移除boot0和3.3V脚之间的杜邦线。<br> <img src="https://i.loli.net/2021/08/31/xQ1U8m9p5vecgFi.png" alt="image.png">  </li><li>重新用USB连接OpenMV4和电脑，等待10秒使其完成自检并闪烁LED（我的是闪烁绿灯）。此时文件管理器和设备管理器都会把OpenMV4识别成一个U盘，说明DFU烧录成功，成功完成“恢复出厂设置”！<br><img src="https://i.loli.net/2021/08/31/iPcam1YjLRH7tbM.png" alt="image.png"><br>参考链接：<a href="https://blog.csdn.net/qq_36375203/article/details/105568044">https://blog.csdn.net/qq_36375203/article/details/105568044</a></li></ol><h3 id="运行第一个helloworld"><a href="#运行第一个helloworld" class="headerlink" title="运行第一个helloworld"></a>运行第一个helloworld</h3><p>在固件烧写完成之后，按照步骤，将OpenMV插入到电脑之后，打开OpenMVIDE软件，设备管理器应该会出现对应的端口，并且资源管理器会出现U盘，但是对于我设计的这版来讲，什么反应都没有，网上搜了很多的解决方案，最后将可能出现的方向定位到了电压上，不知道为什么我输入的电压是4.4V，而单片机供电的电压为2.7V，网上说不能低于3V供电，我想可能是因为供电电压过低，导致器件工作不正常。<br>找到方向后，就考虑什么导致供电电压偏低，我将USB至AMS1117-3.3的器件排查了一遍，可能的器件有保险丝和SS14二极管，之后将这两种元器件拆下，直接将USB输出的5V供给AMS1117-3.3v,拆掉所有的保险，我发现保险不仅具有保护作用，居然还有降压的作用。从新上电测试，芯片供电电压正常，设备管理器也显示出了端口，但是资源管理器不显示U盘，这时的端口一会有，一会没有。出现这种现象使用IDE软件进行擦除，发现可以正常的擦除和编写。在编写完成之后，上述问题解决，资源管理器正确弹出U盘。<br>点击连接，运行第一个程序，显示出的界面，至此，硬件实践完成！<br><img src="https://i.loli.net/2021/08/31/7NrChTglnwzDGv5.png" alt="image.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在设计过程中，可能会出现各种各样的问题，需要我们仔细专注去解决。目前对于为什么4.4V的输入还未解决，如果得不到解决，下一版中准备删除对应得元器件。后面准备使用PHTYON语言进行编程实践。并且总结第一版得缺陷，更新第二版OpenMV.由于第一版电压的问题，PCB文件就不分享给大家了，后续稳定后的第二版再分享给大家！</p>]]></content>
      
      
      <categories>
          
          <category> 项目实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenMV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习随笔04：磁盘与文件系统管理</title>
      <link href="/2023/11/16/Linux%E7%B3%BB%E7%BB%9F%EF%BC%9A%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
      <url>/2023/11/16/Linux%E7%B3%BB%E7%BB%9F%EF%BC%9A%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在了解完Linux操作系统的文件与目录之后，对于一些常用的命令当然要熟记于心，比如常用的cd,ls,cp这些等等，需要掌握对于文件和文件夹的一些基本的操作。在这些基础之上，今天看下每个操作系统中都有的，也是学起来比较虚的，就是磁盘与文件系统。</p><span id="more"></span><h3 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h3><p>文件系统时寄生在磁盘上的，对于磁盘来讲，其分区主要有两种格式，一种是限制较多的MBR分区表，一种是较新且限制较少的GPT分区。推荐后者。对于微软的文件系统，Windows98之前的都是FAT，Windows2000之后的为NTFS，而对于Linux的文件操作系统则为ext2。</p><h4 id="ext2文件系统"><a href="#ext2文件系统" class="headerlink" title="ext2文件系统"></a>ext2文件系统</h4><p>对于Linux文件系统ext2存储文件的形式则是采用indoe&#x2F;block的形式，在block中存放着数据，在indoe的中存放着block块在磁盘中的位置，这样在读写文件时就可以直接根据indoe的信息，找到相应的block块的信息。除了indoe,对于ext2还有indoe对应表、区块对应表、文件系统描述、以及超级块。下面对这几个部分做详细介绍。</p><ol><li>数据区块（datablock):存放相应的数据，需要注意的一点就是该数据块支持的大小只能是1k&#x2F;2k&#x2F;4k这三种情况，每个区块只能存放一个数据，如果该数据大小小于区块的大小，则剩余的只能空着。如果文件大于区块的容量，则需要采用多个区块组合来存放文件。故对于该数据块的大小要根据实际的用途进行配置。</li><li>inode table(inode表)：在inode中记录着文件的属性信息，例如文件的读写属性、拥有者和用户组、文件大小、修改时间等。除此之外，每个inode规定大小为128B，一个文件会占用一个inode。相应的如果文件的block块越多，则inode的数量也就会越多。一个文件的block在inode中会占用4B，那么将会有一个问题，这个inode如果按照这种方式最多可以记录的block的数量为32个，如果一个文件非常大，占用的block超过了32，那么该怎么存储呢。这时ext2文件系统采用了间接、双间接、三间接的方式进行存储。采用这种方式后，最大的存储文件单个大小可以达到16GB</li><li>superblock（超级区块）：记录整个文件系统的信息，包含数据区块和inode的数量、数据区块和inode的大小、文件系统挂载时间、挂载有效位等。大小1024B</li><li>Filesystem Description(文件系统描述说明)：记录区块组开始和结束的区块，区段的每部分的区间</li><li>inode对照表:记录inode号码的使用情况</li><li>区块对照表：记录区块的使用情况。<br>在操作系统中可以采用dumpe2fs这个命令进行上述几项信息的查找，注意仅仅针对ext2格式的文件系统。</li></ol><h3 id="文件系统的操作"><a href="#文件系统的操作" class="headerlink" title="文件系统的操作"></a>文件系统的操作</h3><h4 id="查看磁盘使用量"><a href="#查看磁盘使用量" class="headerlink" title="查看磁盘使用量"></a>查看磁盘使用量</h4><p>这里面有两个命令，一个是df,用于列出文件系统的整体磁盘使用量；另外一个是du,查看文件系统的磁盘使用量。对于df命令，可以直接输入使用，也可以增加选项，df -ih：将目前各个分区用的inode数量列出。这个命令因为直接读取超级块中的信息，因此执行的速度比较快。<br><img src="https://i.loli.net/2021/11/18/zjcQ8NsLdZmpxAf.png" alt="image.png"><br>使用的方法可以见上，Filesystem代表文件系统在哪个硬盘分区，1k-blocks代表下面的数字单位是1k;Mounted on代表的含义就是磁盘的挂载目录。</p><h3 id="磁盘的分区、格式化、检验与挂载"><a href="#磁盘的分区、格式化、检验与挂载" class="headerlink" title="磁盘的分区、格式化、检验与挂载"></a>磁盘的分区、格式化、检验与挂载</h3><h3 id="启动挂载与内存交换分区"><a href="#启动挂载与内存交换分区" class="headerlink" title="启动挂载与内存交换分区"></a>启动挂载与内存交换分区</h3>]]></content>
      
      
      <categories>
          
          <category> Linux系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>聊聊文件操作和目录管理的命令</title>
      <link href="/2023/11/16/Linux%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"/>
      <url>/2023/11/16/Linux%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>前段时间呢，大致聊了下Linux系统的三种命令帮助，其中需要熟记的还是man page以及help的用法，还聊了聊在Linux系统中一个非常重要的概念，那就是权限管理。权限管理的对象，以及Linux系统的文件结构。这几个方面的内容都是非常重要，今天继续往下学习文件操作和目录管理中常用的几个命令。</p><span id="more"></span><h3 id="目录的相关操作"><a href="#目录的相关操作" class="headerlink" title="目录的相关操作"></a>目录的相关操作</h3><p>想一想在Windos系统中，你对于目录经常需要哪些操作？总结下来就是：创建一个新的目录、删除目录、打开目录等。在Linux操作系统中，对于目录的操作也是如此，需要新建和删除目录，目录之间的切换等。同时由于Linux采用命令行终端的形式，还需要显示当前目录。</p><h4 id="新建删除命令（mkdir-rmdir"><a href="#新建删除命令（mkdir-rmdir" class="headerlink" title="新建删除命令（mkdir&#x2F;rmdir)"></a>新建删除命令（mkdir&#x2F;rmdir)</h4><p>mkdir（make dirctory)用于新建一个空白的目录，后面直接接目录的名字。选项参数有 -m,代表的含义为创建一个指定权限的目录，例如：mkdir -m 666 test;含义为：创建一个新的目录，命名为test1105，对应的权限为666，rw-rw-rw-。需要值得注意的一点是在创建目录时不能在未创建的目录下面创建一个新的目录。<br><img src="https://i.loli.net/2021/11/05/tOY1dyEfwWQJcjv.png" alt="image.png"><br>有创建就会有删除，删除命令rmdir(romve dirctory).删除命令的用法和新建目录的用法相差不大，也是后面接文件名，如果是需要递归的方式删除，则需要在命令和目录对象之间加上一个-p选项。</p><h4 id="目录切换命令cd"><a href="#目录切换命令cd" class="headerlink" title="目录切换命令cd"></a>目录切换命令cd</h4><p>在Linux系统中，最常用的命令之一。cd(change dirtory).常规的用法就是在命令后面直接接上你要去的目录的路径，这个路径可以是绝对路径，也可以是相对路径。类似于：cd &#x2F;tmp。另外还有几个相对快捷的用法，如下所示：</p><table><thead><tr><th align="center">命令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">cd</td><td align="center">直接切换到当前用户的家目录</td></tr><tr><td align="center">cd -</td><td align="center">切换到刚才的那一个目录</td></tr><tr><td align="center">cd ..</td><td align="center">切换到当前目录的上一级目录</td></tr><tr><td align="center">cd ~</td><td align="center">切换到自己的家目录</td></tr><tr><td align="center">除此之外还是pwd这个目录，显示当前所在的目录等等。</td><td align="center"></td></tr></tbody></table><h3 id="文件与目录的管理"><a href="#文件与目录的管理" class="headerlink" title="文件与目录的管理"></a>文件与目录的管理</h3><p>还是类比如Windos系统中对于文件和目录的管理。先说文件，在Windos系统中，对于文件就是查看该文件、删除文件、新建文件、移动文件、复制文件等等。在Linux中也是类似。</p><h4 id="查看命令ls"><a href="#查看命令ls" class="headerlink" title="查看命令ls"></a>查看命令ls</h4><p>ls（list)命令则表示对文件和目录的查看，ls配合一定的选项功能可以查看该文件或者目录的一些属性，例如权限信息、时间信息、文件名、文件类型等等。比较常用的一些选项如下：</p><table><thead><tr><th align="center">命令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">ls -a</td><td align="center">显示目录下的所有文件，隐藏文件同样显示</td></tr><tr><td align="center">ls -l</td><td align="center">详细信息显示，包含文件的属性与权限数据</td></tr><tr><td align="center">ls -d</td><td align="center">仅列出目录本身，而不是列出目录在内的文件数据</td></tr><tr><td align="center">由于ls -l的命令比较常用，所以现有的发行版本中，用ll代替该命令。</td><td align="center"></td></tr></tbody></table><h4 id="复制、删除、移动"><a href="#复制、删除、移动" class="headerlink" title="复制、删除、移动"></a>复制、删除、移动</h4><p>先讲cp复制命令，命令的格式为：cp 【选项】 源文件 目标文件。含义为讲源文件复制到目标文件中，在选项的含义中，-a代表全部复制；-i代表若文件存在则在复制时会先进行询问；-p代表连同文件的属性一起复制过去；-r代表递归复制。在使用文件复制时，要确保用户对文件具有相应的权限<br>然后再讲讲rm删除文件或目录，后面直接接要删除的文件目录或者文件，对应的选项有三种，-f代表强行删除，-I代表删除之前会进行询问确认；-r代表递归删除。<br>最后时移动文件mv,使用的格式为 mv [选项] source1 source2 .. directory。选项中如果有-u则代表更新文件。</p><h3 id="文件的查看"><a href="#文件的查看" class="headerlink" title="文件的查看"></a>文件的查看</h3><p>文件的查看在Linux操作系统中有很多种，其中最常用用的有以下几种：</p><ol><li>cat:Concatenate串联，表示文件的内容打印在终端上，用于文件行数较短的文件查看。如果后面接-n,则可以实现每行前面有一个序号。</li><li>tac:与cat相反，cat表示的是从第一行显示到最后一行，而tac表示的是从最后一行显示到第一行。</li><li>more:可以实现一页一页的显示，适用于文件比较大的文件查看，其中空格键表示向下翻一页，回车键表示向下翻一行。</li><li>less:用法和more差不多，区别在于more有时不能向前翻页，而less则可以实现这个功能，可以用PageUP和PageDown两个进行操作。</li><li>head:只显示该文件的前几行</li><li>tail：只显示该文件的后面几行</li><li>od:非纯文本进行显示<br>除此之外还有一个命令，那就是文件的创建命令，touch命令，后面直接接要创建的文件名字。对于创建的文件，有几个时间的概念需要解释，第一个就是修改时间（mtime)这个比较关系，另外一个就是状态时间（ctime),最后一个就是读取时间(atime)。</li></ol><h4 id="默认权限umask"><a href="#默认权限umask" class="headerlink" title="默认权限umask"></a>默认权限umask</h4><p>在Linux操作系统中，有一个定义就是默认权限的概念，这个概念的含义就是当你去创建文件时，如果你不指定相应的权限，他会以这个默认权限去创建，默认的是022，含义就是对于用户来讲，保留读写和执行，对于用户组来讲，保留读和执行，对于其他用户也是一样。大白话就是在你默认创建时，它的权限就是&#x3D;全部的权限-默认的权限。022的含义就是他拿去了用户组和其他用户写的权限，这个是非常必要的。一般在我们指定权限创建文件时，最后创建出来的文件也是拿去了默认的权限。<br><img src="https://i.loli.net/2021/11/05/KPTwaoUFpR8GeSj.png" alt="image.png"><br>可以从上面看出，test11文件的其他用户去掉了写的权限。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>文件具有SUID的特殊权限时，代表当前用户执行次二进制程序时，在执行过程中用户会暂时拥有者的权限<br>目录具有SDID的特殊权限时，代表用户在这个目录下面新建的文件的用户组都会与该目录的组名相同<br>目录具有SBIT权限时，代表在该目录下用户建立的文件只能自己或root能够删除<br>观察文件文件的类型可以使用file命令<br>查找文件可以使用whereis find locate 命令。</p>]]></content>
      
      
      <categories>
          
          <category> Linux系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习随笔02：文件权限与目录配置</title>
      <link href="/2023/11/16/Linux%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/"/>
      <url>/2023/11/16/Linux%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>Linux操作系统的文件目录和windows是大不一样的，同时在Linux操作系统中，有一个非常重要的知识点就是文件权限，至于什么是文件权限？系统的文件目录有和Windows有何不同，下面我们就一起聊聊。</p><span id="more"></span><h3 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h3><p>先来讲讲用户和用户组的相关概念吧。在Linux操作系统中是可以实现多个终端界面同时登录到一台主机的。登录系统的账号被称为用户，而用户组相当于Windows里面域的概念。设立用户和用户组的概念就是方面文件权限的管理。用户是一级者，用户组为二级者。</p><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><h4 id="文件权限的格式"><a href="#文件权限的格式" class="headerlink" title="文件权限的格式"></a>文件权限的格式</h4><p>既然实现了多个终端在一台主机上进行登录，那么必然要实现文件的管理，也就是文件权限，防止A用户的文件被B用户修改。在Linux系统中的文件权限分为三部分，分别是用户：用户组：其他者，使用ls -l命令可以查看当前文件夹中文件或文件夹的详细信息，如下图所示<br><img src="https://i.loli.net/2021/10/31/VRNOcTKiS1bF3aH.png" alt="image.png"><br>上面的图片中展示了一个链接文件bin和一个文件夹boot。上面显示文件的信息格式为：</p><table><thead><tr><th align="center">01</th><th align="center">02</th><th align="center">03</th><th align="center">04</th><th align="center">05</th><th align="center">06</th><th align="center">07</th></tr></thead><tbody><tr><td align="center">dr-xr-xr-x</td><td align="center">6</td><td align="center">root</td><td align="center">root</td><td align="center">1024</td><td align="center">MAY 10 2019</td><td align="center">bin</td></tr><tr><td align="center">文件夹类型权限</td><td align="center">链接数</td><td align="center">文件拥有者</td><td align="center">单元格</td><td align="center">文件所属用户组</td><td align="center">最后修改时间</td><td align="center">文件名</td></tr><tr><td align="center">对于文件夹类型权限：<strong>dr-xr-xr-x</strong>，一共10个字符，其中第一个字符代码文件的类型，后面9个字符表示文件的权限。常见的文件类型为：**-<strong>:普通文件；</strong>d**:目录；<strong>b</strong>:设备文件（U盘等）；<strong>c</strong>:设备文件（键盘等）；<strong>l</strong>:链接文件。后面9个字符三个三个为一组，分别表示用户、用户组、其他者三部分的权限。在三个字符中，以<strong>rwx</strong>的格式进行表示。其中r代表可读，数字为4；w代表可写，数字为2；x代表可执行，数组为1。如果没有相应的权限则用-表示。上述bin文件夹的权限为用户root,用户组root,和其他用户都具有可打开和可读的权限，但是没有可写的权限。</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">文件和文件目录的x有着不同的含义，其中文件的x表示该文件可以被执行，如果是可执行的程序文件，则可以说该文件可以成功执行。文件夹的x代表是用户能否打开这个文件夹。并不是该文件夹可以被执行，显然文件夹是不可以被执行的。</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h4 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h4><p>修改权限包含三个部分，一个是修改用户对于该文件的权限，采用chmod命令，另外一个是修改该文件的所有者，命令为chown,最后一个是修改该文件的用户组，命令为chgrp.下面我们一一看这三个命令的使用方法。<br><strong>chmod</strong>：chmod+(u&#x2F;g&#x2F;o)+(r&#x2F;w&#x2F;x)+文件名。其中(u&#x2F;g&#x2F;o)+(r&#x2F;w&#x2F;x)可以随意的组合，例如chmod u rw filename;还有一个+-,表示不管原来的权限是什么，在原来的基础之上加上或者减去这个权限，例如chmod u +x fimename;这么的表示方法显示比较笨拙，还有一种比较方便的表示方法就是采用数字的形式，将421进行组合，例如上面例子中的文件权限就是 chmod 555 boot.<br><strong>chown</strong>: chown + 用户+ 文件<br><strong>chgrp</strong>: chown + 用户组+ 文件。<br>在这三个命令中，如果在命令后面加上了-R这个字符，就表示递归，也就是如果你修改的是文件夹的属性，那么文件夹下面对应的文件的属性也会随之修改。还有一点需要注意的就是文件夹和文件的权限互相不影响，如果一个用户对这个文件夹具有删除修改的权限，即使这里面的文件对于这个用户没有修改的权限，最终这个用户还是可以对该文件进行更改的。</p><h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><p>在Linux操作系统中，扩展名对于文件来讲的意识不大，其实可以说无所谓。虽然现在有很多发行版的Linux操作系统，但是他们的目录结构都遵循FHS标准，在FHS标准下，目录的大致结构和功能其实是差不多的，下面列举几个常见的目录和对应的功用。<br><img src="https://i.loli.net/2021/10/31/PeHEAxWK6pTvZD2.png" alt="image.png"></p><table><thead><tr><th align="center">01</th><th align="center">02</th><th align="center">03</th><th align="center">04</th><th align="center">05</th><th align="center">06</th></tr></thead><tbody><tr><td align="center">bin</td><td align="center">boot</td><td align="center">dev</td><td align="center">etc</td><td align="center">lib</td><td align="center">media</td></tr><tr><td align="center">二进制文件，包含一些命令</td><td align="center">内核启动文件</td><td align="center">设备信息文件</td><td align="center">配置文件，密码用户等</td><td align="center">链接库文件</td><td align="center">挂载点（光盘）</td></tr><tr><td align="center">opt</td><td align="center">proc</td><td align="center">sbin</td><td align="center">usr</td><td align="center">var</td><td align="center">mnt</td></tr><tr><td align="center">第三方软件安装目录</td><td align="center">内核参数</td><td align="center">系统二进制文件</td><td align="center">相当于program files</td><td align="center">运行缓存、日志等</td><td align="center">挂载点</td></tr></tbody></table><h4 id="区别绝对路径和相对路径"><a href="#区别绝对路径和相对路径" class="headerlink" title="区别绝对路径和相对路径"></a>区别绝对路径和相对路径</h4><p>.表示当前目录；..表示上一级目录；</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>了解完这章的内容之后，现在对于Linux有了一个新的认识，特别是文件的权限设置，个人感觉还是挺有意思的。还有对文件目录的结构也有了基本认识，对于每个文件夹有了大概的了解，纠正了对usr的认识，其实不是user的缩写，而是UNIX Software Resource的缩写。</p>]]></content>
      
      
      <categories>
          
          <category> Linux系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习随笔01：聊聊常用的命令帮助方法</title>
      <link href="/2023/11/16/Linux%E7%B3%BB%E7%BB%9F%EF%BC%9A%E8%81%8A%E8%81%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E5%B8%AE%E5%8A%A9%E6%96%B9%E6%B3%95/"/>
      <url>/2023/11/16/Linux%E7%B3%BB%E7%BB%9F%EF%BC%9A%E8%81%8A%E8%81%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E5%B8%AE%E5%8A%A9%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>众所周知Linux操作系统由于其优越的稳定性和可移植性目前已经广泛应用于计算机以及嵌入式领域。而Linux系统相比于Windows操作系统最大的差别就是无桌面化，整个操作全部以命令行的形式在终端输入。这么多的命令让每个人死记硬背显然不现实，如何高效地使用已有的方式帮助我们输入正确的命令是我们的关注点，这篇中，我们就一起聊聊聊常用的命令帮助方法</p><span id="more"></span><h3 id="命令的格式"><a href="#命令的格式" class="headerlink" title="命令的格式"></a>命令的格式</h3><p>Linux命令中，其基本的格式如下：<br>[dmtsai@study ~]$   command     [-options]     parameter1    parameter2<br>其中command表示我们要做什么事情，例如ls(list)列出当前目录中的所有文件，parameter1    parameter2代表我们要做这件事情的对象，也就是要列出什么路径下的文件，在一些其他命令中，还需要 [-options] 的配合。需要注意的有以下几点：</p><ol><li>在输入命令中，要区别大小写</li><li>命令和参数之间采用空格进行隔开，几个空格无所谓</li><li>在输入命令时善用TAB（补全）、Ctrl-c（中断目前操作）、Ctrl-d（键盘输入结束）、[shift]+{[pageup][pagedown]}</li></ol><h3 id="whatis"><a href="#whatis" class="headerlink" title="whatis"></a>whatis</h3><p>如果记得一个命令，但是不知道这个命令能够做什么用，可以直接使用whatis [command],执行后会列出这个命令相关的含义。需要注意的是whatis中间没有空格，另外在使用之前需要建立whatis数据库，方法为切换至root用户，输入mandb即可。<br><img src="https://i.loli.net/2021/10/29/vEMozldnUwiJcCH.png" alt="image.png"></p><h3 id="–help"><a href="#–help" class="headerlink" title="–help"></a>–help</h3><p>–help命令主要用于查看这个命令后面的其他相关的参数和选项，通过它对这个命令有一个大致的了解。在这个里面，我们可以看到这个命令后面接的所有参数，并且对每个选项也做个详细说明，是一个比较好用的方法。<br><img src="https://i.loli.net/2021/10/29/TCK2xJvyWm64i3Z.png" alt="image.png"></p><h3 id="man-page"><a href="#man-page" class="headerlink" title="man page"></a>man page</h3><p>如果前面的help还没有帮助你找到合适的答案，那么这个man方法绝对可以帮助你。man是manual手册的英文缩写，其使用的方法就是man [command]，它就会列出这个命令的使用时手册。在这个手册中有对这个命令的介绍和一些相关的语法。在man的环境中，空格键可以实现翻页、&#x2F;[word]可以实现找到这个字符在这个手册中、q代表退出。还有一个与之相似的info page这里就不做介绍了，两者相差不大。<br><img src="https://i.loli.net/2021/10/29/7cdnOR1xNDGFotI.png" alt="image.png"></p><h3 id="帮助文档"><a href="#帮助文档" class="headerlink" title="帮助文档"></a>帮助文档</h3><p>还有一个就是帮助文档，一般的命令都有一份帮助文档，这份文档常常存在于&#x2F;usr&#x2F;share&#x2F;doc这个文件目录中。<br><img src="https://i.loli.net/2021/10/29/7FGWnQHxYCNieDr.png" alt="image.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是常用的几种命令帮助方式，除此之外，Linux中还有一个运行级别的说法和终端界面的说法。所谓的运行级别就是linux在不同环境中运行不同的服务，一共有0-6个运行级别，其中1代表关机、6代表重启、3代表无界面现实、5代表启动X界面服务。所涉及的命令有runlevel(查看当前运行级别)、init [级别号]切换到这个级别中。而终端界面就是每个运行级别的入口，一共tty1-6。每个运行级别都有这6个终端界面。</p>]]></content>
      
      
      <categories>
          
          <category> Linux系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DWIN屏使用方法总结（下）</title>
      <link href="/2023/11/16/%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91%EF%BC%9ADWIN%E5%B1%8F%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8B/"/>
      <url>/2023/11/16/%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91%EF%BC%9ADWIN%E5%B1%8F%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<p>上一篇关于DWIN屏的总结学习中，描述了什么是DWIN屏以及这类串口屏幕在实际开发中的流程、相比于传统的LCD屏幕，这种屏幕有什么好的优点等等。这一篇呢，就是在上一篇的基础之上，对于屏幕在使用中的常用控件做简单的介绍，并阐述下用单片机程序如何解析与之相关的控件信息。</p><span id="more"></span><h3 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h3><p>屏幕默认选择串口2与外部设备进行通讯，在串行通讯的参数为：波特率&#x2F;115200 数据位&#x2F;8 奇偶校验&#x2F;无。在通讯过程中，采用的数据帧格式为：</p><table><thead><tr><th align="center">数据块</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th></tr></thead><tbody><tr><td align="center">定义</td><td align="center">帧头</td><td align="center">数据长度</td><td align="center">指令</td><td align="center">数据</td><td align="center">CRC校验</td></tr><tr><td align="center">长度</td><td align="center">2</td><td align="center">1</td><td align="center">1</td><td align="center">&lt;&#x3D;249</td><td align="center">2</td></tr><tr><td align="center">说明</td><td align="center">0x5aa5</td><td align="center">指令+数据+CRC字节数</td><td align="center">0x82&#x2F;83写&#x2F;读</td><td align="center">用户命名</td><td align="center">CRC-16(x16+x15+x2+1)</td></tr></tbody></table><p>对于上述的数据帧来讲，一般来讲，不用开启CRC校验，另外在数据方面，详细的格式如下：<br><img src="https://i.loli.net/2021/08/15/gRIZ2AwsTiKQaDN.png" alt="image.png"><br>写的话就是目的变量空间地址+要写的数据，读的话就是读什么变量地址空间+读数据的长度。<br>举例说明<br>例如：发送5A A5 04 83 0014 01 收到5A A5 06 83 00 14 01 00 01；0001为页面ID。解析该发送指令如下：其中5A A5为固定的帧头，04代表指令+数据一共4个字节，指令83代表读，就是从变量地址中读数据，0014代表要读哪个变量地址，01表示：从0014 地址开始读 1 个字长度.返回的指令中附加的0001代表着当前的页面ID。</p><h4 id="常用的系统指令"><a href="#常用的系统指令" class="headerlink" title="常用的系统指令"></a>常用的系统指令</h4><ul><li>T5L复位：5A A5 07 82 0004 55AA 5AA5</li><li>读页面ID：5A A5 04 83 0014 01</li><li>开启触摸上传：5A A5 07 82 0080 5A 00 00 38，注意掉电失效</li><li>页面切换：5A A5 07 82 00845A010001，0001代表要切换的ID</li><li>读系统配置：5A A5 04 83 0080 02</li></ul><p>常用的系统指令大概也就以上几个，详细的请参考开发手册指南。</p><h3 id="常用控件"><a href="#常用控件" class="headerlink" title="常用控件"></a>常用控件</h3><h4 id="基础触控"><a href="#基础触控" class="headerlink" title="基础触控"></a>基础触控</h4><p>基础触控相对来讲是一个比较简单的控件，主要的功能就是进行页面间的切换，不会产生返回值，没有相对应的变量地址空间，所以不能进行响应的读写。常用的案例就是导航栏的制作，在右面属性中，选择相应的背景ID，点击该触控区域后，即可切换到相应的ID界面。<br><img src="https://i.loli.net/2021/08/15/IAyW5SbdHcCBw3g.png" alt="image.png"></p><h4 id="按键返回"><a href="#按键返回" class="headerlink" title="按键返回"></a>按键返回</h4><p>按键返回和基础触控很不相同，按键返回有自己的变量地址和变量地址中放的键值。勾选数据自动上传后，前提还要在系统的配置中开启数据自动上传，然后当我们点击该按键时，串口就会将该变量地址空间中存放的键值发送出来，图片中发出的指令为：5A A5 05 83 5346 0001.<br><img src="https://i.loli.net/2021/08/15/2etfMRvTzaGPdZJ.png" alt="image.png"><br>在程序中，就可以开启串口的接收中断，当接收到一帧数据后，对数据进行判断，主要是判断变量地址控制和相应的键值，来确定哪个按键按下。一般在设计当中，对于按键返回变量地址设置一样，判断返回的键值来确定哪个按键按下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span>(rxbuffer[<span class="number">4</span>] == <span class="number">0x20</span> &amp;&amp; rxbuffer[<span class="number">5</span>] == <span class="number">0x00</span>)  <span class="comment">//按键返回</span></span><br><span class="line">&#123;  </span><br><span class="line"> <span class="keyword">switch</span>( rxbuffer[<span class="number">8</span>])</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0x10</span>:    <span class="comment">//按键10</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* User Code*/</span>  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">0x20</span>:    <span class="comment">//按键20</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* User Code*/</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据变量录入"><a href="#数据变量录入" class="headerlink" title="数据变量录入"></a>数据变量录入</h4><p>数据变量的录入其实和按键返回有相似的地方，但是也有不一样的地方。变量录入不仅要加载DataInput的标签，而且需要加载一个变量显示的控件，变量的录入可以使用键盘，前提是键盘需要提前PS设计好。另外变量录入控件中的变量地址也就是你要把数据写到什么地方的地址，如果选中了数据自动上传，那么当这个变量地址中的数据发生变化时，该控件就会将这个变量地址中的数据通过串口发送出来。具体配置见下面图片设置。<br><img src="https://i.loli.net/2021/08/15/8CDuh2rJHkmPTWo.png" alt="image.png"></p><h4 id="图标变量"><a href="#图标变量" class="headerlink" title="图标变量"></a>图标变量</h4><p>在UI界面中，如果想用更加华丽的效果展示，那就可以试试采用变量图标的这种形式。这种形式的前提在于你要提前利用PS将需要展示的图标设计好，然后生成48开头的图标文件。在背景图片中加载一个变量图标显示控件，在控件右侧的属性中，填写该控件的地址以及变化的范围。注意这两个值变量地址和返回是非常重要的。如果我们后续想更改这个控件图标的显示，只需要对该地址写入对应图标的键值即可。详细的指令为：0x5A,0xA5,0x05,0x82，0x3002,0x0001-0x0001.<br><img src="https://i.loli.net/2021/08/15/CvGailLNF3t589X.png" alt="image.png"></p><h4 id="数据变量显示"><a href="#数据变量显示" class="headerlink" title="数据变量显示"></a>数据变量显示</h4><p>数据变量其实和变量图标差不多，图标变量需要指定也就是定义好键值对应的图标，而数据变量则是选择对应的字库，选择好要显示的位数等信息，同样的，数据变量也有相应的地址，通过相应的写入指令，在该地址中写入指定的值，即可显示相应的值。举例为：5A A5 05 82 54 20 00 12,将会在5420地址所对应的控件中显示0012.<br><img src="https://i.loli.net/2021/08/15/q9vBckxNFR2IfbZ.png" alt="image.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是目前来讲，我使用DWIN屏幕设计开发过程中的学习心得，明显能够感觉到使用DWIN屏幕开发越来越熟练，开发的效率和效果也越来越好。以上这些总结，希望在自己下次开发如果忘记了，能够快速回忆起来。</p>]]></content>
      
      
      <categories>
          
          <category> 裸机开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 串口屏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DWIN屏使用方法总结（上）</title>
      <link href="/2023/11/16/%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91%EF%BC%9ADWIN%E5%B1%8F%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8A/"/>
      <url>/2023/11/16/%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91%EF%BC%9ADWIN%E5%B1%8F%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<p>DWIN屏的使用应该有一段时间了，期间使用它开发完成了两个项目。在项目中的显示交互部分均采用了DWIN屏，对于DWIN屏这种开发模式有了大概的了解，所以做一个总结，增加自己这方面的认知。</p><span id="more"></span><h3 id="DWIN屏介绍"><a href="#DWIN屏介绍" class="headerlink" title="DWIN屏介绍"></a>DWIN屏介绍</h3><p>DWIN屏主要是用于一些工业上的人机界面交互，内部含有存储器，可以通过开发软件开发出符合要求的界面和展示效果。采用的通讯方式为串口通讯，所以也被称为串口屏，依据官方屏幕型号提供的手册，通过串口发送相应的指令即可达到相应的显示效果。DWIN屏的开发大致有两种模式，第一种是利用屏幕内部的处理芯片进行开发，一般不采用；另外的一种模式就是作为系统的一个单独模块进行使用，通信采用模块提供的串口通讯。一般采用第二种方式进行开发。两次项目所采用的屏幕型号均为：DMG48480C040-03WTC，属于方形4寸IPS电容触摸屏。除此之外，还有IPS无触摸DMG48480C040-03WN和IPS电阻触摸DMG48480C040-03WTR的型号。<br><img src="https://i.loli.net/2021/08/11/uGBUYCMyrOXf98A.png" alt="image.png"><br>关于该型号屏幕的详细参数如下：分辨率480*480,采用LED背光，工作电压5V，工作电流220mA,串口模式N81，用户接口方式10Pin_1.0mm FCC软排线，拥有16M字节的FLASH存储器，其中字库存储空间4-12Mbytes,图片存储空间12-14Mbytes。屏幕出厂预装DGUSU II版本UI，处理芯片采用低功耗、高性价比、双核8051人机界面专用ASIC-T5L。官方提供的参考资料如下：</p><ol><li><a href="https://pan.baidu.com/s/18juBKHyaXzunLdDdht83Pg">T5L DGUSII应用开发指南</a>提取码：kolh;</li><li><a href="https://pan.baidu.com/s/1kj3FJsx1rWxZZsito3YYGw">T5L DGUSII应用文档</a> 提取码：pax5</li><li><a href="http://forum.dwin.com.cn/">迪文开发者论坛</a></li></ol><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>官网给出出的开发工具在不断的迭代更新，笔者使用的开发工具版本为V7.622，其下载链接为<a href="https://pan.baidu.com/s/1PGzCcNBCMfDm0VM9E-ui4A">DGUS_V7622</a>提取码：xjvx。<br><img src="https://i.loli.net/2021/08/14/kHpnvcbPeIAErVM.png" alt="image.png">，软件集成了与之相关的开发工具，里面最常用的就是DWIN ICL生成工具。</p><h4 id="ICL生成"><a href="#ICL生成" class="headerlink" title="ICL生成"></a>ICL生成</h4><p>DWIN ICL生成工具实际上就是将背景图片、图标生成icl格式的文件，通过将这些icl格式的文件下载到工程中，进行开发。普通的png或者其他格式的图片在屏幕的文件中是没有办法识别的，这就需要使用icl工具，将这些转换成icl可以识别的文件形式。具体的icl使用方法如下：<br><img src="https://i.loli.net/2021/08/15/ivYwQm74jqHKtNu.png" alt="image.png"><br>首先选择存放图标或者北京图片的文件夹，然后选择JPG图片质量设置成100%，点击全部设置，最后生成icl文件即可。在这里需要注意的是，如果你是生成背景图片的icl文件，请以32XX形式进行命名，如果你是生成图标的icl文件，请以48XX形式进行命名。这么命名的原因在于DWIM屏幕中的FLASH存储，文件命名前面的数字代表着文件的ID，系统根据文件的ID将这些不同功能的文件合理地存放在FLASH中，根据这个ID号，可以避免在同一个位置存放重叠的文件，从而导致系统错误，详细的空间分配，请参考手册。<br><img src="https://i.loli.net/2021/08/15/Bf4DEhp8mogQI9F.png" alt="image.png"></p><h4 id="CFG修改"><a href="#CFG修改" class="headerlink" title="CFG修改"></a>CFG修改</h4><p>CFG文件也就是系统屏幕的配置文件，通过二进制的格式进行书写，在文件下载过程中，可以下载修改后的配置文件从而修改系统的配置。修改配置文件的方法如下：<br><img src="https://i.loli.net/2021/08/15/NlJukQvUbWAxsZ7.png" alt="image.png"><br>首先选择CFG文件修改，然后选择新建CFG，将新建好的CFG文件保存到下载目录当中，然后选择需要修改的配置，在这里我们修改触控变量自动上传开启，最后保存到我们刚刚新建的配置文件中即可。</p><h3 id="工程建立与下载"><a href="#工程建立与下载" class="headerlink" title="工程建立与下载"></a>工程建立与下载</h3><h4 id="工程建立"><a href="#工程建立" class="headerlink" title="工程建立"></a>工程建立</h4><ol><li>首先需要新建一个文件夹，用于存放开发过程中与之相关的文件信息</li><li>打开DGUSII软件，选择新建，选择对应的分辨率，将工程保存到刚刚新建的文件夹中，如下图所示<br><img src="https://i.loli.net/2021/08/15/BAmQguylhqPcnUz.png" alt="image.png"></li><li>新建好工程之后，会生成4个文件夹和2个文件，其中以.hmi为后缀的文件为系统的工程文件，下次打开该工程时，直接打开该文件即可。4个文件目录中，DWIN_SET为主目录，开发软件生成的配置文件、图标触控、字符触控等都是直接生成在这个文件夹中，ICON和image文件用于存放工程中需要用到的图标和背景，注意需要将他们生成icl文件然后拷贝到DWIN_SET文件夹中。<br><img src="https://i.loli.net/2021/08/15/WxuAcGJVDm3U1Py.png" alt="image.png"></li><li>加载提前设计好的背景，进行工程的开发，背景加载完毕后，添加需要的控件，最常用的有变量图标显示、数字显示、以及文本输入、触控按钮等，最后在右侧进行对选中的控件进行属性设置，主要设置的是控件的地址以及相应的作动效果。<br><img src="https://i.loli.net/2021/08/15/hd9gtcH8FNyevK5.png" alt="image.png"></li><li>对工程进行预览，查看工程的地址信息，防止控件与控件之间地址产生冲突，其实解决冲突最好的办法就是在开发之前，对需要用到的控件先规划好他们的地址，在开发过程中，写入他们的地址即可。<br><img src="https://i.loli.net/2021/08/15/ItCpy76ilcmaDTJ.png" alt="image.png"></li><li>生成相应的配置文件，在生成配置文件中，会生成13触控配置文件、14变量配置文件以及22通用配置文件。</li></ol><h4 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h4><p>文件的下载首先需要准备SD卡，DWIN屏对SD卡的要求为：容量大小1-16G，格式为FAT32格式，需要注意的是一般我们右击进行格式化的SD卡并是不FAT32格式的，需要我们采用以下方法对SD卡进行格式化。</p><ol><li>开始&#x3D;》运行&#x3D;》输入command（win7系统则输入cmd）进入DOS系统</li><li>键入指令：format&#x2F;q g:&#x2F;fs:fat32&#x2F;a:4096（注：q后面是一个空格），输入完成之后点击回车按键。其中g是用户的电脑显示的SD卡的盘号，不同的用户对应的盘符是不固定的（比如h,i替换即可）<br><img src="https://i.loli.net/2021/08/15/X5LcgJpMtHFN9Tv.png" alt="image.png"><br>SD卡准备完成之后，需要在SD卡中新建一个文件夹，注意文件夹必须以<strong>DWIN_SET</strong>命名。然后将需要下载到屏幕的文件拷贝到该文件夹下，其中包含以下文件：<br><img src="https://i.loli.net/2021/08/15/cTrqC472sxAa5Ne.png" alt="image.png"><br>如果需要更改CFG文件，最后也需要将生成的CFG文件拷贝到这个文件夹中。最后就是文件的烧录了，注意先把屏幕断电，然后再把SD卡插入，上电后，系统会检测有无SD卡，如果右，则会蓝屏显示下载进度，当显示到XXend时，代表下载完成，断电拔出SD卡，上电后即可看到刚刚下载的效果。需要注意的是SD的下载过程千万不能进行热插拔！！<br><img src="https://i.loli.net/2021/08/15/okEYTe9t4CNJIAy.png" alt="image.png"></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在该文章中，首先对DWIN屏这类做了介绍，他们相对于传统的LCD屏幕开发起来更加的方便，直接使用控件+变量地址即可。然后对于DWIN屏幕有的整个开发过程做了简单的介绍，整体开发流程不是特别的复杂，最后对于开发过程中特别是文件的下载做了详细的记录。</p>]]></content>
      
      
      <categories>
          
          <category> 裸机开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 串口屏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记11：面向对象高级编程（1-5）</title>
      <link href="/2023/11/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(12)/"/>
      <url>/2023/11/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(12)/</url>
      
        <content type="html"><![CDATA[<p>本篇主要记录侯捷老师讲的C++ 面向对象高级编程课程1-5节的学习笔记和心得。</p><span id="more"></span><h3 id="杂碎知识点"><a href="#杂碎知识点" class="headerlink" title="杂碎知识点"></a>杂碎知识点</h3><ul><li>C++历史：起源于1983年，当时不叫C++，名字为C with class.</li><li>C++ 是第一个面向对象语言，也是效率方便比较高的语言，后面的Java C# 都属于面向对象语言</li><li>所谓的面向对象的意思就是不同于C语言的过程语言，C++将数据和方法进行整合在一起，组装成一个新的东西，这个新的东西就是Class.使用这个类可以去创建对象，使用类中的方法可以操作这个对象，这就是所谓的面向对象的思想。</li><li>目前最新的C++的版本为C++ 11，但是大部分人还是习惯在使用C++ 98这个版本。</li><li>推荐阅读的C++书籍，C++ Primer是第一个设计C++编译器的人写的，另外一个是创建C++语言的人写的。<br><img src="https://s2.loli.net/2022/04/05/Qbfq8XcPj2a9vmi.png" alt="image.png"></li></ul><h3 id="语法知识点"><a href="#语法知识点" class="headerlink" title="语法知识点"></a>语法知识点</h3><ul><li>C++的类分为两种形式，一种是带指针类型的，另外一种是不带指针类型的。</li><li>代码形式为由.h和.cpp两种文件组成，.h为头文件，头文件的类型分为两种，一种是自己写的，另外一种是标准库，如果.cpp文件要使用头文件，则需要引用，注意在这里对于自定义头文件以及标准库头文件引用方式不同，如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;complex.h&quot;</span>   <span class="comment">//自定义头文件引用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span>  <span class="comment">//标准库头文件引用</span></span></span><br></pre></td></tr></table></figure>区别就是一个使用引号，一个使用尖括号，文件名的.h后缀可以去掉。</li><li>对于自己定义的头文件，请严格按照以下格式<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _COMPLEX_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _COMPLEX_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Code */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>这种格式的好处就是如果多个文件都引用一个头文件，则该头文件只会定义一次，避免了重复的代码段。</li><li>一类分为两个部分，分别为body和head,类的定义以及声明都是在头文件中完成的，具体一个类可以分为以下几个部分<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _COMPLEX_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _COMPLEX_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="comment">/*  第一部分：前置声明区 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ostream</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//如果不确定变量的特性可以使用模板的概念</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/*  第二部分：类声明 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123;            <span class="comment">// class head: complex</span></span><br><span class="line">   <span class="comment">//body</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">       <span class="comment">/* code */</span></span><br><span class="line">       ...</span><br><span class="line"><span class="keyword">friend</span>  <span class="comment">/* code */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  第三部分：类的定义 */</span></span><br><span class="line">complex :: function ...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>body里面又可以分为三个部分，一个是Public公共也就是可以让外界访问，即对象使用的一些方法；另外一个是Private私有部分只有这个类中的成员可以访问，一般里面放的是数据；最后一部分为friend部分，它的特性就是可以访问Private。</li><li>构造函数具有的几个特性<ol><li>构造函数的名称需要和类的名称相同</li><li>在对象声明时可以传入参数，如果没有传入参数，则使用构造函数的默认值</li><li>无任何的返回类型</li><li>要使用Initialization list的功能去对变量进行赋值</li><li>构造函数可以有多个重载，编译器编译时会将输入值一同和函数名称编译，其区分重载函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span> (<span class="type">double</span> r=<span class="number">0</span>,<span class="type">double</span> i=<span class="number">0</span>)</span><br><span class="line">    : <span class="built_in">re</span>(r),<span class="built_in">im</span>(i)  <span class="comment">//re im 为初始化的私有变量</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li>const 字符的含义就是不改变传入的数据数值，如果前面加上const字符，则该函数不可以更改变量，这个的使用要根据具体的情况而来。</li><li>参数传入的两种形式：pass by value vs pass by reference<ol><li>传入的数据reference的形式为 加上&amp;符号</li><li>如果可以，尽量使用reference传递数值，因为reference相当于C语言中的指针，传递数值的速度快。</li><li>value适合于local var或者临时变量的这种情况。</li></ol></li><li>参数值返回的两种形式和输入形式相同<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">complex&amp; <span class="keyword">operator</span> +=(<span class="type">const</span> complex&amp;); <span class="comment">//reference形式的传入和返回</span></span><br></pre></td></tr></table></figure></li><li>相同class的objects互为友元函数</li><li>操作符重载<ol><li>成员函数会有一个默认的this，不是成员函数没有this</li><li>传递者不需要知道接收者是怎么接受的</li><li>所谓的操作符重载就是对已知的符号根据自身类的特性进行特殊话，例如输出复数的《，以及复数的+-<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作符重载的例子</span></span><br><span class="line"><span class="keyword">inline</span> complex</span><br><span class="line"><span class="keyword">operator</span> + (<span class="type">const</span> complex&amp; x, <span class="type">const</span> complex&amp; y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">complex</span> (<span class="built_in">real</span> (x) + <span class="built_in">real</span> (y),</span><br><span class="line"><span class="built_in">imag</span> (x) + <span class="built_in">imag</span> (y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记11：类和动态内存分配</title>
      <link href="/2023/11/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(11)/"/>
      <url>/2023/11/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(11)/</url>
      
        <content type="html"><![CDATA[<p>经过了短暂的清明假期之后，又回到了实验室，继续开始了C++的学习，不得不说清明节出去人真多，还是在校学习知识，每天进步一点点有成就感。好了，不说这么多废话了，今天开始学习C++中很关键的类和动态内存分配。在这一章中，将要掌握对类成员进行动态内存分配，了解赋值和复制构造函数等等。</p><span id="more"></span><h3 id="动态内存和类"><a href="#动态内存和类" class="headerlink" title="动态内存和类"></a>动态内存和类</h3><p>所谓动态内存的一些概念在之前已经了解过，使用动态你内存可以更好的存储数据。之前的动态内存只是用在普通的变量上，那么对于类，这种面向对象编程中，最重要的变量，如何使用动态内存对其进行管理呢，这个就是今天的关键。</p><h4 id="复习示例和静态类成员"><a href="#复习示例和静态类成员" class="headerlink" title="复习示例和静态类成员"></a>复习示例和静态类成员</h4><p>有如下的示例，在对于C++的构造函数和析构函数使用new和delete进行内存管理，并且使用静态变量来对构造函数和析构函数调用的次数进行统计。主要程序代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------------------------------</span><br><span class="line">StringBad::<span class="built_in">StringBad</span>(<span class="type">const</span> <span class="type">char</span> * s)   <span class="comment">//自定义构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    len = std::<span class="built_in">strlen</span>(s);             <span class="comment">// set size</span></span><br><span class="line">    str = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];          <span class="comment">// allot storage  使用new</span></span><br><span class="line">    std::<span class="built_in">strcpy</span>(str, s);              <span class="comment">// initialize pointer</span></span><br><span class="line">    num_strings++;                    <span class="comment">// set object count</span></span><br><span class="line">    cout &lt;&lt; num_strings &lt;&lt; <span class="string">&quot;: \&quot;&quot;</span> &lt;&lt; str</span><br><span class="line">         &lt;&lt; <span class="string">&quot;\&quot; object created\n&quot;</span>;    <span class="comment">// For Your Information</span></span><br><span class="line">&#125;</span><br><span class="line">StringBad::~<span class="built_in">StringBad</span>()               <span class="comment">// necessary destructor    //自定义析构函数</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\&quot; object deleted, &quot;</span>;    <span class="comment">// FYI</span></span><br><span class="line">    --num_strings;                    <span class="comment">// required</span></span><br><span class="line">    cout &lt;&lt; num_strings &lt;&lt; <span class="string">&quot; left\n&quot;</span>; <span class="comment">// FYI</span></span><br><span class="line">    <span class="keyword">delete</span> [] str;                    <span class="comment">// required</span></span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"> <span class="built_in">callme2</span>(headline2);    <span class="comment">//按值传递headline2</span></span><br><span class="line"> StringBad sailor = sports;    <span class="comment">//等效于 StringBad sailor = StringBad（sports);</span></span><br></pre></td></tr></table></figure><p>程序中声明了一个StringBad的类，在类中声明了两个构造函数，一个是采用指针传递数据，故用到new分配内存，另外一个是默认的构造函数。还声明了析构函数。在程序执行过程后，输出出现了乱码和num_strings静态变量等于-2的现象。分析可以发现程序中有一个按值传递的语句，对于程序中，如果按值传递则会导致析构函数被调用。另外还发现在使用一个对象来初始化另外一个对象时，编译器自动生成了一个复制构造函数。所以造成了上面乱码和计数错误的结果。</p><h4 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h4><p>复制构造函数也是C++中自动提供的一类函数，用于将一个对象复制到新创建的对象中。常用于初始化当中。在新建一个对象并将其初始化同类对象时，复制构造函数都将使用。在进行按值传递时，复制函数也是要被调用的。对于上面示例出现的问题，对于静态变量变成-2主要是因为在按值传递和对象复制过程中使用了默认的复制构造函数，而默认的复制构造函数并不对静态变量num_strings进行修改，但是析构函数更新了计数，所以出现了-2.另外的一个问题是乱码，原因则在于析构函数释放了已经释放的内存，这将造成很大的不确定性。<br>发现了问题之后，如何去优化这些问题呢，首先我们可以定义一个显式的复制构造函数，在函数中，对静态变量进行加1操作，同时要进行深度复制，应当复制字符串并将副本的地址赋给str成员，而不是仅仅复制字符串地址。这样析构函数就可以去释放不同字符串占用的地址。</p><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>示例程序中的问题也有一部分是赋值运算符造成的，C++中是有默认的赋值运算符的，在声明一个新的对象并进行赋值时，都将调用赋值运算符。使用默认的赋值运算符在调用析构函数时释放了已经释放的内存，所以造成乱码和一系列不确定性。为了解决这个问题，我们需要重新声明赋值运算符的程序，从新编写后的重载赋值运算符程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String &amp; String::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span> * s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] str;</span><br><span class="line">    len = std::<span class="built_in">strlen</span>(s);</span><br><span class="line">    str = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">    std::<span class="built_in">strcpy</span>(str, s);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在构造函数中使用new时注意的事项"><a href="#在构造函数中使用new时注意的事项" class="headerlink" title="在构造函数中使用new时注意的事项"></a>在构造函数中使用new时注意的事项</h3><p>在构造函数中使用new时需要注意以下几个方面</p><ul><li>要将new和delete配合使用，如果使用new[]那么则应该使用delete []进行释放</li><li>如果有多个构造函数，那么这些构造函数应该以相同的方式使用new</li><li>应定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象</li><li>应定义一个赋值运算符，通过深度赋值将一个对象复制给另外一个对象</li></ul><h3 id="有关返回对象的说明"><a href="#有关返回对象的说明" class="headerlink" title="有关返回对象的说明"></a>有关返回对象的说明</h3><p>成员函数或独立的函数返回对象时，有几种返回方法进行使用，第一种是可以返回指向对象的引用、指向对象的const引用和const对象。指向对象的const引用可以提高效率，使用的场景为比较两个对象；返回指向非const对象的引用，常用于重载赋值运算符以及重载与count一起使用的&lt;&lt;运算符。如果被赶返回的对象是被调用的函数中的局部变量，则不用使用引用的方式，应该按照返回对象的方式。</p><h3 id="使用指向对象的指针"><a href="#使用指向对象的指针" class="headerlink" title="使用指向对象的指针"></a>使用指向对象的指针</h3><p>在使用对象指针时，需要注意以下几点</p><ul><li>使用常规表示法来声明指向对象的指针</li><li>可以将指针初始化为指向已有的对象</li><li>可以使用new来初始化指针，这将创建一个新的对象</li><li>对类使用new将调用相应的类构造函数来初始化新创建的对象</li><li>可以使用-&gt;运算符通过指针访问类方法</li><li>可以对对象指针应用解除引用运算符（*）来获得变量</li></ul><h3 id="队列模拟"><a href="#队列模拟" class="headerlink" title="队列模拟"></a>队列模拟</h3><p>队列是一种抽象的数据类型，可以存储有序的项目数列，新的项目添加在结尾，使用完的项目从首删除。队列有点像栈，但是和栈的方式还是有些差别，栈是采用先进后出的方式。而队列则是采用先进先出的方式。在设计队列时，首先进行队列接口的定义，在定义好接口之后，需要采用一种方式进行实现，通常采用链表的方式可以很好的实现。因为链表中 每个结点都只包含一个指向其他节点的指针，知道第一个节点后，便可以沿着指针找到后面的节点，通常链表的最后一个节点中的指针被设置为NULL</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本章节涉及的内容有些复杂和难以理解，不过没有关系，在这里先做一个大概面的知道，等到以后详细使用到里面某个技术时。再做详细研究。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记10：使用类</title>
      <link href="/2023/11/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(10)/"/>
      <url>/2023/11/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(10)/</url>
      
        <content type="html"><![CDATA[<p>在上篇文章中，对类的声明进行了阐述，包含私有部分和公有部分，并且对面向对象编程进了探讨。这一篇文章将介绍友元函数、常见运算符的重载以及类的自动转换和强制类型转换等。</p><span id="more"></span><p>学习C++其实最大的困难现在随着学习内容的深入，也逐渐显露出来，就是C++需要您记录很多的东西。然后对于一个初学者并且没有经验的人来讲，要去记这些东西显然有些不现实。其实学习C++不是要用C++中所有的特性，而是要轻松地使用这门语言。</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>前面提到过函数重载，函数重载是指两个函数的名字是一致的，但是函数的入口参数和返回类型是不同的。程序会对这些函数进行重载。相比于函数重载，这里提出了运算符重载，允许C++的运算符有多种含义，例如*既可以表示地址，也可以表示两个数相乘，程序根据上下的关系情况进行判定。</p><h4 id="运算符实例"><a href="#运算符实例" class="headerlink" title="运算符实例"></a>运算符实例</h4><p>现在有一个实例，是计算时间问题，时间包含分钟和小时两部分。通过相应的类成员函数相加求和。首先程序声明类并且对编写成员函数。在没有使用重载运算符的情况下，采用下面的代码进行求和运算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">const</span> Time <span class="title">Sum</span><span class="params">(<span class="type">const</span> Time &amp; t)</span> <span class="type">const</span></span>;    <span class="comment">//在类中声明这个成员函数</span></span><br><span class="line"> ---------------------------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="type">const</span> Time <span class="title">Time::Sum</span><span class="params">(<span class="type">const</span> Time &amp; t)</span> <span class="type">const</span>     <span class="comment">//对成员函数编写代码</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Time sum;      </span><br><span class="line">    sum.minutes = minutes + t.minutes;</span><br><span class="line">    sum.hours = hours + t.hours + sum.minutes / <span class="number">60</span>;</span><br><span class="line">    sum.minutes %= <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"> total = coding.<span class="built_in">Sum</span>(fixing);      <span class="comment">//使用该成员函数将coding对象和fixing对象相加</span></span><br></pre></td></tr></table></figure><p>如果没有成员运算符，我们可以根据上面的代码进行求和运算，其中函数返回的应该是类，而不是引用，如果是引用则是sum的临时变量，所以返回量的声明必须是一个类。入口参数是引用，而不是按值传递，这么做的原因在于提高效率。下面为程序添加加法运算符，更改后的程序代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Time <span class="keyword">operator</span>+(<span class="type">const</span> Time &amp; t) <span class="type">const</span>;    <span class="comment">//在类中声明这个成员函数</span></span><br><span class="line"> ---------------------------------------------------------------------------------</span><br><span class="line">Time Time::<span class="keyword">operator</span>+(<span class="type">const</span> Time &amp; t) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Time sum;</span><br><span class="line">    sum.minutes = minutes + t.minutes;</span><br><span class="line">    sum.hours = hours + t.hours + sum.minutes / <span class="number">60</span>;</span><br><span class="line">    sum.minutes %= <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"> total = coding + fixing;     <span class="comment">//coding和fixing相加</span></span><br><span class="line"> total = morefixing.<span class="keyword">operator</span>+(total);   <span class="comment">//fixing和total相加</span></span><br></pre></td></tr></table></figure><p>运算符重载的一般格式为operator+()重载+运算符。operator是必须的，后面的是重载之后的符号。在使用过程中，既可以简单使用+符号进行运算，也可以使用原有的.格式。</p><h4 id="重载限制"><a href="#重载限制" class="headerlink" title="重载限制"></a>重载限制</h4><p>下面来说一下重载限制问题,主要几点如下：</p><ul><li>重载后的运算符必须至少有一个操作数是用户定义的类型</li><li>使用运算符时不能违反原有的语句规则</li><li>不能创建新的运算符</li><li>不能重载一些特殊的运算符，例如：sizeof等</li></ul><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><h4 id="为什么需要友元函数"><a href="#为什么需要友元函数" class="headerlink" title="为什么需要友元函数"></a>为什么需要友元函数</h4><p>为探讨这个话题，我们可以看以下乘法运算符的重载问题，其乘法运算符的相关程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Time <span class="keyword">operator</span>*(<span class="type">double</span> n) <span class="type">const</span>;    <span class="comment">//在类中声明这个成员函数</span></span><br><span class="line"> ---------------------------------------------------------------------------------</span><br><span class="line">Time Time::<span class="keyword">operator</span>*(<span class="type">double</span> mult) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Time result;</span><br><span class="line">    <span class="type">long</span> totalminutes = hours * mult * <span class="number">60</span> + minutes * mult;</span><br><span class="line">    result.hours = totalminutes / <span class="number">60</span>;</span><br><span class="line">    result.minutes = totalminutes % <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line">adjusted = total * <span class="number">1.5</span>;      <span class="comment">// use operator+()</span></span><br></pre></td></tr></table></figure><p>这个乘法运算有一个问题，以上的写法可以实现total乘以1.5，但是如果反过来写1.5*total那么程序计算的结构将出现问题，为什么有这个问题呢，因为在对成员函数定义时，左侧的操作数是调用的对象，但是2.75不是对象，所以会出现问题。解决这个问题有两种方案，一种是提前告知程序员，让程序员在编写程序时遵循这种方式，另外一种是使用非成员函数。但是非成员函数是无法访问隐藏变量的，这时C++提供了一种新的函数类型，这种函数被称为友元函数。</p><h4 id="创建友元函数并使用"><a href="#创建友元函数并使用" class="headerlink" title="创建友元函数并使用"></a>创建友元函数并使用</h4><p>创建友元函数的第一步是将其原型放在类声明中，并且在原型中加上关键词friend,第二步是编写函数，因为不是成员函数，所以不需要使用Time::限定符，另外不需要再定义中使用关键词friend.最后就是使用友元函数。例如下面的乘法运算符重载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> Time <span class="keyword">operator</span> * (<span class="type">double</span> m,<span class="type">const</span> Time &amp; t);   <span class="comment">//声明</span></span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line">Time <span class="keyword">operator</span>*(<span class="type">double</span> m,<span class="type">const</span> Time &amp; t)     <span class="comment">//函数原型</span></span><br><span class="line">&#123;</span><br><span class="line">    Time result;</span><br><span class="line">    <span class="type">long</span> totalminutes = t.hours * mult * <span class="number">60</span> + t.minutes * mult;</span><br><span class="line">    result.hours = totalminutes / <span class="number">60</span>;</span><br><span class="line">    result.minutes = totalminutes % <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line">adjusted =  <span class="number">1.5</span> * total;      <span class="comment">// 有效运算</span></span><br></pre></td></tr></table></figure><h3 id="类的自动转换和强制转换"><a href="#类的自动转换和强制转换" class="headerlink" title="类的自动转换和强制转换"></a>类的自动转换和强制转换</h3><p>在类的使用过程中，经常需要对变量进行转换，有些变换是自动进行的，而有些转换是强制进行的。构造函数在对变量进行声明时，可以自动进行隐式转换。使用关键词explicit将关闭构造函数的隐式转换，只能进行显示转换。</p><h4 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h4><p>构造函数可以将数字转换成对象，但是如果将对象转换成数字，则采用转换函数。转换函数的一般定义格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">typeName</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>对于转换函数，需要注意以下几点：</p><ul><li>转换函数必须是类方法</li><li>转换函数不能指定返回类型</li><li>转换函数不能有参数</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇介绍了运算符重载、友元函数以及类型转换等问腿，对类的理解更加深了一步，学习完这些后，后面将继续以类为对象，学习类和动态内存分配。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记09：对象和类</title>
      <link href="/2023/11/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(09)/"/>
      <url>/2023/11/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(09)/</url>
      
        <content type="html"><![CDATA[<p>从这篇开始，就要学习C++当中最重要的一项了对象和类，面向对象编程是C++的优点，而类是面向对象的基础。这这篇文章中，将记录过程编程和面向对象编程、类概念以及怎么使用类等等。</p><span id="more"></span><h3 id="过程性编程和面向对象编程"><a href="#过程性编程和面向对象编程" class="headerlink" title="过程性编程和面向对象编程"></a>过程性编程和面向对象编程</h3><p>过程性编程和面向对象编程是两个不同的概念，其中过程性编程侧重的是要遵循的一些步骤，比如先干什么，后干什么，并采用相应的函数来执行这些步骤。而面向对象编程侧重的是数据，比如，程序需要哪些数据，需要这些数据的哪些特点，以及需要对这些数据执行哪些操作等等。</p><h3 id="抽象和类"><a href="#抽象和类" class="headerlink" title="抽象和类"></a>抽象和类</h3><h4 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h4><p>如果想使用类，首先需要在头文件中对类进行声明，下面是一种常见的类的声明方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stock</span>  <span class="comment">// class declaration</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    std::string company;</span><br><span class="line">    <span class="type">long</span> shares;</span><br><span class="line">    ....</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">acquire</span><span class="params">(<span class="type">const</span> std::string &amp; co, <span class="type">long</span> n, <span class="type">double</span> pr)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buy</span><span class="params">(<span class="type">long</span> num, <span class="type">double</span> price)</span></span>;</span><br><span class="line">    ....</span><br><span class="line">&#125;;    <span class="comment">// note semicolon at the end</span></span><br></pre></td></tr></table></figure><p>首先类的声明需要关键词class，这个是不能省略的。然后如上图所示，定义了类的一些变量和方法。可以使用方法对变量进行修改和访问。方法其实就函数，描述了类的一些细节。还有关键词private（可以省略）和public也是新的关键词，这两个关键词描述了对类成员的访问控制，使用类对象的程序都可以访问公有部分，但是不能访问私有部分，只有使用公有部分的函数才可以访问私有部分，或者使用友元函数。也就说如果你要修改shares这个变量，你不能再程序中直接修改，你需要先在公有部分中创建一个方法，然后使用这种方法修改。这样看上去比较繁琐，但是对数据来说，不易发生错误，这种对数据的保护在C++当中被称为数据隐藏。</p><h4 id="类的函数"><a href="#类的函数" class="headerlink" title="类的函数"></a>类的函数</h4><p>在声明类之后，要想使用类，必须还有一项工作就是对类的成员中的方法函数进行代码编写。编写的方法和常规函数没有太大的差异，但是有两点需要注意：</p><ul><li>定义成员函数时，使用作用域解析运算符（::）来标识函数所属的类</li><li>类定义可以访问类的private<br>类函数的代码常用编写结构如下所示：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stock::update</span> <span class="params">(<span class="type">double</span> price)</span>  <span class="comment">//（::）表示作用域是这个类，除了类其他地方没法使用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Share:&quot;</span> &lt;&lt; shares &lt;&lt; endl;   <span class="comment">//可以对隐藏部分的数据进行修改和访问</span></span><br><span class="line">      -----</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>其定义位于类声明中的函数都将自动称为内联函数</li></ul><h4 id="类的使用"><a href="#类的使用" class="headerlink" title="类的使用"></a>类的使用</h4><p>在对类进行声明和创造之后，便可以在程序中用类声明一个对象，例如Stock Katte,Katte这个就是一个对象，在面向对象编程中，可以使用类去声明不同的对象，程序会为这些声明的对象创建一定的内存，这些对象使用类的同一种方法和变量声明。对象使用成员函数和结构那部分类似，都是采用成员运算符（.）声明完成之后，便可以使用类的一些方法。</p><h3 id="类的构造函数和析构函数"><a href="#类的构造函数和析构函数" class="headerlink" title="类的构造函数和析构函数"></a>类的构造函数和析构函数</h3><h4 id="为啥有构造函数？"><a href="#为啥有构造函数？" class="headerlink" title="为啥有构造函数？"></a>为啥有构造函数？</h4><p>对于为啥有构造函数这个问题，我们首先要知道C++创建类的目标是什么，目标是希望使用类对象和标准类型一样（如int char类等），在标准型中，可以非常容易地对类进行初始化，但是在类对象中，由于类将数据进行隐藏，所以不能直接对数据进行初始化，只能通过成员函数进行初始化，那么C++就提供了一个专门的成员函数用于初始化，这个成员函数被称为构造函数。</p><h4 id="定义并使用构造函数"><a href="#定义并使用构造函数" class="headerlink" title="定义并使用构造函数"></a>定义并使用构造函数</h4><p>构造函数的定义和成员函数一样，需要作用域符号，函数的名称需要和类的名称一致，这样在程序运行中，将自动调用构造函数。但是有一定需要注意，在构造函数中的入口参数命名中，不能和类的变量命名一致。否则会出现错误。使用构造函数有隐式和显示两种方法。如果在程序中没有声明构造函数，则程序会使用默认的构造函数，默认的构造函数是空的。</p><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p>析构函数的作用在于当程序执行完毕之后，对剩余进行清理，比如在程序中使用new分配出了一块新的内存，程序执行完毕后，可以使用析构函数释放这个内存。注意析构函数的声明需要~符号加上类的名称。与构造函数不同的是，析构函数没有入口参数。因为析构函数不承担重要的工作，所以可以将它编写为不执行操作的函数。</p><h3 id="对象数组和类作用域"><a href="#对象数组和类作用域" class="headerlink" title="对象数组和类作用域"></a>对象数组和类作用域</h3><p>当用户需要创建同一个类的多个对象时，可以采用创建对象数据的这种方式，这种方式声明和标准类型数据声明相同，如下图所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stock mystuff[<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>如果希望成员函数对多个对象进行操作，可以将额外的对象作为参数传递给它。如果方法需要显式地引用调用它的对象，则可以使用this指针，由于this指针被设置为调用对象的地址，因此*this是该对象的别名。<br>类很适合用于描述ADT，公有成员函数接口提供了ADT描述的服务，类的私有部分和类方法代码提供了实现，这些实现对类的客户隐藏。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章讲述了类的从定义到编写再到使用的整个过程以及构造函数和析构函数等。类的方法是很重要的，也是区别C语言的关键。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记08：内存模型和名称空间</title>
      <link href="/2023/11/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(08)/"/>
      <url>/2023/11/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(08)/</url>
      
        <content type="html"><![CDATA[<p>在上一篇中，讲述了内联函数、函数重载以及函数模板等概念，学习完之后，对函数有了更加深刻的理解。今天再来学习下C++中的内存模型和名称空间问题，讨论下单独编译、存储持续性、作用域和链接性。</p><span id="more"></span><h3 id="单独编译"><a href="#单独编译" class="headerlink" title="单独编译"></a>单独编译</h3><p>所谓的单独编译就是将函数原型放在同一个文件中，将函数的源代码放在另外一个文件当中。这么做的目的一方面是使用更加方便，当多个程序使用相同的函数调用，则只需要将包含该调用函数的头文件即可使用该函数；另外一方面是如果修改一个函数的定义或者逻辑，只需要在该文件中修改即可。这种单独编译的思想在C中也存在。需要注意的几点是，在包含该头文件时，要用“cood.h”，而不是&lt;cood.h&gt;。这两种的区别在于前者的包含程序在项目目录中去搜寻该.h文件，而后者的包含则是在标准库中搜索该文件。还需要注意可能我们在两个文件中包含了相同的内容，这个时候，程序会报错，可以使用#idndef 和#endif方法来解决此问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#idndef COOD_H_</span></span><br><span class="line">....</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在首次调用该函数时，COOD_H_是没有定义的，这种情况下程序查看#idndef 和#endif<br>之间的内容，并读取定义COOD_H_的一行。如果相同文件中，再次遇到包含cood.h的代码，则程序则直接跳到#endif后面的一行去执行。</p><h3 id="存储持续性、作用域和链接性"><a href="#存储持续性、作用域和链接性" class="headerlink" title="存储持续性、作用域和链接性"></a>存储持续性、作用域和链接性</h3><h4 id="三种存储类型"><a href="#三种存储类型" class="headerlink" title="三种存储类型"></a>三种存储类型</h4><p>在前面了解到存储的类型有三种，分别是自动存储、静态存储以及动态存储。三者的区别在于数据在内存中占用有效的时间。对于自动存储，定义的变量和参数在程序开始执行其所属的函数时被创建，在程序执行完毕后被释放，静态存储就是在整个运行过程中都存在；动态存储则使用new和delete来管理内存，存储时间不一定。这里的持续性其实就是指数据在内存中占用的时间。</p><h4 id="作用域和链接性"><a href="#作用域和链接性" class="headerlink" title="作用域和链接性"></a>作用域和链接性</h4><p>作用域就是描述名称在文件内多大范围内可见，也就是数据的影响范围有多大。而链接性就是描述了名称如何在不同单元内进行共享。自动变量的名称没有链接性，因此不能实现共享。链接性不仅对于变量而言，对于函数也是如此，函数也具有它的链接性，函数的链接性大部分都是外部的。对于语言来讲，也具有链接性。</p><h4 id="自动存储持续性"><a href="#自动存储持续性" class="headerlink" title="自动存储持续性"></a>自动存储持续性</h4><p>如果在main函数当中定义了i,则程序会分配一定的内存给i.如果在子函数中也定义了一个i，那么在程序执行到这个函数时，以前的那个i会被隐藏，当前函数的i会分配一定的内存，当程序执行完毕后，该函数的i的内存会被释放。这两个i的变量其实是两个数据，并且互不影响；程序中采用一种特殊的方式管理自动存储变量，这种方式被称为栈，栈就是在程序执行之前先在内存中留出一块空间用于管理这种自动存储的数据，这块空间就被成为栈，栈采用后进先出的规则运行。</p><h4 id="静态持续变量"><a href="#静态持续变量" class="headerlink" title="静态持续变量"></a>静态持续变量</h4><p>C++为静态存储持续性变量提供了三种链接性，分别是外部连接性、内部连接性以及无连接性。对于外部连接性则是变量可以全局使用，在对变量进行声明时，采用全局变量声明的方式，对于内部连接性，则变量只能在该文件中使用，声明时采用关键字static，对于无连接性的变量，该变量只能在该代码块或者函数中使用，在声明时使用关键词static。在静态变量初始化时，如果没有定义，则程序默认为0，但是需要注意一点的是不可以将未知的数据赋值给变量。</p><h4 id="单定义规则"><a href="#单定义规则" class="headerlink" title="单定义规则"></a>单定义规则</h4><p>所谓的单定义规则就是变量只能在文件中定义一次，如果一个变量在一个文件中定义了一次，同时这个变量又字另外一个文件中定义了一次，这么做的话，程序会出现错误。那么如果另外那么文件想用这个变量该怎么办呢，则采用external的方法即可。</p><h4 id="说明符和限定符"><a href="#说明符和限定符" class="headerlink" title="说明符和限定符"></a>说明符和限定符</h4><p>存储的说明符主要包含auto、register、static、external、mutable等等，mutable关键词表明即使结构变量为const,其某个成员也可能被修改。限定符为cv-限定符const和voiatile。关键词voiatile表明，即使程序代码没有对内存单元进行修改，其值也可能发生变化。</p><h3 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h3><h4 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h4><ul><li>声明区域：可在其中进行声明的区域，例如可以在函数外面声明全局变量，这种声明区域为声明所在的文件</li><li>潜在作用域：指的是从声明点开始到声明区域的结尾这块区域</li></ul><h4 id="using声明和using编译指令"><a href="#using声明和using编译指令" class="headerlink" title="using声明和using编译指令"></a>using声明和using编译指令</h4><p>C++提供了两种机制，一种是using声明使特定的标识符可用，另外一种使using编译指令使名称空间可用。这样我们就不需要再每次使用名称时对其进行限定。using声明使一个名称可用，using编译指令使所用名称都可用。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Jill&#123;</span><br><span class="line">    <span class="type">double</span> fetch;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> fetch;   <span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> main &#123;</span><br><span class="line">    <span class="keyword">using</span> Jill :: fetch;   <span class="comment">//局部</span></span><br><span class="line">    cin &gt;&gt; fetch;      <span class="comment">//读取一个变量到JiLL:fetch中</span></span><br><span class="line">    cin &gt;&gt; :: fetch;   <span class="comment">//读取一个变量到全局fetch</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>名称空间允许定义一个可在其中声明标识符的命名区域，这样做的目的是减少名称冲突，尤其是当程序非常大，并且使用多个厂商代码是。可以通过使用作用域解析运算符、using声明或using编译指令来使名称空间中的标识符可用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇中主要记录了单独编译、数据存储以及名称空间的一些知识，要理解文件一般要单独存放单独编译，三种存储方式的区别，以及名称空间的使用方法。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记07：函数探幽</title>
      <link href="/2023/11/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(07)/"/>
      <url>/2023/11/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(07)/</url>
      
        <content type="html"><![CDATA[<p>从上一篇学习函数基本特点之后，对C++的函数有了一定的了解。但是C++函数还包含更多的内容，比如：内联函数、按引用传递变量、默认的参数值以及函数重载等等，这篇文章，将会逐个介绍。</p><span id="more"></span><h3 id="C-内联函数"><a href="#C-内联函数" class="headerlink" title="C++内联函数"></a>C++内联函数</h3><h4 id="常规函数运行机制"><a href="#常规函数运行机制" class="headerlink" title="常规函数运行机制"></a>常规函数运行机制</h4><p>函数分为常规函数和内联函数，这两类的主要区别不在于编写函数的方式，而在于函数在程序中执行的过程。其常规函数在程序中执行的大概流程为在对程序进行编译之后，会生成一系列的可执行文件（文件是一组组机器代码），之后操作系统将这些文件载入到计算机内存中，所以每条指令都有对应的地址。当程序执行时，遇到函数调用也就是常规函数，程序会先暂停主程序的执行，并存储函数调用之前的地址，将函数参数复制到堆栈当中。完成这些工作后，跳到调用函数的地址中，去执行调用函数，执行完毕后，再跳回之前的地址中，继续运行程序。由于程序中这样的来回跳跃，会产生一定的开销，从而造成效率降低。</p><h4 id="内联函数运行机制"><a href="#内联函数运行机制" class="headerlink" title="内联函数运行机制"></a>内联函数运行机制</h4><p>内联函数则针对上述常规函数的缺点，它的意义在于程序执行到函数调用时。不需要来回跳啊跳，直接运行调用函数。这么做优点在于相对提高了运行速度，缺点在于这种内联的方案将会占用一定的内存。应该根据程序的执行情况合适的选择使用常规函数，还是内联函数。如果执行代码的时间比处理函数来回跳跃的时间长，则采用内联函数只会节省一小部分时间，但是如果执行代码的时间不长，但是出来程序跳跃这种时间花的时间长，采用内联函数就会提升效率。</p><h4 id="内联函数使用方法"><a href="#内联函数使用方法" class="headerlink" title="内联函数使用方法"></a>内联函数使用方法</h4><p>在使用内联函数时，需要完成下列其中之一</p><ul><li>在函数声明前加关键字inline</li><li>在函数定义前加关键字inline<br>通常的做法是省略原型，将定义直接放在本应该提供原型的地方。如果C语言的宏执行了类似函数的功能，应该考虑将他们转换成C++的内联函数。</li></ul><h3 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h3><p>C++中有一种复合类型-引用变量，引用是已定义的变量的别名。在常规的按值传递过程中，传入的数据的副本，原始数据不会发生改变，而引用变量传入的是原始数组，这样在程序中处理复杂数据时提供快捷的处理手段。</p><h4 id="创建引用变量并使用"><a href="#创建引用变量并使用" class="headerlink" title="创建引用变量并使用"></a>创建引用变量并使用</h4><p>创建引用采用&amp;字符，这个字符本是用来取地址的一个符号，但是C++给它定义了另外一种含义，引用。其创建引用的大致结构为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rats;</span><br><span class="line"><span class="type">int</span> &amp; rodents = rats;</span><br></pre></td></tr></table></figure><p>这样就创建了一个引用，其rodents和rats属于等价的关系，在程序中，如果修改了rodents的值，其rats的值也会发生变化。另外可以将引用作为函数参数，之前都是按值传递，现在C++可以按引用传递，传递后如果函数修改了数值，那么原始的数值也会发生变化。但是如果程序员的意图只是传递数据，而不是更改数组，那么按引用传递可以使用const字符，即</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">refcube</span><span class="params">(<span class="type">const</span> <span class="type">double</span> %a)</span></span>;  <span class="comment">//a只是传递参数，原始数据不会改变</span></span><br></pre></td></tr></table></figure><h4 id="引用的一些属性和特点"><a href="#引用的一些属性和特点" class="headerlink" title="引用的一些属性和特点"></a>引用的一些属性和特点</h4><ul><li>引用和指针都可以改变原始数据的值，但是两者是由差别的，其差别在于引用必须在声明时进行初始化，而不像指针那样，先声明再赋值。引用更加接近const指针，必须在创建时进行初始化。一旦和某个量关联起来，将会一直效忠于它。</li><li>如果实参与引用参数不匹配，C++将会生成临时变量。临时变量可以阻止修改作为参数传递的变量</li><li>引用也可以和结构共同使用，可以将结构引入当做函数参数，也可以返回结构的引用，这么做会提供效率。</li><li>在返回引用时需要注意一点是，应避免返回函数终止时不再存在的内存单元引用。说白了就是你不能返回一个临时变量，也不能返回一个临时变量的指针。</li></ul><h3 id="默认参数和函数重载"><a href="#默认参数和函数重载" class="headerlink" title="默认参数和函数重载"></a>默认参数和函数重载</h3><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>默认参数就是在函数声明时，默认的一个参数，在后期可以对默认的参数进行修改，为程序提供了一种便捷的方式，在设计类时，可以减少定义的折构函数、方法以及方法重载的数量。</p><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>函数重载就是在程序中，可以由多个重名的函数，但是程序执行时，会根据实际的情况将他们分开。这里的时间情况可以是这个函数的入口参数以及函数返回值的类型，这些信息都可区别同名函数。注意在匹配函数时，并不区分const和非const变量。一般在函数执行相同任务，但使用不同形式的数据时，选择采用函数重载。</p><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>在程序中，如果我们遇到先定义了一个交换两个int值的函数，假设现在要交换double类型，一种方法是采用把之前的代码进行复制，另外一种方法则是选择函数模板，其函数模板的大致定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AnyType&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(AnyType &amp;a,AnyType &amp;a)</span></span>&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键词template typename是必须的，另外需要声明尖括号，类型名AnyType可以随意选择。注意使用函数模板生成可执行文件时，中间不包含函数模板，而是实际的函数，使用函数模板可以让程序更加可靠。</p><h4 id="显示具体化"><a href="#显示具体化" class="headerlink" title="显示具体化"></a>显示具体化</h4><p>在对结构操作时，如果我们要将整个结构进行交换可以选择使用函数模板，但是如果我们选择交换结构当中的某一个分量，我们可以选择使用显示具体化，当编译器找到与函数调用匹配的具体化定义时，将使用该定义，不再使用模板。</p><h4 id="函数版本选择"><a href="#函数版本选择" class="headerlink" title="函数版本选择"></a>函数版本选择</h4><p>在对应函数执行时，C++定义了一套策略，来选择优秀的函数。这个过程称为函数解析。其大致过程为创建候选函数列表，使用候选函数列表创建可行函数列表，确定是否为最佳可行函数。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章记录了C++函数中区别于C的一些新的特性，比如引用、内联函数以及函数重载等等，这些概念也是学习掌握C++的关键。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记06：C++的编程模块</title>
      <link href="/2023/11/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(06)/"/>
      <url>/2023/11/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(06)/</url>
      
        <content type="html"><![CDATA[<p>在学习完基本的逻辑条件处理语句后，下面就开始探索在C++中的编程模块，在这篇文章中记录了关于函数的一些知识，比如函数和数组、函数和字符串等等。</p><span id="more"></span><h3 id="函数的基本知识"><a href="#函数的基本知识" class="headerlink" title="函数的基本知识"></a>函数的基本知识</h3><p>无论对于基本的库函数还是自己定义的函数，在使用前，我们必须要完成提供函数的定义、提供函数的原型。只有这样，在程序中才可以调用函数。函数可以分为两类，一类是有返回类型的，另外一类是无返回类型的，其基本结构定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionName</span><span class="params">(parameterList)</span></span>&#123;    <span class="comment">//无返回类型</span></span><br><span class="line">    <span class="built_in">statement</span>(s)</span><br><span class="line">    <span class="keyword">return</span>;   <span class="comment">//可选</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">typeName <span class="title">functionName</span><span class="params">(parameterList)</span></span>&#123;   <span class="comment">//有返回类型</span></span><br><span class="line">    <span class="built_in">statement</span>(s)</span><br><span class="line">    <span class="keyword">return</span> value;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于无返回类型，意思就是函数在执行完毕后，没有返回任何值，该函数常常被称为void函数，其返回语句是可选的。对于有返回类型的函数，必须使用返回语句，以便将值返回给调用语句。值的本身可以是常量、变量、表达式等等，只是其结果类型必须是typeName或者可以被转换成typeName的值。</p><h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h4><p>所谓的函数原型可以理解为函数的定义，在函数的原型中，描述了返回值的类型，以及入口参数的类型。使用原型的目的一方面在一般工程中，包含大量的文件，使用原型可以提高程序的执行效率，当程序执行到函数调用时，知道去哪个文件中巡查。另外一方面，使用函数原型可以提前告知程序内存占用的大小空间。总之在C++中，是必须要使用原型的，原型可以让编译器正确的处理函数的返回值，还可以检查使用的参数数目是否正确等等。</p><h3 id="函数参数和按值传递"><a href="#函数参数和按值传递" class="headerlink" title="函数参数和按值传递"></a>函数参数和按值传递</h3><p>函数参数也常常被称为入口参数，其数据的传递可以理解为按值传递，根据下面的程序，按值传递的过程大致理解为：首先定义int n,程序将会为该变量分配一定的内存，之后将n传入cheers函数中，这时cheers函数中将赋值n的值，从而进行相关计算。按值传递结束后，其定义的n值将不会改变。函数的参数个数可以是一个也可以是多个，在多个时，使用逗号分开。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line">     <span class="built_in">cheers</span>(n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cheers</span><span class="params">(<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数和数组"><a href="#函数和数组" class="headerlink" title="函数和数组"></a>函数和数组</h3><p>在程序中，数组和函数是一一对应的，例如int *arr和int arr[]属于等效的表达方式，在下面的语句中sum_arr(cookies,ArSize)的cookies其实是一个数组，在这里当作指针使用，传递的是第一个数据的地址。也可以对cookies+1表示的是第二个数据的地址。另外在函数中，可以有数组区间的函数，其意思就是数组的地址，比如向函数传入数组的第一个数据地址和某个中间数据的地址，依次来形成数组区间。</p><h4 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h4><p>在函数对数组进行操作时，C++默认是对复制值进行操作，而原始的数据不会发生改变，如果为了保险起见，可以使用const来保护数组的原始值。可以使用两种不同的方式将const用于指针，第一种方法是将指针指向一个常量对象，这样可以防止使用该指针来修改所指向的值，另外一种是将指针本身声明为常量，这样可以防止改变指针指向的位置。 C++中禁止将const值赋值给非const.在程序中，我们应该尽量使用const.可以避免由于修改数据而导致的编程错误。</p><h3 id="函数和C-风格字符串"><a href="#函数和C-风格字符串" class="headerlink" title="函数和C-风格字符串"></a>函数和C-风格字符串</h3><p>程序中可以将字符传作为参数传递给函数，表示字符串的方式有三种，第一种是char数组，第二种是用引号括起的字符常量，最后一种就是被设置成字符串的地址的char指针。在程序的返回类型中，可以返回一个指向字符串的指针，这样做效率高。但是在使用完成之后，需要使用delete来释放该字符串占用的内存。</p><h3 id="函数和结构"><a href="#函数和结构" class="headerlink" title="函数和结构"></a>函数和结构</h3><p>在函数中如果传递结构，有第三种方式，第一种是直接传递，这种效率高，但是如果结构大，则占用的内存大，另外一种方式是采用指针的方式，即传递数组的地址，这一种传递方式内存占有量小，比上一种好，最后一种传递方式是引用的方式。在使用指针传递结构时，需要注意入口参数是结构的地址，另外应使用间接成员运算符（-&gt;）来访问成员变量，而不使用成员运算符（句点）。</p><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>对于变量来讲，是有地址的，对于结构来讲，也是有地址的。对于函数来讲，程序中也是有地址的，有了函数的地址，我们就可以使用函数指针来调用函数。获取函数的地址也是非常简单，只要使用函数名（后面不跟参数）即可，例如think。另外就是在需要声明函数的返回类型以及函数的特征标。最后就是在程序中调用指针，例如:(*pf)(5)。总之C++函数名与函数地址作用相同，通过将函数地址作为参数，可以传递调用的函数的名称。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇笔记主要记录了C++的编程模块，其实就是了解函数与数组、指针、结构、string类之间的用法关系。记住const的概念，在函数传参时，传递的是数据的副本，最后要知道C++函数代码中可以包含对函数本身的调用。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记05：分支语句和逻辑运算符</title>
      <link href="/2023/11/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(05)/"/>
      <url>/2023/11/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(05)/</url>
      
        <content type="html"><![CDATA[<p>上一篇讨论了C++中的循环语句，其中要记住的就是循环语句构成的条件，这篇将讨论下程序中经常使用的逻辑运算以及条件语句的使用</p><span id="more"></span><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>在程序中，当我们对逻辑进行判断时，需要采用if条件语句。if语句既可以单独使用if，也可以与else联合使用，其定义的结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(test-expression)&#123;</span><br><span class="line">    statement1;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    statement2;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的大致流程为判断test-expression是否为true，如果为真，则执行statement1代码块，否则将执行statement2代码块。在使用该程序语句时，需要注意以下几个方面：</p><ul><li>如果要执行的代码块包含多个，需要用括号括起</li><li>程序采用是从上至下的顺序执行</li></ul><h3 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h3><p>C++语言中的逻辑表达式与C语言差不多，主要包含：逻辑OR运算符||、逻辑AND运算符&amp;&amp;、逻辑NOT运算符！。这三种逻辑表达式中，&amp;&amp;可以用来设置取值范围，注意在进行范围测试过程中，不能像数学那种直接使用&lt;后者&gt;号进行定义。对于逻辑运算符C++还有另外一种表示方式，采用and&#x2F;or&#x2F;not。</p><h3 id="字符函数库-cctype"><a href="#字符函数库-cctype" class="headerlink" title="字符函数库 cctype"></a>字符函数库 cctype</h3><p>C++从C语言继承了一个与字符相关、非常方便的函数软件包。这种软件包包含的函数可以实现确定字符是否为大写字母、数字、标点符号等工作，在使用之前需要包含cctype头文件。主要的几个字符函数库为：isalnum()判断参数是字母数字，如果是返回true，isalpha如果参数是字母，返回true;isdigit如果字母是数字，则返回true等等。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="?:运算符"></a>?:运算符</h3><p>使用这个?:运算符可以代替if else语句的功能，其定义格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression ? expression2 : expression3</span><br></pre></td></tr></table></figure><p>含义为如果expression为true,则程序执行expression2,否则执行expression3。</p><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>对于条件选择语句，除了使用if之外，还有一种条件选择方法，采用switch语句，其语句的定义结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(integer-expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> labell: <span class="built_in">statement</span>(s);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> labell: <span class="built_in">statement</span>(s);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">    ....</span><br><span class="line">    defualt     :<span class="built_in">statement</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行流程大致为程序根据integer-expression的值对case进行匹配。要求integer-expression必须是一个结果为结果为整数值的表达式。另外每个标签都必须是整形常量的表达式，常用的是int或者char。如果integer-expression的值与case没有匹配，则程序执行defualt下的语句。需要注意的是defualt语句不是必须的。</p><h3 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和continue语句</h3><p>break语句和continue语句都可以使程序跳过部分代码，其中如果在循环体中，使用这两个语句，区别在于continue会跳过循环体剩余的部分，开始新的一轮循环。break会跳过循环的剩余部分，到达下一条语句。</p><h3 id="简单文件输入输出"><a href="#简单文件输入输出" class="headerlink" title="简单文件输入输出"></a>简单文件输入输出</h3><p>对于文件I&#x2F;O来讲，循环和选择语句是很有用的工具；文件I&#x2F;O与控制台I&#x2F;O极其相似，声明ifstream和ofstream对象，并且将他们关联起来后，便可以像使用cin和cout那样使用这些对象。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章相对简单，算是对几种条件语句进行了简单的复习，重点应记住下break和continue的区别，另外C++可以声明ifstream和ofstream对象，采用inFile.open对文件关联后，对文件数据进行操作。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记04：循环和关系表达式</title>
      <link href="/2023/11/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(04)/"/>
      <url>/2023/11/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(04)/</url>
      
        <content type="html"><![CDATA[<p>在讨论完C++中变量的相关知识以后，从这篇开始，将讨论更加深入一点的内容，本篇将这着重讨论在程序语言中，使用非常频繁的循环和关系表达式。</p><span id="more"></span><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for循环是一种比较常见的循环结构，在我们对数组进行操作时，常常使用for循环使代码变得更加精简，for循环的基本结构定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; test-experssion; update-experssion)&#123;</span><br><span class="line">    body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该定义主要完成以下部分：设置初始值、执行测试判断循环是否执行、执行循环体、更新用于测试的值。C++中的for循环其实和C语言差不多，只不过还是需要注意以下几点：</p><ul><li>更新表达式是在循环体执行完毕后操作的</li><li>如果循环体包含多条程序语句，应使用括号将这几条语句包含在内</li><li>在for语句的括号中，三个表达式使用分号进行分割，不是使用逗号</li><li>可以在for循环的表达式中声明变量并且赋值，例如for(int i;i&lt;3;i++)</li><li>在对初始值变量进行声明时，可以使用逗号同时声明两个或者多个</li></ul><h4 id="update-expression"><a href="#update-expression" class="headerlink" title="update-expression"></a>update-expression</h4><p>在for循环的更新语句中，首先要知道可以利用表示式中的++或者–修改其步长，也就是将不仅可以一次加1还可以一次加n，另外在该语句中++i和i++是两种不用的语句，只不过结果一样，i++是使用i当前值计算表达式，++i是先将i加1，然后再使用新值来计算表达式。最后前缀格式和后缀格式相比，其运算效率更高。</p><h4 id="strcmp-函数"><a href="#strcmp-函数" class="headerlink" title="strcmp()函数"></a>strcmp()函数</h4><p>可以使用strcmp（str1,str2)函数来判断str1与str2是否相等，如果相等，则该函数返回false，如果不相等，则该返回值为true。也可以使用该函数对str1和str2进行排序，如果str1在str2的前面，则strcmp（str1,str2)&lt;0为true,反之为false。</p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>相比于for循环，while循环时没有初始化和更新部分的，它只有测试条件和循环体，这就意味着测试条件的变量需要提前声明，可以在循环体中，对循环变量进行操作。其定义的基本结构为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (test-expression)&#123;</span><br><span class="line">    body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while循环执行的顺序为，先判断test-expression中的条件是否满足，如果满足则返回true，反之false,只有在返回true的情况下，while循环才去执行循环体，循环体执行完毕后，再次对条件进行判断，如果条件不满足，返回false，则程序跳出while循环，执行下一条语句。<br>在设计循环时，应该采用下面的几条原则：</p><ul><li>指定循环的终止条件</li><li>在首次测试之前初始化条件</li><li>在条件被再次测试之前更新条件</li></ul><h3 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h3><p>do while循环属于出口条件循环，该循环先执行循环体，然后再判断循环条件，根据条件来决定是否下次还继续执行循环体，其定义的基本结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">   body;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (test-expression)</span><br></pre></td></tr></table></figure><h3 id="循环和文本输入"><a href="#循环和文本输入" class="headerlink" title="循环和文本输入"></a>循环和文本输入</h3><p>使用循环常用来完成对字符的输入和读取，可以使用cin对输入进行读取，但是cin对输入的空格没有回显，也就是会忽略空格，因此我们可以采用cin.get(char)进行补救。成员函数调用cin.get()返回下一个输入字符串-包括空格、换行符和制表符，因此可以这样使用它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin = cin.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure><p>cin.get(char)成员函数调用通过返回转换成false的bool值来指出已经到达EOF，而cin.get()成员函数调用则通过返回EOF值来指出已经到达的EOF，EOF是在文件iostream中定义的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇主要讨论了程序中几种循环方法的使用，对基本的定义和相关参数做了解释说明，还对循环文本输入做了简单介绍。下一篇将记录分支语句和逻辑运算符相关知识点。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记03：复合类型（二）</title>
      <link href="/2023/11/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(03)/"/>
      <url>/2023/11/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AC++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(03)/</url>
      
        <content type="html"><![CDATA[<p>在上一篇中，主要讨论了数组、字符串、String类以及结构体的定义和使用方法，这一遍文章将着重讨论枚举、指针以及内存管理等相关方面的内容。</p><span id="more"></span><h3 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h3><p>共用体是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种类型，其用法和结构体相似。其中用于之一是，当数据项使用两种或者更多种格式时，采用这种方法可以节省内存空间。</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举是一种新的创建符号常量的方式，可以代替const,与结构体定义相似，常用于定义相关符号常量，而不是新类型。但是需要遵循严格的使用限制。对于一般的枚举类型，其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">spectrum</span> &#123;red,orange,blue,yellow,violet,indigo&#125;;</span><br></pre></td></tr></table></figure><p>enum是定义枚举的符号，spectrum被称为枚举，{}里面的被称为枚举量，对于0-5。定义完成后在使用中需要注意以下几点：</p><ul><li>枚举量与枚举量之间可以进行相互赋值操作，但是不能将整形数据比如200赋值给red。</li><li>枚举量之间不能使用加减运算，例如：yellow &#x3D; red + blue;</li><li>枚举量在与数据进行加减时，可以转换成整形，例如 orange &#x3D; red + 1;</li><li>在定时枚举时，可以在枚举量后面进行赋值操作，在赋值之后，枚举将有一定的取值范围。</li></ul><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><h4 id="声明指针"><a href="#声明指针" class="headerlink" title="声明指针"></a>声明指针</h4><p>指针是一个变量，其存储的是值的地址，而不是本身。在指针中*被称为间接值或者解除引用。例如有如下的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * pin;</span><br></pre></td></tr></table></figure><p>其中pin是指针，存储变量的地址，*pin是解除引用，显示的是存储在该地址下的数值。可以采用&amp;符号将数据的存储地址赋值给pin,同时可以采取 *pin将该值再次显示出来。在对指针进行声明时，需要注意，在声明时系统分配了用来存储地址的内存，但是没有分配存储数据的内存，如果将 *pin &#x3D; 200;直接进行赋值，将导致程序危险发生，原因在于程序不知道将200存储在什么地址下面。</p><h4 id="指针和数字"><a href="#指针和数字" class="headerlink" title="指针和数字"></a>指针和数字</h4><p>指针和数字是两个不同的类型，数字可以进行加减运算，但是对指针加减是没有任何意义的。在用数字对指针进行地址赋值时，正确的方式是加上（int*),如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * pin;</span><br><span class="line">pin = (<span class="type">int</span>*)<span class="number">0xb8000000</span>;</span><br></pre></td></tr></table></figure><h4 id="指针和数组关系"><a href="#指针和数组关系" class="headerlink" title="指针和数组关系"></a>指针和数组关系</h4><p>由于指针算术和C++内部处理数组的方式原因，导致数组和指针基本上是等价的关系。对于指针算术则大概含义为指针变量加1后，是根据数据的类型将对应的地址加1.而C++内部处理数组的方式也基本类似，例如stack[1],程序是先找到存储第二个元素的地址，然后再读取该地址的值。*（stack +1 )与stack[1]是等价的。但是还是有一定区别的，区别之一在于指针可以修改值，而数组是常量。另外一个区别在于再使用sizeof运算符时，对数组是数组长度，对指针是指针长度，即可它指向一个数组。</p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="申请和释放内存"><a href="#申请和释放内存" class="headerlink" title="申请和释放内存"></a>申请和释放内存</h4><p>在程序运行过程中，需要对内存进行管理，C++提供了new和delete来管理内存，其中new表示申请一块内存，delete代表释放一块内存。在使用这两种方法时需要注意以下几点：</p><ul><li>new和delete要成对使用，在你申请完内存之后，必须释放内存，否则将会导致内存泄漏，如果泄漏严重，则会导致程序直接不会运行。</li><li>程序中的变量或者其他都是存储在被称为栈的内存区域中，而new申请的内存是从堆或者自由区域申请的</li><li>不要对声明的变量进行delet释放内存，而且如果声明的是数组[],还释放时，应使用delete [].</li></ul><h4 id="指针在内存的应用"><a href="#指针在内存的应用" class="headerlink" title="指针在内存的应用"></a>指针在内存的应用</h4><p>总之就是new和delete需要进行搭配使用。在对变量声明时，一种方式是采用在程序开始对变量的类型、数据进行声明，这种方式有一个缺点，如果声明的变量在程序当中没有使用，则仍然会占用一定的内存空间，对内存造成浪费。另外一种方式我们则可以采取new的方式在程序开始声明一个指针，该指针指向的地址是动态的，存储的值存储在未分配的内存空间中。例如先声明一个指针，并且分配了内存地址，该地址指向未分配的内存空间，在程序中，我们输入一个值存储在该空间下，当该值使用完毕后，我们可以释放该指针指向的内存空间，进而利用指针实现内存动态管理。</p><h4 id="三种存储方式"><a href="#三种存储方式" class="headerlink" title="三种存储方式"></a>三种存储方式</h4><p>C++有三种管理数据内存的方式：自动存储、静态存储、以及动态存储。其中自动存储只是在某个代码块中使用时，对声明的变量进行存储，当时该代码块执行完毕后，内存自动释放。静态存储是在程序执行的整个周期，动态存储则采用new和delete来对内存池进行管理。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux应用读取CPU温度</title>
      <link href="/2023/11/13/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%EF%BC%9A%E8%AF%BB%E5%8F%96CPU%E6%B8%A9%E5%BA%A6/"/>
      <url>/2023/11/13/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%EF%BC%9A%E8%AF%BB%E5%8F%96CPU%E6%B8%A9%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="获取CPU核心温度（龙芯3A处理器）"><a href="#获取CPU核心温度（龙芯3A处理器）" class="headerlink" title="获取CPU核心温度（龙芯3A处理器）"></a>获取CPU核心温度（龙芯3A处理器）</h3><p>本案例算是我的第一个Linux应用例程，非常简单，主要根据读取温度传感器寄存器地址的数值来换算成CPU的核心温度，涉及到物理地址和逻辑地址的转换。</p><h4 id="温度传感器寄存器地址"><a href="#温度传感器寄存器地址" class="headerlink" title="温度传感器寄存器地址"></a>温度传感器寄存器地址</h4><ul><li><p>3A500&#x2F;3A3000&#x2F;3A4000芯片物理地址和转换方法:</p><p><img src="/../img/%E8%8E%B7%E5%8F%96CPU%E6%A0%B8%E5%BF%83%E6%B8%A9%E5%BA%A6-1.png"></p></li><li><p>3A1000&#x2F;3A2000芯片物理地址和转换方法：</p><p><img src="/../img/%E8%8E%B7%E5%8F%96CPU%E6%A0%B8%E5%BF%83%E6%B8%A9%E5%BA%A6-2.png"></p></li><li><p>CPU温度传感器是集成内部，具体位置不知道，但是以Thsens0_out为主要参考对象；</p></li></ul><h4 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h4><ul><li><p>3A5000 + loongnix20:使用命令sensors</p><p><img src="/../img/%E8%8E%B7%E5%8F%96CPU%E6%A0%B8%E5%BF%83%E6%B8%A9%E5%BA%A6-3.png"></p></li><li><p>无sensors命令，则使用读取指定物理寄存器数值的方式获取，分成两种情况：</p><ul><li><p>第一种情况系统有busybox命令，则可以采用以下命令直接读取指定寄存器的数值；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo busybox devmem 0x1fe00198 64</span><br></pre></td></tr></table></figure></li><li><p>第二种情况，系统版本比较老旧，没有busybox命令，则可以采用编写应用程序的方式的实现。</p></li></ul></li><li><p>应用程序实现</p></li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FATAL do &#123; fprintf(stderr, <span class="string">&quot;Error at line %d, file %s (%d) [%s]\n&quot;</span>, \</span></span><br><span class="line"><span class="meta">  __LINE__, __FILE__, errno, strerror(errno)); exit(1); &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_SIZE 4096UL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_MASK (MAP_SIZE - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">void</span> *map_base, *virt_addr; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> read_result;</span><br><span class="line">    <span class="type">off_t</span> target;</span><br><span class="line">    <span class="type">int</span> Thsens0_out,Thsens1_out,s0_out,s1_out;</span><br><span class="line">    </span><br><span class="line">    target = strtoul(<span class="string">&quot;0x1fe00198&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);   <span class="comment">//3A2000 198</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fd = open(<span class="string">&quot;/dev/mem&quot;</span>, O_RDWR | O_SYNC)) == <span class="number">-1</span>) FATAL;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;/dev/mem opened.\n&quot;</span>); </span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    map_base = mmap(<span class="number">0</span>, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, target &amp; ~MAP_MASK);</span><br><span class="line">    <span class="keyword">if</span>(map_base == (<span class="type">void</span> *) <span class="number">-1</span>) FATAL;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Memory mapped at address %p.\n&quot;</span>, map_base); </span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    virt_addr = map_base + (target &amp; MAP_MASK);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    read_result = *((<span class="type">unsigned</span> <span class="type">long</span> *) virt_addr);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">    Thsens0_out = (read_result &gt;&gt; <span class="number">32</span>)&amp;<span class="number">0x0000ffff</span>;</span><br><span class="line">    Thsens1_out = read_result &gt;&gt; <span class="number">48</span>;</span><br><span class="line">    </span><br><span class="line">    s0_out = Thsens0_out * <span class="number">731</span> / <span class="number">0x4000</span> <span class="number">-273</span>;</span><br><span class="line">    s1_out = Thsens1_out * <span class="number">731</span> / <span class="number">0x4000</span> <span class="number">-273</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    Thsens0_out = (read_result &gt;&gt; <span class="number">32</span>)&amp;<span class="number">0x000000ff</span>;</span><br><span class="line">    Thsens1_out = (read_result &gt;&gt; <span class="number">40</span>) &amp; <span class="number">0x0000ff</span>;</span><br><span class="line">    </span><br><span class="line">    s0_out = Thsens0_out - <span class="number">100</span>;</span><br><span class="line">    s1_out = Thsens1_out - <span class="number">100</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value at address 0x%X (%p): 0x%llX\n&quot;</span>, target, virt_addr, read_result); </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thsens0_out=%x,Thsens1_out=%x\n&quot;</span>,Thsens0_out,Thsens1_out);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The temperature of cpu: s0_out =%d,s1_out=%d\n&quot;</span>,s0_out,s1_out);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(munmap(map_base, MAP_SIZE) == <span class="number">-1</span>) FATAL;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux应用开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPU温度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/11/06/hello-world/"/>
      <url>/2023/11/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
